COMPREHENSIVE SOURCE CODE DUMP
============================================================

FRONTEND SOURCE CODE
========================================

HOOKS
--------------------

******
UserMenu.tsx
frontend/src/UserMenu.tsx
******

import { ChevronDown, LogOut, Settings, User } from 'lucide-react';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { useNavigate } from 'react-router-dom';

import { useAuth } from '@/hooks/useAuth';

const UserMenu: React.FC = () => {
  const authContext = useAuth();
  const user = authContext.user;
  const logout = authContext.logout;
  const navigate = useNavigate();
  const [isOpen, setIsOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);

  // Close menu when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => { document.removeEventListener('mousedown', handleClickOutside); };
  }, []);

  const handleLogout = useCallback(() => {
    // Clear any stored tokens
    localStorage.removeItem('token');
    localStorage.removeItem('authToken'); // Remove old key if it exists
    logout();
    setIsOpen(false);
  }, [logout]);

  const handleAccountClick = useCallback(() => {
    setIsOpen(false);
    
    if (!user) return;
    
    // Route based on user role (less restrictive for development)
    if (user.role === 'admin') {
      void navigate('/admin-dashboard');
    } else if (user.role === 'affiliate') {
      void navigate('/affiliate-dashboard');
    } else {
      // For now, redirect customers to home page since client dashboard is not implemented
      // Fallback to home page for unknown roles
      void navigate('/');
    }
  }, [user, navigate]);

// ... (truncated 44 lines) ...

                e.preventDefault();
                handleAccountClick();
              }
            }}
            className="w-full flex items-center px-4 py-2 text-sm text-gray-700 hover:bg-gray-50 transition-colors duration-200"
            role="menuitem"
          >
            <User className="h-4 w-4 mr-3" />
            Account
          </button>
          
          <button
            onClick={() => { setIsOpen(false); }}
            onKeyDown={(e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                setIsOpen(false);
              }
            }}
            className="w-full flex items-center px-4 py-2 text-sm text-gray-700 hover:bg-gray-50 transition-colors duration-200"
            role="menuitem"
          >
            <Settings className="h-4 w-4 mr-3" />
            Settings
          </button>
          
          <hr className="my-1" />
          
          <button
            onClick={handleLogout}
            onKeyDown={(e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleLogout();
              }
            }}
            className="w-full flex items-center px-4 py-2 text-sm text-red-600 hover:bg-red-50 transition-colors duration-200"
            role="menuitem"
          >
            <LogOut className="h-4 w-4 mr-3" />
            Logout
          </button>
        </div>
      )}
    </div>
  );
};

export default UserMenu;


******
UsersTab.tsx
frontend/src/UsersTab.tsx
******

// Exports: function: UsersTab, component: UsersTab

import { Loader2, Trash2, UserCheck, UserCog, UserPlus, Users, UserX } from 'lucide-react';
import React, { useCallback, useEffect, useRef, useState } from 'react';

import { ApplicationModal, Toast } from '@/features/adminDashboard/components/shared';
import type { UserSubTab } from '@/features/adminDashboard/types';
import { apiService } from '@/services/api';
import { Button } from '@/shared/ui';
import { affiliateEventManager } from '@/utils/affiliateEvents';

interface User {
  id: number;
  name: string;
  email: string;
  role: string;
  created_at: string;
  business_name?: string;
  slug?: string;
}

interface PendingApplication {
  id: number;
  slug: string;
  business_name: string;
  owner: string;
  phone: string;
  email: string;
  city: string;
  state_code: string;
  postal_code: string;
  has_insurance: boolean;
  source: string;
  notes?: string;
  application_date: string;
  created_at: string;
}

export const UsersTab: React.FC = () => {
  const [activeSubTab, setActiveSubTab] = useState<UserSubTab>('all-users');
  const [users, setUsers] = useState<User[]>([]);
  const [pendingApplications, setPendingApplications] = useState<PendingApplication[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [modalState, setModalState] = useState<{
    isOpen: boolean;
    type: 'approve' | 'reject';
    applicationId: number;
    businessName: string;
  } | null>(null);
  const [processingApplication, setProcessingApplication] = useState(false);
  const [toast, setToast] = useState<{

// ... (truncated 434 lines) ...

              const Icon = subTab.icon;
              return (
                <button
                  key={subTab.id}
                  onClick={() => { handleSubTabChange(subTab.id); }}
                  className={`flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium transition-colors ${
                    activeSubTab === subTab.id
                      ? 'bg-blue-900 text-blue-300 border-b-2 border-blue-400'
                      : 'text-gray-300 hover:text-white hover:bg-gray-700'
                  }`}
                >
                  <Icon className="w-4 h-4" />
                  {subTab.label}
                </button>
              );
            })}
          </nav>
        </div>
        
        <div className="p-6">
          {renderSubTabContent(activeSubTab)}
        </div>
      </div>
      
      {/* Application Modal */}
      {modalState && (
        <ApplicationModal
          isOpen={modalState.isOpen}
          onClose={closeModal}
          onSubmit={handleModalSubmit}
          type={modalState.type}
          applicationId={modalState.applicationId}
          businessName={modalState.businessName}
          isLoading={processingApplication}
        />
      )}
      
      {/* Toast Notifications */}
      {toast && (
        <Toast
          message={toast.message}
          type={toast.type}
          isVisible={toast.isVisible}
          onClose={() => { setToast(null); }}
        />
      )}
    </div>
  );
};


******
useErrorBoundary.tsx
frontend/src/useErrorBoundary.tsx
******

// Exports: function: useErrorBoundary

import { useCallback, useEffect,useState } from 'react';

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export const useErrorBoundary = () => {
  const [errorState, setErrorState] = useState<ErrorBoundaryState>({ hasError: false });

  const handleError = useCallback((error: Error, errorInfo?: { componentStack?: string; errorBoundary?: string }) => {
    console.error('useErrorBoundary caught an error:', error, errorInfo);
    
    setErrorState({
      hasError: true,
      error
    });

    // Log to external service in production
    if (import.meta.env.PROD) {
      console.error('Production error:', { error, errorInfo });
    }
  }, []);

  const resetError = useCallback(() => {
    setErrorState({ hasError: false, error: undefined });
  }, []);

  // Global error handler
  useEffect(() => {
    const handleGlobalError = (event: ErrorEvent) => {
      const error = event.error instanceof Error ? event.error : new Error(event.message);
      handleError(error);
    };

    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
      const reason = typeof event.reason === 'string' ? event.reason : String(event.reason);
      handleError(new Error(reason));
    };

    window.addEventListener('error', handleGlobalError);
    window.addEventListener('unhandledrejection', handleUnhandledRejection);

    return () => {
      window.removeEventListener('error', handleGlobalError);
      window.removeEventListener('unhandledrejection', handleUnhandledRejection);
    };
  }, [handleError]);

  return {
    ...errorState,
    handleError,
    resetError
  };
};


******
UserMenu.tsx
frontend/UserMenu.tsx
******

import { ChevronDown, LogOut, Settings, User } from 'lucide-react';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { useNavigate } from 'react-router-dom';

import { useAuth } from '@/hooks/useAuth';

const UserMenu: React.FC = () => {
  const authContext = useAuth();
  const user = authContext.user;
  const logout = authContext.logout;
  const navigate = useNavigate();
  const [isOpen, setIsOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);

  // Close menu when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => { document.removeEventListener('mousedown', handleClickOutside); };
  }, []);

  const handleLogout = useCallback(() => {
    // Clear any stored tokens
    localStorage.removeItem('token');
    localStorage.removeItem('authToken'); // Remove old key if it exists
    logout();
    setIsOpen(false);
  }, [logout]);

  const handleAccountClick = useCallback(() => {
    setIsOpen(false);
    
    if (!user) return;
    
    // Route based on user role (less restrictive for development)
    if (user.role === 'admin') {
      void navigate('/admin-dashboard');
    } else if (user.role === 'affiliate') {
      void navigate('/affiliate-dashboard');
    } else {
      // For now, redirect customers to home page since client dashboard is not implemented
      // Fallback to home page for unknown roles
      void navigate('/');
    }
  }, [user, navigate]);

// ... (truncated 44 lines) ...

                e.preventDefault();
                handleAccountClick();
              }
            }}
            className="w-full flex items-center px-4 py-2 text-sm text-gray-700 hover:bg-gray-50 transition-colors duration-200"
            role="menuitem"
          >
            <User className="h-4 w-4 mr-3" />
            Account
          </button>
          
          <button
            onClick={() => { setIsOpen(false); }}
            onKeyDown={(e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                setIsOpen(false);
              }
            }}
            className="w-full flex items-center px-4 py-2 text-sm text-gray-700 hover:bg-gray-50 transition-colors duration-200"
            role="menuitem"
          >
            <Settings className="h-4 w-4 mr-3" />
            Settings
          </button>
          
          <hr className="my-1" />
          
          <button
            onClick={handleLogout}
            onKeyDown={(e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleLogout();
              }
            }}
            className="w-full flex items-center px-4 py-2 text-sm text-red-600 hover:bg-red-50 transition-colors duration-200"
            role="menuitem"
          >
            <LogOut className="h-4 w-4 mr-3" />
            Logout
          </button>
        </div>
      )}
    </div>
  );
};

export default UserMenu;


******
UsersTab.tsx
frontend/UsersTab.tsx
******

// Exports: function: UsersTab, component: UsersTab

import { Loader2, Trash2, UserCheck, UserCog, UserPlus, Users, UserX } from 'lucide-react';
import React, { useCallback, useEffect, useRef, useState } from 'react';

import { ApplicationModal, Toast } from '@/features/adminDashboard/components/shared';
import type { UserSubTab } from '@/features/adminDashboard/types';
import { apiService } from '@/services/api';
import { Button } from '@/shared/ui';
import { affiliateEventManager } from '@/utils/affiliateEvents';

interface User {
  id: number;
  name: string;
  email: string;
  role: string;
  created_at: string;
  business_name?: string;
  slug?: string;
}

interface PendingApplication {
  id: number;
  slug: string;
  business_name: string;
  owner: string;
  phone: string;
  email: string;
  city: string;
  state_code: string;
  postal_code: string;
  has_insurance: boolean;
  source: string;
  notes?: string;
  application_date: string;
  created_at: string;
}

export const UsersTab: React.FC = () => {
  const [activeSubTab, setActiveSubTab] = useState<UserSubTab>('all-users');
  const [users, setUsers] = useState<User[]>([]);
  const [pendingApplications, setPendingApplications] = useState<PendingApplication[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [modalState, setModalState] = useState<{
    isOpen: boolean;
    type: 'approve' | 'reject';
    applicationId: number;
    businessName: string;
  } | null>(null);
  const [processingApplication, setProcessingApplication] = useState(false);
  const [toast, setToast] = useState<{

// ... (truncated 434 lines) ...

              const Icon = subTab.icon;
              return (
                <button
                  key={subTab.id}
                  onClick={() => { handleSubTabChange(subTab.id); }}
                  className={`flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium transition-colors ${
                    activeSubTab === subTab.id
                      ? 'bg-blue-900 text-blue-300 border-b-2 border-blue-400'
                      : 'text-gray-300 hover:text-white hover:bg-gray-700'
                  }`}
                >
                  <Icon className="w-4 h-4" />
                  {subTab.label}
                </button>
              );
            })}
          </nav>
        </div>
        
        <div className="p-6">
          {renderSubTabContent(activeSubTab)}
        </div>
      </div>
      
      {/* Application Modal */}
      {modalState && (
        <ApplicationModal
          isOpen={modalState.isOpen}
          onClose={closeModal}
          onSubmit={handleModalSubmit}
          type={modalState.type}
          applicationId={modalState.applicationId}
          businessName={modalState.businessName}
          isLoading={processingApplication}
        />
      )}
      
      {/* Toast Notifications */}
      {toast && (
        <Toast
          message={toast.message}
          type={toast.type}
          isVisible={toast.isVisible}
          onClose={() => { setToast(null); }}
        />
      )}
    </div>
  );
};


******
useErrorBoundary.tsx
frontend/useErrorBoundary.tsx
******

// Exports: function: useErrorBoundary

import { useCallback, useEffect,useState } from 'react';

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export const useErrorBoundary = () => {
  const [errorState, setErrorState] = useState<ErrorBoundaryState>({ hasError: false });

  const handleError = useCallback((error: Error, errorInfo?: { componentStack?: string; errorBoundary?: string }) => {
    console.error('useErrorBoundary caught an error:', error, errorInfo);
    
    setErrorState({
      hasError: true,
      error
    });

    // Log to external service in production
    if (import.meta.env.PROD) {
      console.error('Production error:', { error, errorInfo });
    }
  }, []);

  const resetError = useCallback(() => {
    setErrorState({ hasError: false, error: undefined });
  }, []);

  // Global error handler
  useEffect(() => {
    const handleGlobalError = (event: ErrorEvent) => {
      const error = event.error instanceof Error ? event.error : new Error(event.message);
      handleError(error);
    };

    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
      const reason = typeof event.reason === 'string' ? event.reason : String(event.reason);
      handleError(new Error(reason));
    };

    window.addEventListener('error', handleGlobalError);
    window.addEventListener('unhandledrejection', handleUnhandledRejection);

    return () => {
      window.removeEventListener('error', handleGlobalError);
      window.removeEventListener('unhandledrejection', handleUnhandledRejection);
    };
  }, [handleError]);

  return {
    ...errorState,
    handleError,
    resetError
  };
};


CONTEXTS
--------------------

******
AffiliateContext.tsx
frontend/src/AffiliateContext.tsx
******

// Exports: function: AffiliateContext, function: AffiliateProvider, component: AffiliateContext, component: AffiliateProvider

import React, { createContext, type ReactNode, useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';

import { config } from '@/../config/env';

import { useLocation } from '../hooks/useLocation';

interface ServiceArea {
  city: string;
  state: string;
  zip?: number | null;
  primary: boolean;
  minimum: number;
  multiplier: number;
}

interface AffiliateData {
  id: number;
  slug: string;
  business_name: string;
  owner: string;
  email: string;
  phone: string;
  sms_phone: string;
  base_location: {
    city: string | null;
    state_code: string | null;
    state_name: string | null;
    zip: string | null;
    lat: number | null;
    lng: number | null;
  } | null;
  service_areas: ServiceArea[] | string | null;
  services: unknown;
  website_url: string;
  gbp_url: string;
  facebook_url: string;
  instagram_url: string;
  youtube_url: string;
  tiktok_url: string;
  application_status: string;
  has_insurance: boolean;
  source: string;
  notes: string;
  uploads: unknown;
  business_license: string;
  insurance_provider: string;
  insurance_expiry: string;
  service_radius_miles: number;
  operating_hours: unknown;

// ... (truncated 58 lines) ...

        setIsLoading(false);
      }
    };

    void fetchAffiliateData();
  }, [businessSlug]);

  // Update location when affiliate data loads (only if no valid location is currently selected)
  useEffect(() => {
    if (affiliateData?.service_areas) {
      // Only update location if no valid location is currently selected
      if (!selectedLocation.city || !selectedLocation.state) {
        // Parse service areas to find the primary location
        let serviceAreasData = affiliateData.service_areas;
        if (typeof serviceAreasData === 'string') {
          try {
            serviceAreasData = JSON.parse(serviceAreasData) as ServiceArea[];
          } catch (e) {
            console.error('Error parsing service_areas JSON:', e);
            return;
          }
        }
        
        if (Array.isArray(serviceAreasData)) {
          // Find the primary service area (only elements with primary: true)
          const primaryArea = serviceAreasData.find(area => area.primary);
          
          if (primaryArea && primaryArea.city && primaryArea.state) {
            // Update location with affiliate's primary service area
            updateLocationWithState(primaryArea.city, primaryArea.state);
          }
        }
      }
    }
  }, [affiliateData, updateLocationWithState, selectedLocation]);

  const value: AffiliateContextType = {
    affiliateData,
    isLoading,
    error,
    businessSlug,
  };

  return (
    <AffiliateContext.Provider value={value}>
      {children}
    </AffiliateContext.Provider>
  );
};


******
AuthContext.tsx
frontend/src/AuthContext.tsx
******

// Exports: function: AuthContext, function: AuthProvider, component: AuthContext, component: AuthProvider

import React, { createContext, useCallback, useEffect, useState } from 'react';

import { apiService } from '../services/api';
import { apiClient } from '../services/apiClient';

interface User {
  id: string;
  name: string;
  email: string;
  phone?: string | undefined;
  role: 'user' | 'affiliate' | 'admin';
  affiliate_id?: number | undefined;
}

export interface AuthContextType {
  user: User | null;
  isLoggedIn: boolean;
  login: (email: string, password: string) => Promise<{ success: boolean; error?: string }>;
  register: (email: string, password: string, name: string, phone?: string) => Promise<{ success: boolean; error?: string }>;
  logout: () => void;
  loading: boolean;
}

export const AuthContext = createContext<AuthContextType | null>(null);

// Helper function to map backend user data to frontend User interface
const mapBackendUserToFrontend = (backendUser: unknown): User => {
  const user = backendUser as {
    id: string;
    name: string;
    email: string;
    phone?: string;
    role?: 'user' | 'affiliate' | 'admin';
    is_admin?: boolean;
    affiliate_id?: number;
  };
  // Handle both backend API response format and saved user format
  let role: 'user' | 'affiliate' | 'admin' = 'user';
  
  if (user.role !== undefined) {
    // If role is already set (from saved user data)
    role = user.role;
  } else if (user.is_admin) {
    // If is_admin flag is present (from API response)
    role = 'admin';
  }
  
  return {
    id: user.id,
    name: user.name,

// ... (truncated 117 lines) ...

      }
      if (err.code === 'TIMEOUT') {
        return { success: false, error: 'Login request timed out. Please check your connection and try again.' };
      }
      if (err.code === 'NETWORK_ERROR') {
        return { success: false, error: 'Network error. Please check your connection and try again.' };
      }
      
      return { success: false, error: err.message || 'Network error occurred' };
    }
  };

  const register = async (email: string, password: string, name: string, phone?: string): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await apiService.register(email, password, name, phone);

      if (response.success) {
        const mappedUser = mapBackendUserToFrontend(response.user);
        setUser(mappedUser);
        localStorage.setItem('token', response.accessToken);
        localStorage.setItem('refreshToken', response.refreshToken);
        localStorage.setItem('user', JSON.stringify(mappedUser));
        return { success: true };
      } else {
        return { success: false, error: response.message || 'Registration failed' };
      }
    } catch (error: unknown) {
      const err = error as { code?: string; message?: string };
      // Handle specific error codes
      if (err.code === 'RATE_LIMITED') {
        return { success: false, error: `Rate limited: ${err.message ?? 'Unknown error'}` };
      }
      if (err.code === 'VALIDATION_ERROR') {
        return { success: false, error: err.message || 'Validation failed' };
      }
      
      return { success: false, error: err.message || 'Network error occurred' };
    }
  };

  const isLoggedIn = !!user;

  return (
    <AuthContext.Provider value={{ user, isLoggedIn, login, register, logout, loading }}>
      {children}
    </AuthContext.Provider>
  );
};



******
FAQContext.tsx
frontend/src/FAQContext.tsx
******

// Exports: function: FAQContext, function: FAQProvider, component: FAQContext, component: FAQProvider

import type { ReactNode } from 'react';
import React, { createContext, useState } from 'react';

export interface FAQContextType {
  isExpanded: boolean;
  setIsExpanded: (expanded: boolean) => void;
  expandFAQ: () => void;
  collapseFAQ: () => void;
  toggleFAQ: () => void;
}

export const FAQContext = createContext<FAQContextType | null>(null);

interface FAQProviderProps {
  children: ReactNode;
}

export const FAQProvider: React.FC<FAQProviderProps> = ({ children }) => {
  const [isExpanded, setIsExpanded] = useState(false);

  const expandFAQ = () => {
    setIsExpanded(true);
    // Scroll to FAQ section after a brief delay to ensure it's expanded
    setTimeout(() => {
      const faqSection = document.getElementById('faq');
      faqSection.scrollIntoView({ behavior: 'smooth' });
    }, 100);
  };

  const collapseFAQ = () => { setIsExpanded(false); };
  
  const toggleFAQ = () => { setIsExpanded(prev => !prev); };

  const value: FAQContextType = {
    isExpanded,
    setIsExpanded,
    expandFAQ,
    collapseFAQ,
    toggleFAQ,
  };

  return (
    <FAQContext.Provider value={value}>
      {children}
    </FAQContext.Provider>
  );
};



******
LocationContext.tsx
frontend/src/LocationContext.tsx
******

// Exports: function: LocationContext, function: LocationProvider, component: LocationContext, component: LocationProvider

import type { ReactNode } from 'react';
import React, { createContext, useEffect, useState } from 'react';

export interface LocationData {
  city: string;
  state: string;
  zipCode: string;
  fullLocation: string;
}

interface LocationContextType {
  selectedLocation: LocationData | null;
  setSelectedLocation: (location: LocationData | null) => void;
  clearLocation: () => void;
  updateLocationWithState: (city: string, state: string) => void;
  hasValidLocation: () => boolean;
}

export const LocationContext = createContext<LocationContextType | null>(null);

interface LocationProviderProps {
  children: ReactNode;
}

export const LocationProvider: React.FC<LocationProviderProps> = ({ children }) => {
  const [selectedLocation, setSelectedLocation] = useState<LocationData | null>(() => {
    try {
      const saved = localStorage.getItem('selectedLocation');
      if (saved) {
        const parsed = JSON.parse(saved) as LocationData;
        if (parsed.city && parsed.state) {
          return parsed;
        }
      }
    } catch (error) {
      console.error('Error loading location from localStorage:', error);
    }
    return null;
  });

  // Persist to localStorage whenever location changes
  useEffect(() => {
    if (selectedLocation.city && selectedLocation.state) {
      localStorage.setItem('selectedLocation', JSON.stringify(selectedLocation));
    } else {
      localStorage.removeItem('selectedLocation');
    }
  }, [selectedLocation]);

  // Listen for localStorage changes from other components (like business config)

// ... (truncated 24 lines) ...

          // Only update if we have complete location data and it's different from current
          if (parsed.city && parsed.state && 
              (!selectedLocation || 
               parsed.city !== selectedLocation.city || 
               parsed.state !== selectedLocation.state || 
               parsed.zipCode !== selectedLocation.zipCode)) {
            setSelectedLocation(parsed);
          }
        }
      } catch {
        // Ignore errors
      }
    }, 5000); // Increased interval to 5 seconds to reduce frequency

    return () => {
      window.removeEventListener('storage', handleStorageChange);
      clearInterval(interval);
    };
  }, [selectedLocation]); // Added selectedLocation as dependency to prevent stale closures

  const clearLocation = () => {
    setSelectedLocation(null);
  };

  const updateLocationWithState = (city: string, state: string) => {
    if (city && state) {
      // If no location is selected, or if the current location doesn't have a state, update it
      if (!selectedLocation || !selectedLocation.state) {
        const updatedLocation: LocationData = {
          city: city,
          state: state,
          zipCode: selectedLocation?.zipCode ?? '',
          fullLocation: `${city}, ${state}`
        };
        setSelectedLocation(updatedLocation);
      }
    }
  };

  const hasValidLocation = () => {
    return !!(selectedLocation.city && selectedLocation.state);
  };

  return (
    <LocationContext.Provider value={{ selectedLocation, setSelectedLocation, clearLocation, updateLocationWithState, hasValidLocation }}>
      {children}
    </LocationContext.Provider>
  );
};


******
MDHConfigContext.tsx
frontend/src/MDHConfigContext.tsx
******

// Exports: function: MDHConfigContext, function: MDHConfigProvider, component: MDHConfigContext, component: MDHConfigProvider

import type { ReactNode } from 'react';
import React, { createContext, useCallback, useEffect, useState } from 'react';

import { config } from '@/../config/env';

interface MDHConfig {
  email: string;
  phone: string;
  sms_phone?: string;
  logo_url: string;
  favicon_url: string;
  header_display: string;
  tagline: string;
  services_description: string;
  facebook: string;
  instagram: string;
  tiktok: string;
  youtube: string;
  created_at: string;
  updated_at: string;
}

// Static config interface to match mdh-config.js
interface StaticMDHConfig {
  name: string;
  url: string;
  logo: string;
  phone: string;
  email: string;
  socials: {
    facebook: string;
    instagram: string;
    youtube: string;
    tiktok: string;
  };
  header_display: string;
  tagline: string;
  services_description: string;
  logo_url: string;
  favicon_url: string;
  ogImage: string;
  created_at: string;
  updated_at: string;
}

// Extend Window interface to include __MDH__ property
declare global {
  interface Window {
    __MDH__?: StaticMDHConfig;
  }

// ... (truncated 72 lines) ...

        setIsLoading(false);
        return;
      }

      // Use global promise if already fetching
      if (globalConfigPromise !== null) {
        const data = await globalConfigPromise;
        setMdhConfig(data);
        setIsLoading(false);
        return;
      }

      // Create new fetch promise
      globalConfigPromise = fetchMDHConfig();
      const data = await globalConfigPromise;
      
      // Cache the result globally
      globalConfigCache = data;
      globalConfigPromise = null;
      
      setMdhConfig(data);
    } catch (err) {
      console.error('Error refreshing MDH config:', err);
      setError(err instanceof Error ? err.message : 'Failed to refresh MDH config');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    // Only fetch if we don't have static config and haven't cached anything
    if (mdhConfig === null && globalConfigCache === null && globalConfigPromise === null) {
      void refreshConfig();
    }
  }, [mdhConfig, refreshConfig]);

  const value: MDHConfigContextType = {
    mdhConfig,
    isLoading,
    error,
    refreshConfig,
  };

  return (
    <MDHConfigContext.Provider value={value}>
      {children}
    </MDHConfigContext.Provider>
  );
};


******
AffiliateContext.tsx
frontend/AffiliateContext.tsx
******

// Exports: function: AffiliateContext, function: AffiliateProvider, component: AffiliateContext, component: AffiliateProvider

import React, { createContext, type ReactNode, useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';

import { config } from '@/../config/env';

import { useLocation } from '../hooks/useLocation';

interface ServiceArea {
  city: string;
  state: string;
  zip?: number | null;
  primary: boolean;
  minimum: number;
  multiplier: number;
}

interface AffiliateData {
  id: number;
  slug: string;
  business_name: string;
  owner: string;
  email: string;
  phone: string;
  sms_phone: string;
  base_location: {
    city: string | null;
    state_code: string | null;
    state_name: string | null;
    zip: string | null;
    lat: number | null;
    lng: number | null;
  } | null;
  service_areas: ServiceArea[] | string | null;
  services: unknown;
  website_url: string;
  gbp_url: string;
  facebook_url: string;
  instagram_url: string;
  youtube_url: string;
  tiktok_url: string;
  application_status: string;
  has_insurance: boolean;
  source: string;
  notes: string;
  uploads: unknown;
  business_license: string;
  insurance_provider: string;
  insurance_expiry: string;
  service_radius_miles: number;
  operating_hours: unknown;

// ... (truncated 58 lines) ...

        setIsLoading(false);
      }
    };

    void fetchAffiliateData();
  }, [businessSlug]);

  // Update location when affiliate data loads (only if no valid location is currently selected)
  useEffect(() => {
    if (affiliateData?.service_areas) {
      // Only update location if no valid location is currently selected
      if (!selectedLocation.city || !selectedLocation.state) {
        // Parse service areas to find the primary location
        let serviceAreasData = affiliateData.service_areas;
        if (typeof serviceAreasData === 'string') {
          try {
            serviceAreasData = JSON.parse(serviceAreasData) as ServiceArea[];
          } catch (e) {
            console.error('Error parsing service_areas JSON:', e);
            return;
          }
        }
        
        if (Array.isArray(serviceAreasData)) {
          // Find the primary service area (only elements with primary: true)
          const primaryArea = serviceAreasData.find(area => area.primary);
          
          if (primaryArea && primaryArea.city && primaryArea.state) {
            // Update location with affiliate's primary service area
            updateLocationWithState(primaryArea.city, primaryArea.state);
          }
        }
      }
    }
  }, [affiliateData, updateLocationWithState, selectedLocation]);

  const value: AffiliateContextType = {
    affiliateData,
    isLoading,
    error,
    businessSlug,
  };

  return (
    <AffiliateContext.Provider value={value}>
      {children}
    </AffiliateContext.Provider>
  );
};


******
AuthContext.tsx
frontend/AuthContext.tsx
******

// Exports: function: AuthContext, function: AuthProvider, component: AuthContext, component: AuthProvider

import React, { createContext, useCallback, useEffect, useState } from 'react';

import { apiService } from '../services/api';
import { apiClient } from '../services/apiClient';

interface User {
  id: string;
  name: string;
  email: string;
  phone?: string | undefined;
  role: 'user' | 'affiliate' | 'admin';
  affiliate_id?: number | undefined;
}

export interface AuthContextType {
  user: User | null;
  isLoggedIn: boolean;
  login: (email: string, password: string) => Promise<{ success: boolean; error?: string }>;
  register: (email: string, password: string, name: string, phone?: string) => Promise<{ success: boolean; error?: string }>;
  logout: () => void;
  loading: boolean;
}

export const AuthContext = createContext<AuthContextType | null>(null);

// Helper function to map backend user data to frontend User interface
const mapBackendUserToFrontend = (backendUser: unknown): User => {
  const user = backendUser as {
    id: string;
    name: string;
    email: string;
    phone?: string;
    role?: 'user' | 'affiliate' | 'admin';
    is_admin?: boolean;
    affiliate_id?: number;
  };
  // Handle both backend API response format and saved user format
  let role: 'user' | 'affiliate' | 'admin' = 'user';
  
  if (user.role !== undefined) {
    // If role is already set (from saved user data)
    role = user.role;
  } else if (user.is_admin) {
    // If is_admin flag is present (from API response)
    role = 'admin';
  }
  
  return {
    id: user.id,
    name: user.name,

// ... (truncated 117 lines) ...

      }
      if (err.code === 'TIMEOUT') {
        return { success: false, error: 'Login request timed out. Please check your connection and try again.' };
      }
      if (err.code === 'NETWORK_ERROR') {
        return { success: false, error: 'Network error. Please check your connection and try again.' };
      }
      
      return { success: false, error: err.message || 'Network error occurred' };
    }
  };

  const register = async (email: string, password: string, name: string, phone?: string): Promise<{ success: boolean; error?: string }> => {
    try {
      const response = await apiService.register(email, password, name, phone);

      if (response.success) {
        const mappedUser = mapBackendUserToFrontend(response.user);
        setUser(mappedUser);
        localStorage.setItem('token', response.accessToken);
        localStorage.setItem('refreshToken', response.refreshToken);
        localStorage.setItem('user', JSON.stringify(mappedUser));
        return { success: true };
      } else {
        return { success: false, error: response.message || 'Registration failed' };
      }
    } catch (error: unknown) {
      const err = error as { code?: string; message?: string };
      // Handle specific error codes
      if (err.code === 'RATE_LIMITED') {
        return { success: false, error: `Rate limited: ${err.message ?? 'Unknown error'}` };
      }
      if (err.code === 'VALIDATION_ERROR') {
        return { success: false, error: err.message || 'Validation failed' };
      }
      
      return { success: false, error: err.message || 'Network error occurred' };
    }
  };

  const isLoggedIn = !!user;

  return (
    <AuthContext.Provider value={{ user, isLoggedIn, login, register, logout, loading }}>
      {children}
    </AuthContext.Provider>
  );
};



******
FAQContext.tsx
frontend/FAQContext.tsx
******

// Exports: function: FAQContext, function: FAQProvider, component: FAQContext, component: FAQProvider

import type { ReactNode } from 'react';
import React, { createContext, useState } from 'react';

export interface FAQContextType {
  isExpanded: boolean;
  setIsExpanded: (expanded: boolean) => void;
  expandFAQ: () => void;
  collapseFAQ: () => void;
  toggleFAQ: () => void;
}

export const FAQContext = createContext<FAQContextType | null>(null);

interface FAQProviderProps {
  children: ReactNode;
}

export const FAQProvider: React.FC<FAQProviderProps> = ({ children }) => {
  const [isExpanded, setIsExpanded] = useState(false);

  const expandFAQ = () => {
    setIsExpanded(true);
    // Scroll to FAQ section after a brief delay to ensure it's expanded
    setTimeout(() => {
      const faqSection = document.getElementById('faq');
      faqSection.scrollIntoView({ behavior: 'smooth' });
    }, 100);
  };

  const collapseFAQ = () => { setIsExpanded(false); };
  
  const toggleFAQ = () => { setIsExpanded(prev => !prev); };

  const value: FAQContextType = {
    isExpanded,
    setIsExpanded,
    expandFAQ,
    collapseFAQ,
    toggleFAQ,
  };

  return (
    <FAQContext.Provider value={value}>
      {children}
    </FAQContext.Provider>
  );
};



******
LocationContext.tsx
frontend/LocationContext.tsx
******

// Exports: function: LocationContext, function: LocationProvider, component: LocationContext, component: LocationProvider

import type { ReactNode } from 'react';
import React, { createContext, useEffect, useState } from 'react';

export interface LocationData {
  city: string;
  state: string;
  zipCode: string;
  fullLocation: string;
}

interface LocationContextType {
  selectedLocation: LocationData | null;
  setSelectedLocation: (location: LocationData | null) => void;
  clearLocation: () => void;
  updateLocationWithState: (city: string, state: string) => void;
  hasValidLocation: () => boolean;
}

export const LocationContext = createContext<LocationContextType | null>(null);

interface LocationProviderProps {
  children: ReactNode;
}

export const LocationProvider: React.FC<LocationProviderProps> = ({ children }) => {
  const [selectedLocation, setSelectedLocation] = useState<LocationData | null>(() => {
    try {
      const saved = localStorage.getItem('selectedLocation');
      if (saved) {
        const parsed = JSON.parse(saved) as LocationData;
        if (parsed.city && parsed.state) {
          return parsed;
        }
      }
    } catch (error) {
      console.error('Error loading location from localStorage:', error);
    }
    return null;
  });

  // Persist to localStorage whenever location changes
  useEffect(() => {
    if (selectedLocation.city && selectedLocation.state) {
      localStorage.setItem('selectedLocation', JSON.stringify(selectedLocation));
    } else {
      localStorage.removeItem('selectedLocation');
    }
  }, [selectedLocation]);

  // Listen for localStorage changes from other components (like business config)

// ... (truncated 24 lines) ...

          // Only update if we have complete location data and it's different from current
          if (parsed.city && parsed.state && 
              (!selectedLocation || 
               parsed.city !== selectedLocation.city || 
               parsed.state !== selectedLocation.state || 
               parsed.zipCode !== selectedLocation.zipCode)) {
            setSelectedLocation(parsed);
          }
        }
      } catch {
        // Ignore errors
      }
    }, 5000); // Increased interval to 5 seconds to reduce frequency

    return () => {
      window.removeEventListener('storage', handleStorageChange);
      clearInterval(interval);
    };
  }, [selectedLocation]); // Added selectedLocation as dependency to prevent stale closures

  const clearLocation = () => {
    setSelectedLocation(null);
  };

  const updateLocationWithState = (city: string, state: string) => {
    if (city && state) {
      // If no location is selected, or if the current location doesn't have a state, update it
      if (!selectedLocation || !selectedLocation.state) {
        const updatedLocation: LocationData = {
          city: city,
          state: state,
          zipCode: selectedLocation?.zipCode ?? '',
          fullLocation: `${city}, ${state}`
        };
        setSelectedLocation(updatedLocation);
      }
    }
  };

  const hasValidLocation = () => {
    return !!(selectedLocation.city && selectedLocation.state);
  };

  return (
    <LocationContext.Provider value={{ selectedLocation, setSelectedLocation, clearLocation, updateLocationWithState, hasValidLocation }}>
      {children}
    </LocationContext.Provider>
  );
};


******
MDHConfigContext.tsx
frontend/MDHConfigContext.tsx
******

// Exports: function: MDHConfigContext, function: MDHConfigProvider, component: MDHConfigContext, component: MDHConfigProvider

import type { ReactNode } from 'react';
import React, { createContext, useCallback, useEffect, useState } from 'react';

import { config } from '@/../config/env';

interface MDHConfig {
  email: string;
  phone: string;
  sms_phone?: string;
  logo_url: string;
  favicon_url: string;
  header_display: string;
  tagline: string;
  services_description: string;
  facebook: string;
  instagram: string;
  tiktok: string;
  youtube: string;
  created_at: string;
  updated_at: string;
}

// Static config interface to match mdh-config.js
interface StaticMDHConfig {
  name: string;
  url: string;
  logo: string;
  phone: string;
  email: string;
  socials: {
    facebook: string;
    instagram: string;
    youtube: string;
    tiktok: string;
  };
  header_display: string;
  tagline: string;
  services_description: string;
  logo_url: string;
  favicon_url: string;
  ogImage: string;
  created_at: string;
  updated_at: string;
}

// Extend Window interface to include __MDH__ property
declare global {
  interface Window {
    __MDH__?: StaticMDHConfig;
  }

// ... (truncated 72 lines) ...

        setIsLoading(false);
        return;
      }

      // Use global promise if already fetching
      if (globalConfigPromise !== null) {
        const data = await globalConfigPromise;
        setMdhConfig(data);
        setIsLoading(false);
        return;
      }

      // Create new fetch promise
      globalConfigPromise = fetchMDHConfig();
      const data = await globalConfigPromise;
      
      // Cache the result globally
      globalConfigCache = data;
      globalConfigPromise = null;
      
      setMdhConfig(data);
    } catch (err) {
      console.error('Error refreshing MDH config:', err);
      setError(err instanceof Error ? err.message : 'Failed to refresh MDH config');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    // Only fetch if we don't have static config and haven't cached anything
    if (mdhConfig === null && globalConfigCache === null && globalConfigPromise === null) {
      void refreshConfig();
    }
  }, [mdhConfig, refreshConfig]);

  const value: MDHConfigContextType = {
    mdhConfig,
    isLoading,
    error,
    refreshConfig,
  };

  return (
    <MDHConfigContext.Provider value={value}>
      {children}
    </MDHConfigContext.Provider>
  );
};




BACKEND SOURCE CODE
========================================



DEPLOYMENT CONFIGURATIONS
========================================

--------------------
Platform: unknown
Config Files: package.json
Platforms Detected: package

BUILD SETTINGS
--------------------
FRONTEND:
  dev: vite
  build: vite build
  lint: eslint .
  lint:fix: eslint . --fix
  preview: vite preview
  test: vitest
  test:ui: vitest --ui
  optimize-images: node scripts/convert-images.js
  prebuild: npm run optimize-images
  check-pages: node scripts/check-pages-usage.js
  lint:pages: eslint . --rule 'import/no-restricted-paths: error'

BACKEND:
  start: node server.js
  start:prod: node server.js
  dev: nodemon server.js
  test: echo "Error: no test specified" && exit 1

No deployment configuration files found.
Checked for: vercel.json, render.yaml, Dockerfile, netlify.toml, etc.

