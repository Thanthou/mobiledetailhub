BACKEND FILES CONTENT
==================================================

FILE: backend\package.json
------------------------------
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "start:prod": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "express-rate-limit": "^8.0.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.2",
    "pg": "^8.16.3",
    "retry": "^0.13.1",
    "uuid": "^11.1.0",
    "winston": "^3.15.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}


==================================================

FILE: backend\README.md
------------------------------
# Backend Setup

## Environment Variables

Create a `.env` file in the backend directory with the following variables:

```bash
# Database Configuration
DATABASE_URL=postgresql://username:password@localhost:5432/database_name

# JWT Secret (for authentication)
JWT_SECRET=your-secret-key-here

# Admin Emails (comma-separated)
ADMIN_EMAILS=admin@example.com,admin2@example.com

# Server Port (optional, defaults to 3001)
PORT=3001
```

## Database Setup

1. Ensure PostgreSQL is running
2. Create a database named `MobileDetailHub` (or update DATABASE_URL)
3. Run the setup script: `node server.js` (this will create tables automatically)

## Running the Server

```bash
npm install
npm run dev  # for development with nodemon
npm start    # for production
```

## API Endpoints

### Health & Status
- `GET /api/health` - Comprehensive health check with database status
- `GET /api/health/live` - Liveness check (process responsive, always 200 if event loop working)
- `GET /api/health/ready` - Readiness check (database connectivity + migration status)
- `GET /api/health/db-status` - Database connection status only
- `GET /api/health/test-db` - Simple database connection test
- `GET /api/health/migrations` - Migration status and history

### Core Services
- `GET /api/service_areas` - Get service areas (with fallback data)
- `GET /api/test` - Test endpoint

## Database Connection Features

### ✅ **Improved Error Handling**
- **No more crashes**: Database connection failures no longer cause `process.exit(-1)`
- **Automatic retry**: Built-in retry logic with exponential backoff
- **Graceful degradation**: Application continues running even when database is unavailable

### ✅ **Connection Management**
- **Health monitoring**: Real-time connection pool status
- **Auto-reconnection**: Automatic reconnection on connection failures
- **Graceful shutdown**: Proper cleanup on application termination

### ✅ **Developer Tools**
- **Helper utilities**: `executeQuery()`, `executeTransaction()`, `isConnected()`
- **Connection status**: Detailed pool metrics and health information
- **Migration guide**: Complete guide for updating existing code

## Troubleshooting

### Database Connection Issues
1. **Check if PostgreSQL is running**
2. **Verify DATABASE_URL in .env file**
3. **Ensure the database exists**
4. **Check the server logs for detailed error messages**

### Health Check System (Liveness vs Readiness)

The application now provides proper separation of liveness and readiness checks for container orchestration:

#### Liveness Endpoint (`/api/health/live`)
- **Purpose**: Check if the process is responsive
- **Response**: Always returns 200 if event loop is working
- **Use case**: Kubernetes liveness probes, container health checks
- **Checks**: Process uptime, memory usage, PID

#### Readiness Endpoint (`/api/health/ready`)
- **Purpose**: Check if service is ready to receive traffic
- **Response**: 200 if ready, 503 if not ready
- **Use case**: Kubernetes readiness probes, load balancer health checks
- **Checks**: Database connectivity, circuit breaker status, migration version

#### Usage Examples
```bash
# Liveness check (always 200 if process is up)
curl http://localhost:3001/api/health/live

# Readiness check (200 if ready, 503 if not ready)
curl http://localhost:3001/api/health/ready

# Comprehensive health check
curl http://localhost:3001/api/health

# Migration status
curl http://localhost:3001/api/health/migrations
```

### Migration Tracking

The system now tracks database schema versions:
- Automatic creation of `schema_migrations` table
- Version history tracking with timestamps
- Integration with readiness checks
- Utility script for recording migrations: `node scripts/record_migration.js <version> <description>`

### Connection Retry Logic
The system automatically retries failed connections:
- **Initial delay**: 1 second
- **Maximum retries**: 5 attempts
- **Backoff strategy**: Exponential (1s, 2s, 4s, 8s, 16s)
- **Maximum delay cap**: 30 seconds

## Migration Guide

If you're updating existing code to use the new database connection pattern, see:
- [`docs/DATABASE_CONNECTION_MIGRATION.md`](docs/DATABASE_CONNECTION_MIGRATION.md) - Complete migration guide
- [`utils/dbHelper.js`](utils/dbHelper.js) - Helper utility functions
- [`database/connection.js`](database/connection.js) - New connection management

## Performance Monitoring

The health endpoints provide real-time metrics:
- Database connection status
- Query response times
- Connection pool utilization
- Memory usage
- Application uptime


==================================================

FILE: backend\server.js
------------------------------
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');

// Import environment validator
const { validateEnvironment } = require('./utils/envValidator');
const logger = require('./utils/logger');

// Import route modules
const healthRoutes = require('./routes/health');
const serviceAreasRoutes = require('./routes/serviceAreas');
const authRoutes = require('./routes/auth');
const affiliatesRoutes = require('./routes/affiliates');
const mdhConfigRoutes = require('./routes/mdhConfig');
const customersRoutes = require('./routes/customers');
const adminRoutes = require('./routes/admin');
const uploadRoutes = require('./routes/upload');

// Get the update function from health routes
const { updateShutdownStatus } = healthRoutes;

// Import middleware
const { errorHandler, notFoundHandler } = require('./middleware/errorHandler');
const { apiLimiter, authLimiter, adminLimiter } = require('./middleware/rateLimiter');
const { requestLogger } = require('./middleware/requestLogger');

// Import database utilities
const { setupDatabase } = require('./utils/databaseInit');
const { waitForConnection, closePool } = require('./database/connection');

// Import upload validation utilities
const { validateUploadRequest } = require('./utils/uploadValidator');

// Validate CORS configuration on boot
const validateCorsConfig = () => {
  if (process.env.NODE_ENV === 'production') {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',').filter(origin => origin.trim()) || [];
    if (allowedOrigins.length === 0) {
      logger.error('FATAL: ALLOWED_ORIGINS is empty in production environment');
      logger.error('Please set ALLOWED_ORIGINS environment variable with comma-separated domains');
      process.exit(1);
    }
    logger.info(`Production CORS configured with ${allowedOrigins.length} allowed origins`);
  }
};

// Validate environment variables before starting server
try {
  validateEnvironment();
} catch (error) {
  logger.error('Environment validation failed:', { error: error.message });
  process.exit(1);
}

// Validate CORS configuration
validateCorsConfig();

const app = express();
const PORT = process.env.PORT || 3001;

// Server instance for graceful shutdown
let server = null;

// Graceful shutdown state management
let isShuttingDown = false;
let activeRequests = new Map(); // Map to store request promises
let statusUpdateInterval = null; // Interval for status updates

// Request tracking middleware
const requestTracker = (req, res, next) => {
  // Allow health endpoints during shutdown for monitoring
  if (isShuttingDown && !req.path.startsWith('/api/health')) {
    return res.status(503).json({
      error: 'Service Unavailable',
      message: 'Server is shutting down, please try again later'
    });
  }

  const requestId = Date.now() + Math.random();
  const requestPromise = new Promise((resolve) => {
    let resolved = false;
    
    const cleanup = () => {
      if (!resolved) {
        resolved = true;
        activeRequests.delete(requestId);
        resolve();
      }
    };
    
    // Track request completion
    res.on('finish', cleanup);
    res.on('close', cleanup);
    res.on('error', cleanup);
    
    // Fallback: resolve after a reasonable timeout
    setTimeout(cleanup, 30000); // 30 seconds max
  });
  
  activeRequests.set(requestId, requestPromise);
  next();
};

// CORS configuration based on environment
const corsOptions = {
  origin: function (origin, callback) {
    // Allow requests with no origin (like mobile apps or Postman)
    if (!origin) return callback(null, true);
    
    const allowedOrigins = [];
    
    if (process.env.NODE_ENV === 'production') {
      // Production: Only allow specific production domains
      const prodDomains = process.env.ALLOWED_ORIGINS?.split(',').filter(origin => origin.trim()) || [];
      allowedOrigins.push(...prodDomains);
    } else if (process.env.NODE_ENV === 'staging') {
      // Staging: Allow staging domains + localhost
      const stagingDomains = process.env.ALLOWED_ORIGINS?.split(',').filter(origin => origin.trim()) || [];
      allowedOrigins.push(...stagingDomains, 'http://localhost:3000', 'http://localhost:5173');
    } else {
      // Development: Allow localhost and common dev ports
      allowedOrigins.push(
        'http://localhost:3000',
        'http://localhost:5173',
        'http://localhost:4173',
        'http://127.0.0.1:3000',
        'http://127.0.0.1:5173',
        'http://127.0.0.1:4173'
      );
    }
    
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      logger.warn(`CORS blocked request from unauthorized origin: ${origin}`);
      // Return proper CORS headers even when denying
      callback(new Error('Not allowed by CORS'));
    }
  },
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: false, // Disable credentials to prevent token leakage
  optionsSuccessStatus: 200, // Some legacy browsers choke on 204
  preflightContinue: false, // Ensure preflight requests are handled properly
  maxAge: 86400 // Cache preflight response for 24 hours
};

// Middleware
app.use(cors(corsOptions));
app.use(requestLogger); // Add request logging with correlation IDs and PII scrubbing
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"],
      styleSrc: ["'self'"],
      imgSrc: [
        "'self'",
        "data:",
        "https://*.mobiledetailhub.com"
      ],
      connectSrc: [
        "'self'",
        "https://*.mobiledetailhub.com"
      ],
      fontSrc: ["'self'", "data:"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
      baseUri: ["'self'"],
      formAction: ["'self'"],
      frameAncestors: ["'none'"],
      upgradeInsecureRequests: []
    },
    reportOnly: false
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  noSniff: true,
  frameguard: {
    action: 'deny'
  },
  hidePoweredBy: true,
  ienoopen: true,
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
}));
app.use(express.json({ limit: '1mb' })); // Limit request body size
app.use(express.urlencoded({ extended: true, limit: '1mb' })); // Limit URL-encoded body size

// Enhanced request validation middleware
const requestValidationMiddleware = (req, res, next) => {
  // Check if server is shutting down (allow health endpoints for monitoring)
  if (isShuttingDown && !req.path.startsWith('/api/health')) {
    return res.status(503).json({
      error: 'Service Unavailable',
      message: 'Server is shutting down, please try again later'
    });
  }
  
  // Content-Type validation for POST/PUT requests
  if (['POST', 'PUT', 'PATCH'].includes(req.method)) {
    const contentType = req.headers['content-type'];
    
    if (!contentType) {
      return res.status(400).json({
        error: 'Content-Type header is required',
        message: 'Please specify the content type for your request'
      });
    }

    // MIME type allowlist for JSON and form data
    const allowedMimeTypes = [
      'application/json',
      'application/x-www-form-urlencoded',
      'multipart/form-data' // For future file uploads
    ];

    const isValidMimeType = allowedMimeTypes.some(allowedType => 
      contentType.startsWith(allowedType)
    );

    if (!isValidMimeType) {
      logger.warn(`Invalid Content-Type rejected: ${contentType} from ${req.ip}`);
      return res.status(415).json({
        error: 'Unsupported Media Type',
        message: 'Only JSON, form data, and multipart form data are supported',
        allowedTypes: allowedMimeTypes
      });
    }

    // Enhanced validation for multipart/form-data (future uploads)
    if (contentType.startsWith('multipart/form-data')) {
      const uploadValidation = validateUploadRequest(req);
      if (!uploadValidation.success) {
        logger.warn(`Multipart validation failed: ${uploadValidation.errors.join(', ')} from ${req.ip}`);
        return res.status(400).json({
          error: 'Invalid multipart data',
          message: uploadValidation.errors.join(', '),
          warnings: uploadValidation.warnings
        });
      }
    }
  }

  // Request size validation (additional check beyond express limits)
  const contentLength = parseInt(req.headers['content-length'] || '0');
  const maxSize = 1024 * 1024; // 1MB in bytes
  
  if (contentLength > maxSize) {
    logger.warn(`Request too large rejected: ${contentLength} bytes from ${req.ip}`);
    return res.status(413).json({
      error: 'Payload Too Large',
      message: 'Request body exceeds maximum allowed size of 1MB',
      maxSize: '1MB',
      receivedSize: `${Math.round(contentLength / 1024)}KB`
    });
  }

  next();
};

app.use(requestValidationMiddleware);
app.use(requestTracker); // Apply request tracking middleware

// Apply rate limiting to specific route groups
// Note: Auth and admin routes have their own stricter limiters
app.use('/api/health', apiLimiter);
app.use('/api/service_areas', apiLimiter);
app.use('/api/affiliates', apiLimiter);
app.use('/api/mdh-config', apiLimiter);
app.use('/api/customers', apiLimiter);

// Routes
app.use('/api/health', healthRoutes);
app.use('/api/service_areas', serviceAreasRoutes);
app.use('/api/auth', authLimiter, authRoutes); // Apply auth rate limiting
app.use('/api/affiliates', affiliatesRoutes);
app.use('/api/mdh-config', mdhConfigRoutes);
app.use('/api/customers', customersRoutes);
app.use('/api/admin', adminLimiter, adminRoutes); // Apply admin rate limiting
app.use('/api/upload', apiLimiter, uploadRoutes); // Apply upload rate limiting

// Error handling middleware (must be last)
app.use(notFoundHandler);
app.use(errorHandler);

// Start server
server = app.listen(PORT, async () => {
  // Check if we're already shutting down
  if (isShuttingDown) {
    logger.warn('Server startup cancelled - shutdown in progress');
    return;
  }
  
  logger.startup(`Server running on port ${PORT}`);
  
  // Wait for database connection to be established
  logger.info('Waiting for database connection...');
  try {
    const pool = await waitForConnection();
    logger.info('Database connection ready, setting up database...');
    
    // Setup database and initialize sample data
    await setupDatabase();
    logger.info('Database setup completed successfully');
    logger.startup('Server is fully ready and operational!');
    
    // Start periodic shutdown status updates
    statusUpdateInterval = setInterval(() => {
      updateShutdownStatus({
        isShuttingDown,
        activeRequests: activeRequests.size
      });
    }, 1000); // Update every second
  } catch (err) {
    logger.error('Failed to setup database:', { error: err.message });
  }
});

// Graceful shutdown function
async function gracefulShutdown(signal) {
  logger.info(`Received ${signal}, starting graceful shutdown...`);
  
  isShuttingDown = true; // Set flag to prevent new requests
  logger.info(`${activeRequests.size} active requests will be allowed to complete.`);

  // Wait for active requests to complete with timeout
  if (activeRequests.size > 0) {
    const timeout = 10000; // 10 seconds timeout
    const timeoutPromise = new Promise(resolve => setTimeout(resolve, timeout));
    
    try {
      await Promise.race([
        Promise.all(Array.from(activeRequests.values())),
        timeoutPromise
      ]);
      logger.info('All active requests have completed successfully');
    } catch (error) {
      logger.warn('Some requests may not have completed within timeout');
    }
  } else {
    logger.info('No active requests to wait for');
  }

  // Stop accepting new connections
  if (server) {
    const serverClosePromise = new Promise((resolve) => {
      server.close(() => {
        logger.info('HTTP server closed');
        resolve();
      });
    });
    
    // Wait for server to close with timeout
    const serverCloseTimeout = new Promise(resolve => setTimeout(resolve, 5000));
    await Promise.race([serverClosePromise, serverCloseTimeout]);
  }
  
  // Clear status update interval
  if (statusUpdateInterval) {
    clearInterval(statusUpdateInterval);
    statusUpdateInterval = null;
  }
  
  // Close database pool
  try {
    await closePool();
    logger.info('Database pool closed');
  } catch (error) {
    logger.error('Error closing database pool:', { error: error.message });
  }
  
  // Flush logger and exit
  try {
    // Final status update
    updateShutdownStatus({
      isShuttingDown: true,
      activeRequests: 0
    });
    
    // Give logger time to flush any pending writes
    await new Promise(resolve => setTimeout(resolve, 1000));
    logger.info('Graceful shutdown completed');
    process.exit(0);
  } catch (error) {
    logger.error('Error during shutdown:', { error: error.message });
    process.exit(1);
  }
}

// Signal handlers for graceful shutdown
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception:', { error: error.message, stack: error.stack });
  gracefulShutdown('uncaughtException');
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection:', { reason: reason?.message || reason, promise });
  gracefulShutdown('unhandledRejection');
});

==================================================

