BACKEND FILES CONTENT
==================================================

FILE: backend\check-table-locations.js
------------------------------
require('dotenv').config();
const { pool } = require('./database/pool');

async function checkTableLocations() {
  try {
    console.log('üîç Checking refresh_tokens table locations...');
    
    // Check all schemas for refresh_tokens table
    const result = await pool.query(`
      SELECT table_schema, table_name, 
             (SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = t.table_schema AND table_name = t.table_name) as column_count
      FROM information_schema.tables t
      WHERE table_name = 'refresh_tokens'
      ORDER BY table_schema
    `);
    
    if (result.rows.length > 0) {
      console.log('‚úÖ Found refresh_tokens tables:');
      result.rows.forEach(row => {
        console.log(`  - ${row.table_schema}.${row.table_name} (${row.column_count} columns)`);
      });
    } else {
      console.log('‚ùå No refresh_tokens tables found');
    }
    
    // Check if there's a view in public schema
    const viewResult = await pool.query(`
      SELECT table_name, table_type
      FROM information_schema.tables 
      WHERE table_schema = 'public' AND table_name = 'refresh_tokens'
    `);
    
    if (viewResult.rows.length > 0) {
      console.log('üìã Public schema has:', viewResult.rows[0].table_type);
    }
    
  } catch (error) {
    console.log('‚ùå Error:', error.message);
  } finally {
    await pool.end();
  }
}

checkTableLocations();


==================================================

FILE: backend\checkAffiliates.js
------------------------------
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function checkAffiliates() {
  try {
    console.log('üîç Checking affiliates in database...');
    const result = await pool.query('SELECT id, business_name, email FROM affiliates ORDER BY id');
    
    console.log('‚úÖ Affiliates found:', result.rows.length);
    result.rows.forEach(row => {
      console.log(`  ID: ${row.id}, Name: ${row.business_name}, Email: ${row.email}`);
    });
    
    if (result.rows.length === 0) {
      console.log('‚ö†Ô∏è  No affiliates found in database');
    }
    
  } catch (error) {
    console.error('‚ùå Error checking affiliates:', error.message);
  } finally {
    await pool.end();
  }
}

checkAffiliates();


==================================================

FILE: backend\createTestAffiliate.js
------------------------------
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

async function createTestAffiliate() {
  try {
    console.log('üîß Creating test affiliate...');
    
    // Check if affiliate already exists
    const checkQuery = "SELECT id FROM affiliates WHERE email = 'test@example.com'";
    const existing = await pool.query(checkQuery);
    
    if (existing.rows.length > 0) {
      console.log('‚úÖ Test affiliate already exists with ID:', existing.rows[0].id);
      return existing.rows[0].id;
    }
    
    // Create test affiliate
    const insertQuery = `
      INSERT INTO affiliates (business_name, email, phone, address_json, service_radius_miles, active)
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING id
    `;
    
    const testAffiliate = {
      business_name: 'Test Mobile Detail Pro',
      email: 'test@example.com',
      phone: '(555) 123-4567',
      address_json: { city: 'Test City', state: 'TS' },
      service_radius_miles: 25,
      active: true
    };
    
    const result = await pool.query(insertQuery, [
      testAffiliate.business_name,
      testAffiliate.email,
      testAffiliate.phone,
      JSON.stringify(testAffiliate.address_json),
      testAffiliate.service_radius_miles,
      testAffiliate.active
    ]);
    
    const affiliateId = result.rows[0].id;
    console.log('‚úÖ Test affiliate created with ID:', affiliateId);
    return affiliateId;
    
  } catch (error) {
    console.error('‚ùå Error creating test affiliate:', error.message);
    throw error;
  } finally {
    await pool.end();
  }
}

createTestAffiliate();


==================================================

FILE: backend\fix-auth-schema.js
------------------------------
require('dotenv').config();
const { pool } = require('./database/pool');

async function fixAuthSchema() {
  try {
    console.log('üîß Setting up auth schema and refresh_tokens table...');
    
    // Create auth schema if it doesn't exist
    await pool.query('CREATE SCHEMA IF NOT EXISTS auth');
    console.log('‚úÖ auth schema created/verified');
    
    // Check if refresh_tokens table exists in auth schema
    const checkTable = await pool.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'auth' AND table_name = 'refresh_tokens'
    `);
    
    if (checkTable.rows.length === 0) {
      console.log('üîß Creating refresh_tokens table in auth schema...');
      
      // Create the refresh_tokens table in auth schema
      await pool.query(`
        CREATE TABLE auth.refresh_tokens (
          id SERIAL PRIMARY KEY,
          user_id INTEGER NOT NULL,
          token_hash VARCHAR(255) NOT NULL UNIQUE,
          expires_at TIMESTAMPTZ NOT NULL,
          revoked_at TIMESTAMPTZ NULL,
          created_at TIMESTAMPTZ DEFAULT NOW(),
          ip_address INET,
          user_agent TEXT,
          device_id VARCHAR(16)
        )
      `);
      
      console.log('‚úÖ refresh_tokens table created in auth schema');
      
      // Add foreign key constraint to users table (assuming it's in public schema)
      await pool.query(`
        ALTER TABLE auth.refresh_tokens 
        ADD CONSTRAINT refresh_tokens_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE
      `);
      
      console.log('‚úÖ Foreign key constraint added');
      
      // Create indexes for better performance
      await pool.query(`
        CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON auth.refresh_tokens(user_id)
      `);
      
      await pool.query(`
        CREATE INDEX IF NOT EXISTS idx_refresh_tokens_token_hash ON auth.refresh_tokens(token_hash)
      `);
      
      await pool.query(`
        CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires_at ON auth.refresh_tokens(expires_at)
      `);
      
      await pool.query(`
        CREATE INDEX IF NOT EXISTS idx_refresh_tokens_device_id ON auth.refresh_tokens(device_id)
      `);
      
      console.log('‚úÖ Indexes created');
    } else {
      console.log('‚úÖ refresh_tokens table already exists in auth schema');
    }
    
    // Create a view in public schema for backward compatibility
    await pool.query(`
      CREATE OR REPLACE VIEW public.refresh_tokens AS 
      SELECT * FROM auth.refresh_tokens
    `);
    
    console.log('‚úÖ Public view created for backward compatibility');
    
    // Verify the setup
    const result = await pool.query(`
      SELECT column_name, data_type, is_nullable
      FROM information_schema.columns 
      WHERE table_schema = 'auth' AND table_name = 'refresh_tokens'
      ORDER BY ordinal_position
    `);
    
    console.log('üìã Table structure:');
    result.rows.forEach(row => {
      console.log(`  - ${row.column_name}: ${row.data_type} (${row.is_nullable === 'YES' ? 'nullable' : 'not null'})`);
    });
    
    console.log('‚úÖ Auth schema and refresh_tokens table setup complete!');
    
  } catch (error) {
    console.log('‚ùå Error:', error.message);
    if (error.code === '23503') {
      console.log('üí° This might be because the users table doesn\'t exist yet');
    }
  } finally {
    await pool.end();
  }
}

fixAuthSchema();


==================================================

FILE: backend\package.json
------------------------------
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "start:prod": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^1.11.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "express-rate-limit": "^8.0.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.2",
    "pg": "^8.16.3",
    "uuid": "^11.1.0",
    "winston": "^3.15.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}


==================================================

FILE: backend\README.md
------------------------------
# Backend Setup

## Environment Variables

Create a `.env` file in the backend directory with the following variables:

```bash
# Database Configuration
DATABASE_URL=postgresql://username:password@localhost:5432/database_name

# JWT Secret (for authentication)
JWT_SECRET=your-secret-key-here

# Admin Emails (comma-separated)
ADMIN_EMAILS=admin@example.com,admin2@example.com

# Server Port (optional, defaults to 3001)
PORT=3001
```

## Database Setup

1. Ensure PostgreSQL is running
2. Create a database named `MobileDetailHub` (or update DATABASE_URL)
3. Run the setup script: `node server.js` (this will create tables automatically)

## Running the Server

```bash
npm install
npm run dev  # for development with nodemon
npm start    # for production
```

## API Endpoints

### Health & Status
- `GET /api/health` - Comprehensive health check with database status
- `GET /api/health/live` - Liveness check (process responsive, always 200 if event loop working)
- `GET /api/health/ready` - Readiness check (database connectivity)
- `GET /api/health/db-status` - Database connection status only
- `GET /api/health/test-db` - Simple database connection test


### Core Services
- `GET /api/service_areas` - Get service areas (with fallback data)
- `GET /api/test` - Test endpoint

## Database Connection Features

### ‚úÖ **Simple & Reliable**
- **Single pool**: Global PostgreSQL pool configured from `DATABASE_URL`
- **Fast boot**: 1-second database ping on startup, fails fast if unavailable
- **Direct queries**: Simple `pool.query()` calls throughout the application

### ‚úÖ **Built-in PostgreSQL Management** 
- **Auto-reconnection**: PostgreSQL driver handles connection recovery
- **Pool management**: Automatic connection pooling with configurable limits
- **Graceful shutdown**: Clean pool closure with `pool.end()`

### ‚úÖ **Developer Tools**
- **Timeout helper**: `query()` function with per-call timeout (default 5s)
- **Health endpoints**: Fast readiness checks with 250ms timeout
- **Environment validation**: DATABASE_URL format and SSL validation

## Troubleshooting

### Database Connection Issues
1. **Check if PostgreSQL is running**
2. **Verify DATABASE_URL in .env file**
3. **Ensure the database exists**
4. **Check the server logs for detailed error messages**

### Health Check System (Liveness vs Readiness)

The application now provides proper separation of liveness and readiness checks for container orchestration:

#### Liveness Endpoint (`/api/health/live`)
- **Purpose**: Check if the process is responsive
- **Response**: Always returns 200 if event loop is working
- **Use case**: Kubernetes liveness probes, container health checks
- **Checks**: Process uptime, memory usage, PID

#### Readiness Endpoint (`/api/health/ready`)
- **Purpose**: Check if service is ready to receive traffic
- **Response**: 200 if ready, 503 if not ready
- **Use case**: Kubernetes readiness probes, load balancer health checks
- **Checks**: Database connectivity with 250ms timeout

#### Usage Examples
```bash
# Liveness check (always 200 if process is up)
curl http://localhost:3001/api/health/live

# Readiness check (200 if ready, 503 if not ready)
curl http://localhost:3001/api/health/ready

# Comprehensive health check
curl http://localhost:3001/api/health

# Database status  
curl http://localhost:3001/api/health/db-status
```



### Database Configuration
Simple pool configuration using PostgreSQL's built-in connection management:
- **Connection string**: Single `DATABASE_URL` environment variable
- **Pool limits**: 20 max connections, 30s idle timeout, 10s connection timeout
- **SSL support**: Automatic SSL enablement in production environments
- **Error handling**: Simple logging via `pool.on('error')` event

## Database Usage

### Direct Pool Usage (Recommended)
```javascript
const pool = require('./database/pool');

// Simple query
const result = await pool.query('SELECT * FROM users WHERE id = $1', [userId]);

// With transaction
const client = await pool.connect();
try {
  await client.query('BEGIN');
  await client.query('INSERT INTO users (name) VALUES ($1)', [name]);
  await client.query('COMMIT');
} finally {
  client.release();
}
```

### With Timeout Helper
```javascript
const { query } = require('./utils/db');

// Query with 3-second timeout
const result = await query('SELECT * FROM users', [], { timeoutMs: 3000 });
```

### Migration Guide
- [`docs/DATABASE_CONNECTION_MIGRATION.md`](docs/DATABASE_CONNECTION_MIGRATION.md) - Migration from complex connection manager
- [`utils/dbHelper.js`](utils/dbHelper.js) - Legacy helper utilities (still supported)
- [`database/pool.js`](database/pool.js) - Simple pool configuration

## Performance Monitoring

The health endpoints provide simple, fast metrics:
- **Live endpoint**: Process responsiveness (always 200 if running)
- **Ready endpoint**: Database ping with 250ms timeout (200/503)
- **Health endpoint**: Query timing and basic pool metrics
- **Pool status**: Connection counts (total, idle, waiting)


==================================================

FILE: backend\server.js
------------------------------
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');

// Import environment validator
const { validateEnvironment } = require('./utils/envValidator');
const logger = require('./utils/logger');

// Import route modules
const healthRoutes = require('./routes/health');
const serviceAreasRoutes = require('./routes/serviceAreas');
const authRoutes = require('./routes/auth');
const affiliatesRoutes = require('./routes/affiliates');
const mdhConfigRoutes = require('./routes/mdhConfig');
const customersRoutes = require('./routes/customers');
const adminRoutes = require('./routes/admin');
const uploadRoutes = require('./routes/upload');
const servicesRoutes = require('./routes/services');

// Get the update function from health routes
const { updateShutdownStatus } = healthRoutes;

// Import middleware
const { errorHandler, notFoundHandler } = require('./middleware/errorHandler');
const { apiLimiter, authLimiter, adminLimiter } = require('./middleware/rateLimiter');
const { requestLogger } = require('./middleware/requestLogger');

// Import database utilities
const { setupDatabase } = require('./utils/databaseInit');
const { pool } = require('./database/pool');

// Import upload validation utilities
const { validateUploadRequest } = require('./utils/uploadValidator');

// Validate CORS configuration on boot
const validateCorsConfig = () => {
  if (process.env.NODE_ENV === 'production') {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',').filter(origin => origin.trim()) || [];
    if (allowedOrigins.length === 0) {
      logger.error('FATAL: ALLOWED_ORIGINS is empty in production environment');
      logger.error('Please set ALLOWED_ORIGINS environment variable with comma-separated domains');
      process.exit(1);
    }
    logger.info(`Production CORS configured with ${allowedOrigins.length} allowed origins`);
  }
};

// Validate environment variables before starting server
try {
  validateEnvironment();
} catch (error) {
  logger.error('Environment validation failed:', { error: error.message });
  process.exit(1);
}

/**
 * Single source of truth for CORS allowed origins
 * 
 * This ensures consistency across all environments and prevents
 * CORS issues when switching between different dev ports.
 * 
 * Development ports covered:
 * - 3000: React dev server (default)
 * - 5173: Vite dev server (default) 
 * - 5174: Vite dev server (alternate)
 * - 4173: Vite preview server
 * - 127.0.0.1 variants for all ports
 */
const ALLOWED_ORIGINS = {
  development: [
    'http://localhost:3000',    // React dev server (default)
    'http://localhost:5173',    // Vite dev server (default)
    'http://localhost:5174',    // Vite dev server (alternate)
    'http://localhost:4173',    // Vite preview server
    'http://127.0.0.1:3000',   // React dev server (IP variant)
    'http://127.0.0.1:5173',   // Vite dev server (IP variant)
    'http://127.0.0.1:5174',   // Vite dev server (IP variant, alternate)
    'http://127.0.0.1:4173'    // Vite preview server (IP variant)
  ],
  staging: [
    // Staging domains from environment + localhost for testing
    ...(process.env.ALLOWED_ORIGINS?.split(',').filter(origin => origin.trim()) || []),
    'http://localhost:3000',
    'http://localhost:5173'
  ],
  production: process.env.ALLOWED_ORIGINS?.split(',').filter(origin => origin.trim()) || []
};

// Validate CORS configuration
validateCorsConfig();

// Log CORS configuration for current environment
const currentEnv = process.env.NODE_ENV || 'development';
const currentOrigins = ALLOWED_ORIGINS[currentEnv] || ALLOWED_ORIGINS.development;
logger.info(`CORS configured for ${currentEnv} environment with ${currentOrigins.length} allowed origins`);
if (currentEnv === 'development') {
  logger.info('Development origins:', currentOrigins);
}

const app = express();
const PORT = process.env.PORT || 3001;

// Server instance for graceful shutdown
let server = null;

// Graceful shutdown state management
let isShuttingDown = false;
let activeRequests = new Map(); // Map to store request promises
let statusUpdateInterval = null; // Interval for status updates

// Request tracking middleware
const requestTracker = (req, res, next) => {
  // Allow health endpoints during shutdown for monitoring
  if (isShuttingDown && !req.path.startsWith('/api/health')) {
    return res.status(503).json({
      error: 'Service Unavailable',
      message: 'Server is shutting down, please try again later'
    });
  }

  const requestId = Date.now() + Math.random();
  const requestPromise = new Promise((resolve) => {
    let resolved = false;
    
    const cleanup = () => {
      if (!resolved) {
        resolved = true;
        activeRequests.delete(requestId);
        resolve();
      }
    };
    
    // Track request completion
    res.on('finish', cleanup);
    res.on('close', cleanup);
    res.on('error', cleanup);
    
    // Fallback: resolve after a reasonable timeout
    setTimeout(cleanup, 30000); // 30 seconds max
  });
  
  activeRequests.set(requestId, requestPromise);
  next();
};

// CORS configuration based on environment
const corsOptions = {
  origin: function (origin, callback) {
    // Allow requests with no origin (like mobile apps or Postman)
    if (!origin) return callback(null, true);
    
    const environment = process.env.NODE_ENV || 'development';
    const allowedOrigins = ALLOWED_ORIGINS[environment] || ALLOWED_ORIGINS.development;
    
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      logger.warn(`CORS blocked request from unauthorized origin: ${origin}`, {
        environment,
        allowedOrigins: allowedOrigins.length
      });
      // Return proper CORS headers even when denying
      callback(new Error('Not allowed by CORS'));
    }
  },
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: false, // Disable credentials to prevent token leakage
  optionsSuccessStatus: 200, // Some legacy browsers choke on 204
  preflightContinue: false, // Ensure preflight requests are handled properly
  maxAge: 86400 // Cache preflight response for 24 hours
};

// Middleware
app.use(cors(corsOptions));
app.use(requestLogger); // Add request logging with correlation IDs and PII scrubbing
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"],
      styleSrc: ["'self'"],
      imgSrc: [
        "'self'",
        "data:",
        "https://*.mobiledetailhub.com"
      ],
      connectSrc: [
        "'self'",
        "https://*.mobiledetailhub.com"
      ],
      fontSrc: ["'self'", "data:"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
      baseUri: ["'self'"],
      formAction: ["'self'"],
      frameAncestors: ["'none'"],
      upgradeInsecureRequests: []
    },
    reportOnly: false
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  noSniff: true,
  frameguard: {
    action: 'deny'
  },
  hidePoweredBy: true,
  ienoopen: true,
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
}));
app.use(express.json({ limit: '1mb' })); // Limit request body size
app.use(express.urlencoded({ extended: true, limit: '1mb' })); // Limit URL-encoded body size

// Serve static files with caching
// Note: mdh-config.js is cached for 24 hours to ensure instant header/footer loading
app.use('/js/mdh-config.js', (req, res, next) => {
  // Set long-term cache headers for the static config file
  res.set({
    'Cache-Control': 'public, max-age=86400, s-maxage=86400', // 24 hours
    'ETag': '"mdh-config-static"',
    'Vary': 'Accept-Encoding'
  });
  next();
});
app.use('/js', express.static('frontend/public/js'));

// Enhanced request validation middleware
const requestValidationMiddleware = (req, res, next) => {
  // Check if server is shutting down (allow health endpoints for monitoring)
  if (isShuttingDown && !req.path.startsWith('/api/health')) {
    return res.status(503).json({
      error: 'Service Unavailable',
      message: 'Server is shutting down, please try again later'
    });
  }
  
  // Content-Type validation for POST/PUT requests
  if (['POST', 'PUT', 'PATCH'].includes(req.method)) {
    const contentType = req.headers['content-type'];
    
    if (!contentType) {
      return res.status(400).json({
        error: 'Content-Type header is required',
        message: 'Please specify the content type for your request'
      });
    }

    // MIME type allowlist for JSON and form data
    const allowedMimeTypes = [
      'application/json',
      'application/x-www-form-urlencoded',
      'multipart/form-data' // For future file uploads
    ];

    const isValidMimeType = allowedMimeTypes.some(allowedType => 
      contentType.startsWith(allowedType)
    );

    if (!isValidMimeType) {
      logger.warn(`Invalid Content-Type rejected: ${contentType} from ${req.ip}`);
      return res.status(415).json({
        error: 'Unsupported Media Type',
        message: 'Only JSON, form data, and multipart form data are supported',
        allowedTypes: allowedMimeTypes
      });
    }

    // Enhanced validation for multipart/form-data (future uploads)
    if (contentType.startsWith('multipart/form-data')) {
      const uploadValidation = validateUploadRequest(req);
      if (!uploadValidation.success) {
        logger.warn(`Multipart validation failed: ${uploadValidation.errors.join(', ')} from ${req.ip}`);
        return res.status(400).json({
          error: 'Invalid multipart data',
          message: uploadValidation.errors.join(', '),
          warnings: uploadValidation.warnings
        });
      }
    }
  }

  // Request size validation (additional check beyond express limits)
  const contentLength = parseInt(req.headers['content-length'] || '0');
  const maxSize = 1024 * 1024; // 1MB in bytes
  
  if (contentLength > maxSize) {
    logger.warn(`Request too large rejected: ${contentLength} bytes from ${req.ip}`);
    return res.status(413).json({
      error: 'Payload Too Large',
      message: 'Request body exceeds maximum allowed size of 1MB',
      maxSize: '1MB',
      receivedSize: `${Math.round(contentLength / 1024)}KB`
    });
  }

  next();
};

app.use(requestValidationMiddleware);
app.use(requestTracker); // Apply request tracking middleware

// NOTE: Global API limiter removed.
// Apply per-route limiters ONLY on sensitive endpoints (auth/admin/uploads).
// Example elsewhere:
// router.post('/login', authLimiter, asyncHandler(loginHandler));
// router.post('/refresh', refreshLimiter, asyncHandler(refreshHandler));

// Read-only endpoints are NOT rate-limited to prevent slow header/footer performance
// app.use('/api/health', apiLimiter); // REMOVED - read-only endpoint
// app.use('/api/service_areas', apiLimiter); // REMOVED - read-only endpoint
// app.use('/api/affiliates', apiLimiter); // DISABLED - read-only endpoint
// app.use('/api/mdh-config', apiLimiter); // DISABLED - read-only endpoint
// app.use('/api/customers', apiLimiter); // REMOVED - read-only endpoint

// Routes
app.use('/api/health', healthRoutes);
app.use('/api/service_areas', serviceAreasRoutes);
app.use('/api/auth', authLimiter, authRoutes); // Apply auth rate limiting
app.use('/api/affiliates', affiliatesRoutes);
app.use('/api/mdh-config', mdhConfigRoutes);
app.use('/api/customers', customersRoutes);
app.use('/api/admin', adminLimiter, adminRoutes); // Apply admin rate limiting
app.use('/api/upload', apiLimiter, uploadRoutes); // Apply upload rate limiting
app.use('/api/services', servicesRoutes);

// Error handling middleware (must be last)
app.use(notFoundHandler);
app.use(errorHandler);

// Quick database connectivity check before starting server
async function startServer() {
  logger.info('Testing database connection...');
  try {
    // Quick ping with 1 second timeout
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Database ping timeout')), 1000)
    );
    
    await Promise.race([
      pool.query('SELECT 1'),
      timeoutPromise
    ]);
    
    logger.info('‚úÖ Database ping successful');
  } catch (error) {
    logger.error('‚ùå Database ping failed:', { error: error.message });
    process.exit(1);
  }

  // Setup database after successful ping
  logger.info('Setting up database...');
  try {
    await setupDatabase();
    logger.info('‚úÖ Database setup completed successfully');
  } catch (error) {
    logger.error('‚ùå Database setup failed:', { error: error.message });
    process.exit(1);
  }

  // Start server after successful database setup
  server = app.listen(PORT, () => {
    // Check if we're already shutting down
    if (isShuttingDown) {
      logger.warn('Server startup cancelled - shutdown in progress');
      return;
    }
    
    logger.startup(`Server running on port ${PORT}`);
    logger.startup('Server is fully ready and operational!');
    
    // Start periodic shutdown status updates
    statusUpdateInterval = setInterval(() => {
      updateShutdownStatus({
        isShuttingDown,
        activeRequests: activeRequests.size
      });
    }, 1000); // Update every second
  });
}

// Start the server
startServer();

// Graceful shutdown function
async function gracefulShutdown(signal) {
  logger.info(`Received ${signal}, starting graceful shutdown...`);
  
  isShuttingDown = true; // Set flag to prevent new requests
  logger.info(`${activeRequests.size} active requests will be allowed to complete.`);

  // Wait for active requests to complete with timeout
  if (activeRequests.size > 0) {
    const timeout = 10000; // 10 seconds timeout
    const timeoutPromise = new Promise(resolve => setTimeout(resolve, timeout));
    
    try {
      await Promise.race([
        Promise.all(Array.from(activeRequests.values())),
        timeoutPromise
      ]);
      logger.info('All active requests have completed successfully');
    } catch (error) {
      logger.warn('Some requests may not have completed within timeout');
    }
  } else {
    logger.info('No active requests to wait for');
  }

  // Stop accepting new connections
  if (server) {
    const serverClosePromise = new Promise((resolve) => {
      server.close(() => {
        logger.info('HTTP server closed');
        resolve();
      });
    });
    
    // Wait for server to close with timeout
    const serverCloseTimeout = new Promise(resolve => setTimeout(resolve, 5000));
    await Promise.race([serverClosePromise, serverCloseTimeout]);
  }
  
  // Clear status update interval
  if (statusUpdateInterval) {
    clearInterval(statusUpdateInterval);
    statusUpdateInterval = null;
  }
  
  // Close database pool
  try {
    await pool.end();
    logger.info('Database pool closed');
  } catch (error) {
    logger.error('Error closing database pool:', { error: error.message });
  }
  
  // Flush logger and exit
  try {
    // Final status update
    updateShutdownStatus({
      isShuttingDown: true,
      activeRequests: 0
    });
    
    // Give logger time to flush any pending writes
    await new Promise(resolve => setTimeout(resolve, 1000));
    logger.info('Graceful shutdown completed');
    process.exit(0);
  } catch (error) {
    logger.error('Error during shutdown:', { error: error.message });
    process.exit(1);
  }
}

// Signal handlers for graceful shutdown
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception:', { error: error.message, stack: error.stack });
  gracefulShutdown('uncaughtException');
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection:', { reason: reason?.message || reason, promise });
  gracefulShutdown('unhandledRejection');
});

==================================================

FILE: backend\testEndpoints.js
------------------------------
const axios = require('axios');

const BASE_URL = 'http://localhost:3001/api';

async function testEndpoints() {
  console.log('üîç Testing Available API Endpoints...\n');

  const endpoints = [
    '/health',
    '/services/master/vehicles',
    '/services/master/categories',
    '/affiliates',
    '/mdh-config',
    '/service_areas'
  ];

  for (const endpoint of endpoints) {
    try {
      console.log(`Testing ${endpoint}...`);
      const response = await axios.get(`${BASE_URL}${endpoint}`);
      console.log(`‚úÖ ${endpoint}: ${response.status} - ${response.data.success ? 'Success' : 'Data'}`);
      
      if (response.data.data && Array.isArray(response.data.data)) {
        console.log(`   Found ${response.data.data.length} items`);
        if (response.data.data.length > 0) {
          console.log(`   First item:`, JSON.stringify(response.data.data[0], null, 2));
        }
      }
      
    } catch (error) {
      if (error.response) {
        console.log(`‚ùå ${endpoint}: ${error.response.status} - ${error.response.statusText}`);
        if (error.response.data) {
          console.log(`   Error details:`, JSON.stringify(error.response.data, null, 2));
        }
      } else {
        console.log(`‚ùå ${endpoint}: ${error.message}`);
      }
    }
    console.log('');
  }
}

testEndpoints();


==================================================

FILE: backend\testServicesAPI.js
------------------------------
const axios = require('axios');

const BASE_URL = 'http://localhost:3001/api';

async function testServicesAPI() {
  try {
    console.log('üß™ Testing Services API...\n');

    // Test 1: Get all vehicles
    console.log('1Ô∏è‚É£ Testing GET /api/services/master/vehicles');
    const vehiclesResponse = await axios.get(`${BASE_URL}/services/master/vehicles`);
    console.log('‚úÖ Vehicles:', vehiclesResponse.data.data.length, 'found');
    console.log('   Sample:', vehiclesResponse.data.data[0]?.name);
    console.log('');

    // Test 2: Get all categories
    console.log('2Ô∏è‚É£ Testing GET /api/services/master/categories');
    const categoriesResponse = await axios.get(`${BASE_URL}/services/master/categories`);
    console.log('‚úÖ Categories:', categoriesResponse.data.data.length, 'found');
    console.log('   Sample:', categoriesResponse.data.data[0]?.name);
    console.log('');

    // Test 3: Check what affiliates exist
    console.log('3Ô∏è‚É£ Checking existing affiliates...');
    try {
      const affiliatesResponse = await axios.get(`${BASE_URL}/affiliates`);
      console.log('‚úÖ Affiliates found:', affiliatesResponse.data.data?.length || 0);
      if (affiliatesResponse.data.data && affiliatesResponse.data.data.length > 0) {
        const firstAffiliate = affiliatesResponse.data.data[0];
        console.log('   Using affiliate ID:', firstAffiliate.id);
        
        // Test 4: Create a test service with real affiliate ID
        console.log('4Ô∏è‚É£ Testing POST /api/services');
        const newService = {
          affiliate_id: firstAffiliate.id,
          vehicle_id: 1,
          service_category_id: 1,
          base_price_cents: 7500
        };
        
        const createResponse = await axios.post(`${BASE_URL}/services`, newService);
        console.log('‚úÖ Service created:', createResponse.data.message);
        console.log('   Service ID:', createResponse.data.data.id);
        console.log('');

        // Test 5: Get affiliate services
        console.log('5Ô∏è‚É£ Testing GET /api/services/' + firstAffiliate.id);
        const affiliateServicesResponse = await axios.get(`${BASE_URL}/services/${firstAffiliate.id}`);
        console.log('‚úÖ Affiliate services:', affiliateServicesResponse.data.count, 'found');
        console.log('');

        console.log('üéâ All tests passed! Your Services API is working perfectly!');
      } else {
        console.log('‚ö†Ô∏è  No affiliates found. Create an affiliate first before testing services.');
      }
    } catch (affiliateError) {
      console.log('‚ö†Ô∏è  Could not check affiliates:', affiliateError.message);
      console.log('   You may need to create an affiliate first.');
    }

  } catch (error) {
    console.error('‚ùå Test failed:');
    console.error('Error message:', error.message);
    console.error('Error code:', error.code);
    console.error('Error response:', error.response?.data);
    
    if (error.code === 'ECONNREFUSED') {
      console.log('\nüí° Make sure your backend server is running:');
      console.log('   cd backend && npm start');
    }
  }
}

// Run the tests
testServicesAPI();


==================================================

