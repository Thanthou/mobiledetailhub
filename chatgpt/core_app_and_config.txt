CORE APPLICATION FILES
==================================================

CORE APPLICATION FILES
==================================================

FILE: frontend/src/main.tsx
----------------------------------------
import React, { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';

import App from './App.tsx';
import { env } from './shared/env';

import './index.css';

// Register Service Worker for PWA functionality
if ('serviceWorker' in navigator && env.PROD) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then(() => {
        // Service worker registered successfully
      })
      .catch((registrationError: unknown) => {
        // Service worker registration failed
        console.warn('Service worker registration failed:', registrationError);
      });
  });
}

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error('Root element not found');
}

createRoot(rootElement).render(
  <StrictMode>
    <App />
  </StrictMode>
);


==================================================

FILE: frontend/src/App.tsx
----------------------------------------
import App from './app/App';

export default App;

==================================================

FILE: frontend/index.html
----------------------------------------
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#0b0b0b" />

    <!-- Favicon / PWA basics -->
    <link rel="icon" type="image/webp" href="https://mobiledetailhub.com/icons/favicon.webp" />
    <link rel="apple-touch-icon" href="https://mobiledetailhub.com/icons/favicon.webp" />
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.webmanifest" />
    
    <!-- PWA Icons -->
    <link rel="icon" type="image/webp" sizes="64x64" href="/icons/favicon.webp" />

    <!-- Canonical + Robots -->
    <link rel="canonical" href="https://mobiledetailhub.com/" id="canonical-link" />
    <meta name="robots" content="index,follow" />

    <!-- PRIMARY META: MDH ONLY (no LocalBusiness here) -->
    <title id="meta-title">Mobile Detail Hub — Mobile Car, Boat & RV Detailing Near You</title>
    <meta name="title" content="Mobile Detail Hub — Mobile Car, Boat & RV Detailing Near You" id="meta-title-tag" />
    <meta name="description" content="Find trusted mobile detailers for cars, boats, and RVs with Mobile Detail Hub. Compare services, read reviews, and book online with verified pros in your area." id="meta-desc" />
    <meta name="keywords" content="mobile detailing, auto detailing, ceramic coating, paint protection film, RV detailing, boat detailing" id="meta-keywords" />
    <meta name="author" content="Mobile Detail Hub" id="meta-author" />

    <!-- Open Graph (brand-level) -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://mobiledetailhub.com/" id="og-url" />
    <meta property="og:title" content="Mobile Detail Hub — Mobile Car, Boat & RV Detailing Near You" id="og-title" />
    <meta property="og:description" content="Find trusted mobile detailers for cars, boats, and RVs with Mobile Detail Hub. Compare services, read reviews, and book online with verified pros in your area." id="og-desc" />
    <meta property="og:image" content="https://mobiledetailhub.com/hero/image1-lg.webp" id="og-image" />
    <meta property="og:image:width" content="1920" />
    <meta property="og:image:height" content="1080" />
    <meta property="og:site_name" content="Mobile Detail Hub" id="og-site-name" />
    <meta property="og:locale" content="en_US" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://mobiledetailhub.com/" id="tw-url" />
    <meta property="twitter:title" content="Mobile Detail Hub — Mobile Car, Boat & RV Detailing Near You" id="tw-title" />
    <meta property="twitter:description" content="Find trusted mobile detailers for cars, boats, and RVs with Mobile Detail Hub. Compare services, read reviews, and book online with verified pros in your area." id="tw-desc" />
    <meta property="twitter:image" content="https://mobiledetailhub.com/hero/image1-lg.webp" id="tw-image" />
    <meta name="twitter:site" content="@mobiledetailhub" />

    <!-- JSON-LD placeholders (filled below) -->
    <script type="application/ld+json" id="org-jsonld">{}</script>
    <script type="application/ld+json" id="website-jsonld">{}</script>
    <script type="application/ld+json" id="directory-jsonld">{}</script>

    <!-- MDH brand context (now handled by TypeScript) -->
    <!-- MDH Global Config Initialization (must run before jsonld-loader) -->
    <script src="/js/mdh-init.js"></script>

    <!-- JSON-LD Loader -->
    <script src="/js/jsonld-loader.js" defer></script>
  </head>
  <body>
    <noscript>This site requires JavaScript to render content.</noscript>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


==================================================

FILE: frontend/vite.config.ts
----------------------------------------
import react from '@vitejs/plugin-react';
import { fileURLToPath } from 'node:url';
import { URL } from 'node:url';
import { defineConfig } from 'vite';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      'shared': fileURLToPath(new URL('./src/components/shared', import.meta.url)),
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  optimizeDeps: {
    exclude: ['lucide-react'],
  },
  server: {
    proxy: {
      '/api': 'http://localhost:3001',
      '/uploads': 'http://localhost:3001',
    },
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: undefined,
      },
    },
  },
});


==================================================

FILE: frontend/tailwind.config.js
----------------------------------------
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {},
  },
  plugins: [],
};


==================================================

FILE: frontend/postcss.config.js
----------------------------------------
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};


==================================================

FILE: frontend/package.json
----------------------------------------
{
  "name": "mobiledetailhub-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "optimize-images": "node scripts/convert-images.js",
    "prebuild": "npm run optimize-images",
    "check-pages": "node scripts/check-pages-usage.js",
    "lint:pages": "eslint . --rule 'import/no-restricted-paths: error'"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.87.4",
    "clsx": "^2.1.1",
    "lucide-react": "^0.344.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.7.1",
    "tailwind-merge": "^3.3.1",
    "zod": "^4.1.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@types/google.maps": "^3.58.1",
    "@types/node": "^24.3.1",
    "@types/react": "^18.3.24",
    "@types/react-dom": "^18.3.7",
    "@typescript-eslint/eslint-plugin": "^8.8.1",
    "@typescript-eslint/parser": "^8.8.1",
    "@vitejs/plugin-react": "^4.3.1",
    "@vitest/ui": "^3.2.4",
    "autoprefixer": "^10.4.18",
    "eslint": "^8.57.0",
    "eslint-plugin-import": "^2.32.0",
    "eslint-plugin-jsx-a11y": "^6.10.2",
    "eslint-plugin-react": "^7.34.3",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.7",
    "eslint-plugin-simple-import-sort": "^12.1.1",
    "globals": "^15.9.0",
    "jsdom": "^26.1.0",
    "postcss": "^8.4.35",
    "sharp": "^0.33.0",
    "tailwindcss": "^3.4.1",
    "typescript": "~5.5.4",
    "vite": "^5.4.2",
    "vitest": "^3.2.4"
  }
}


==================================================

FILE: backend/server.js
----------------------------------------
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const path = require('path');

// Import typed environment variables
const { env } = require('./src/shared/env');

// Import environment validator
const { validateEnvironment } = require('./utils/envValidator');
const logger = require('./utils/logger');

// Import route modules
const healthRoutes = require('./routes/health');
const serviceAreasRoutes = require('./routes/serviceAreas');
const authRoutes = require('./routes/auth');
const affiliatesRoutes = require('./routes/affiliates');
const mdhConfigRoutes = require('./routes/mdhConfig');
const customersRoutes = require('./routes/customers');
const adminRoutes = require('./routes/admin');
const uploadRoutes = require('./routes/upload');
const servicesRoutes = require('./routes/services');
const reviewsRoutes = require('./routes/reviews');
const avatarRoutes = require('./routes/avatar');
const scheduleRoutes = require('./routes/schedule');

// Get the update function from health routes
const { updateShutdownStatus } = healthRoutes;

// Import middleware
const { errorHandler, notFoundHandler } = require('./middleware/errorHandler');
const { apiLimiter, authLimiter, adminLimiter } = require('./middleware/rateLimiter');
const { requestLogger } = require('./middleware/requestLogger');

// Import database utilities
const { setupDatabase } = require('./utils/databaseInit');
const { pool } = require('./database/pool');

// Import upload validation utilities
const { validateUploadRequest } = require('./utils/uploadValidator');

// Validate CORS configuration on boot
const validateCorsConfig = () => {
  if (env.NODE_ENV === 'production') {
    const allowedOrigins = env.ALLOWED_ORIGINS?.split(',').filter(origin => origin.trim()) || [];
    if (allowedOrigins.length === 0) {
      logger.error('FATAL: ALLOWED_ORIGINS is empty in production environment');
      logger.error('Please set ALLOWED_ORIGINS environment variable with comma-separated domains');
      process.exit(1);
    }
    logger.info(`Production CORS configured with ${allowedOrigins.length} allowed origins`);
  }
};

// Validate environment variables before starting server
try {
  validateEnvironment();
} catch (error) {
  logger.error('Environment validation failed:', { error: error.message });
  process.exit(1);
}

/**
 * Single source of truth for CORS allowed origins
 * 
 * This ensures consistency across all environments and prevents
 * CORS issues when switching between different dev ports.
 * 
 * Development ports covered:
 * - 3000: React dev server (default)
 * - 5173: Vite dev server (default) 
 * - 5174: Vite dev server (alternate)
 * - 4173: Vite preview server
 * - 127.0.0.1 variants for all ports
 */
const ALLOWED_ORIGINS = {
  development: [
    'http://localhost:3000',    // React dev server (default)
    'http://localhost:3001',    // Backend server (for test pages)
    'http://localhost:5173',    // Vite dev server (default)
    'http://localhost:5174',    // Vite dev server (alternate)
    'http://localhost:4173',    // Vite preview server
    'http://127.0.0.1:3000',   // React dev server (IP variant)
    'http://127.0.0.1:3001',   // Backend server (IP variant)
    'http://127.0.0.1:5173',   // Vite dev server (IP variant)
    'http://127.0.0.1:5174',   // Vite dev server (IP variant, alternate)
    'http://127.0.0.1:4173'    // Vite preview server (IP variant)
  ],
  staging: [
    // Staging domains from environment + localhost for testing
    ...(env.ALLOWED_ORIGINS?.split(',').filter(origin => origin.trim()) || []),
    'http://localhost:3000',
    'http://localhost:5173'
  ],
  production: env.ALLOWED_ORIGINS?.split(',').filter(origin => origin.trim()) || []
};

// Validate CORS configuration
validateCorsConfig();

// Log CORS configuration for current environment
const currentEnv = env.NODE_ENV;
const currentOrigins = ALLOWED_ORIGINS[currentEnv] || ALLOWED_ORIGINS.development;
logger.info(`CORS configured for ${currentEnv} environment with ${currentOrigins.length} allowed origins`);
if (currentEnv === 'development') {
  logger.info('Development origins:', currentOrigins);
}

const app = express();
const PORT = env.PORT;

// Server instance for graceful shutdown
let server = null;

// Graceful shutdown state management
let isShuttingDown = false;
let activeRequests = new Map(); // Map to store request promises
let statusUpdateInterval = null; // Interval for status updates

// Request tracking middleware
const requestTracker = (req, res, next) => {
  // Allow health endpoints during shutdown for monitoring
  if (isShuttingDown && !req.path.startsWith('/api/health')) {
    return res.status(503).json({
      error: 'Service Unavailable',
      message: 'Server is shutting down, please try again later'
    });
  }

  const requestId = Date.now() + Math.random();
  const requestPromise = new Promise((resolve) => {
    let resolved = false;
    
    const cleanup = () => {
      if (!resolved) {
        resolved = true;
        activeRequests.delete(requestId);
        resolve();
      }
    };
    
    // Track request completion
    res.on('finish', cleanup);
    res.on('close', cleanup);
    res.on('error', cleanup);
    
    // Fallback: resolve after a reasonable timeout
    setTimeout(cleanup, 30000); // 30 seconds max
  });
  
  activeRequests.set(requestId, requestPromise);
  next();
};

// CORS configuration based on environment
const corsOptions = {
  origin: function (origin, callback) {
    // Allow requests with no origin (like mobile apps or Postman)
    if (!origin) return callback(null, true);
    
    const environment = env.NODE_ENV;
    const allowedOrigins = ALLOWED_ORIGINS[environment] || ALLOWED_ORIGINS.development;
    
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      logger.warn(`CORS blocked request from unauthorized origin: ${origin}`, {
        environment,
        allowedOrigins: allowedOrigins.length
      });
      // Return proper CORS headers even when denying
      callback(new Error('Not allowed by CORS'));
    }
  },
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true, // Enable credentials for HttpOnly cookies
  optionsSuccessStatus: 200, // Some legacy browsers choke on 204
  preflightContinue: false, // Ensure preflight requests are handled properly
  maxAge: 86400 // Cache preflight response for 24 hours
};

// Middleware
app.use(cors(corsOptions));
app.use(requestLogger); // Add request logging with correlation IDs and PII scrubbing
// Helmet: relax in dev, tighten in prod
const dev = process.env.NODE_ENV !== 'production';
app.use(helmet({
  contentSecurityPolicy: {
    useDefaults: true,
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: dev ? ["'self'", "'unsafe-inline'"] : ["'self'"],
      styleSrc: dev ? ["'self'", "'unsafe-inline'"] : ["'self'"],
      imgSrc: [
        "'self'",
        "data:",
        "https://*.mobiledetailhub.com"
      ],
      connectSrc: [
        "'self'",
        "https://*.mobiledetailhub.com"
      ],
      fontSrc: ["'self'", "data:"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
      baseUri: ["'self'"],
      formAction: ["'self'"],
      frameAncestors: ["'none'"],
      upgradeInsecureRequests: []
    },
    reportOnly: false
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  noSniff: true,
  frameguard: {
    action: 'deny'
  },
  hidePoweredBy: true,
  ienoopen: true,
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
}));
app.use(express.json({ limit: '1mb' })); // Limit request body size
app.use(express.urlencoded({ extended: true, limit: '1mb' })); // Limit URL-encoded body size

// Serve static files with caching
// Note: mdh-config.js is cached for 24 hours to ensure instant header/footer loading
app.use('/js/mdh-config.js', (req, res, next) => {
  // Set long-term cache headers for the static config file
  res.set({
    'Cache-Control': 'public, max-age=86400, s-maxage=86400', // 24 hours
    'ETag': '"mdh-config-static"',
    'Vary': 'Accept-Encoding'
  });
  next();
});
app.use('/js', express.static('frontend/public/js'));

// Serve uploaded avatar files
app.use('/uploads', express.static('uploads', {
  maxAge: '1d', // Cache avatars for 1 day
  etag: true,
  lastModified: true
}));

// Serve test page for avatar upload testing
app.get('/test-avatar', (req, res) => {
  res.sendFile(path.join(__dirname, 'test-avatar.html'));
});

// Enhanced request validation middleware
const requestValidationMiddleware = (req, res, next) => {
  // Check if server is shutting down (allow health endpoints for monitoring)
  if (isShuttingDown && !req.path.startsWith('/api/health')) {
    return res.status(503).json({
      error: 'Service Unavailable',
      message: 'Server is shutting down, please try again later'
    });
  }
  
  // Content-Type validation for POST/PUT requests
  if (['POST', 'PUT', 'PATCH'].includes(req.method)) {
    const contentType = req.headers['content-type'];
    
    if (!contentType) {
      return res.status(400).json({
        error: 'Content-Type header is required',
        message: 'Please specify the content type for your request'
      });
    }

    // MIME type allowlist for JSON and form data
    const allowedMimeTypes = [
      'application/json',
      'application/x-www-form-urlencoded',
      'multipart/form-data' // For future file uploads
    ];

    const isValidMimeType = allowedMimeTypes.some(allowedType => 
      contentType.startsWith(allowedType)
    );

    if (!isValidMimeType) {
      logger.warn(`Invalid Content-Type rejected: ${contentType} from ${req.ip}`);
      return res.status(415).json({
        error: 'Unsupported Media Type',
        message: 'Only JSON, form data, and multipart form data are supported',
        allowedTypes: allowedMimeTypes
      });
    }

    // Enhanced validation for multipart/form-data (future uploads)
    if (contentType.startsWith('multipart/form-data')) {
      const uploadValidation = validateUploadRequest(req);
      if (!uploadValidation.success) {
        logger.warn(`Multipart validation failed: ${uploadValidation.errors.join(', ')} from ${req.ip}`);
        return res.status(400).json({
          error: 'Invalid multipart data',
          message: uploadValidation.errors.join(', '),
          warnings: uploadValidation.warnings
        });
      }
    }
  }

  // Request size validation (additional check beyond express limits)
  const contentLength = parseInt(req.headers['content-length'] || '0');
  const maxSize = 1024 * 1024; // 1MB in bytes
  
  if (contentLength > maxSize) {
    logger.warn(`Request too large rejected: ${contentLength} bytes from ${req.ip}`);
    return res.status(413).json({
      error: 'Payload Too Large',
      message: 'Request body exceeds maximum allowed size of 1MB',
      maxSize: '1MB',
      receivedSize: `${Math.round(contentLength / 1024)}KB`
    });
  }

  next();
};

app.use(requestValidationMiddleware);
app.use(requestTracker); // Apply request tracking middleware

// Rate limiting strategy:
// - Apply specific rate limiters to sensitive endpoints (auth, admin, uploads)
// - Apply general API limiter to other routes
// - Read-only endpoints (health, service_areas, mdh-config) are NOT rate-limited
//   to prevent slow header/footer performance

// Apply specific rate limiting to sensitive routes
app.use('/api/auth', authLimiter, authRoutes); // Auth-specific rate limiting
app.use('/api/admin', adminLimiter, adminRoutes); // Admin-specific rate limiting

// Apply general API rate limiting to other routes
app.use('/api/affiliates', apiLimiter, affiliatesRoutes); // Mixed read/write
app.use('/api/customers', apiLimiter, customersRoutes); // Mixed read/write
app.use('/api/services', servicesRoutes); // Mixed read/write - temporarily removed rate limiter
app.use('/api/reviews', apiLimiter, reviewsRoutes); // Mixed read/write
app.use('/api/upload', apiLimiter, uploadRoutes); // Upload routes
app.use('/api/avatar', apiLimiter, avatarRoutes); // Avatar routes
app.use('/api/schedule', apiLimiter, scheduleRoutes); // Schedule routes

// Read-only endpoints (no rate limiting to prevent slow header/footer performance)
app.use('/api/health', healthRoutes); // Health checks
app.use('/api/service_areas', serviceAreasRoutes); // Service areas data
app.use('/api/mdh-config', mdhConfigRoutes); // Configuration data

// Error handling middleware (must be last)
app.use(notFoundHandler);
app.use(errorHandler);

// Quick database connectivity check before starting server
async function startServer() {
  logger.info('Testing database connection...');
  try {
    // Quick ping with 1 second timeout
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Database ping timeout')), 1000)
    );
    
    await Promise.race([
      pool.query('SELECT 1'),
      timeoutPromise
    ]);
    
    logger.info('✅ Database ping successful');
  } catch (error) {
    logger.error('❌ Database ping failed:', { error: error.message });
    process.exit(1);
  }

  // Setup database after successful ping
  logger.info('Setting up database...');
  try {
    await setupDatabase();
    logger.info('✅ Database setup completed successfully');
  } catch (error) {
    logger.error('❌ Database setup failed:', { error: error.message });
    process.exit(1);
  }

  // Start server after successful database setup
  server = app.listen(PORT, () => {
    // Check if we're already shutting down
    if (isShuttingDown) {
      logger.warn('Server startup cancelled - shutdown in progress');
      return;
    }
    
    logger.startup(`Server running on port ${PORT}`);
    logger.startup('Server is fully ready and operational!');
    
    // Start periodic shutdown status updates
    statusUpdateInterval = setInterval(() => {
      updateShutdownStatus({
        isShuttingDown,
        activeRequests: activeRequests.size
      });
    }, 1000); // Update every second
  });
}

// Start the server
startServer();

// Graceful shutdown function
async function gracefulShutdown(signal) {
  logger.info(`Received ${signal}, starting graceful shutdown...`);
  
  isShuttingDown = true; // Set flag to prevent new requests
  logger.info(`${activeRequests.size} active requests will be allowed to complete.`);

  // Wait for active requests to complete with timeout
  if (activeRequests.size > 0) {
    const timeout = 10000; // 10 seconds timeout
    const timeoutPromise = new Promise(resolve => setTimeout(resolve, timeout));
    
    try {
      await Promise.race([
        Promise.all(Array.from(activeRequests.values())),
        timeoutPromise
      ]);
      logger.info('All active requests have completed successfully');
    } catch (error) {
      logger.warn('Some requests may not have completed within timeout');
    }
  } else {
    logger.info('No active requests to wait for');
  }

  // Stop accepting new connections
  if (server) {
    const serverClosePromise = new Promise((resolve) => {
      server.close(() => {
        logger.info('HTTP server closed');
        resolve();
      });
    });
    
    // Wait for server to close with timeout
    const serverCloseTimeout = new Promise(resolve => setTimeout(resolve, 5000));
    await Promise.race([serverClosePromise, serverCloseTimeout]);
  }
  
  // Clear status update interval
  if (statusUpdateInterval) {
    clearInterval(statusUpdateInterval);
    statusUpdateInterval = null;
  }
  
  // Close database pool
  try {
    await pool.end();
    logger.info('Database pool closed');
  } catch (error) {
    logger.error('Error closing database pool:', { error: error.message });
  }
  
  // Flush logger and exit
  try {
    // Final status update
    updateShutdownStatus({
      isShuttingDown: true,
      activeRequests: 0
    });
    
    // Give logger time to flush any pending writes
    await new Promise(resolve => setTimeout(resolve, 1000));
    logger.info('Graceful shutdown completed');
    process.exit(0);
  } catch (error) {
    logger.error('Error during shutdown:', { error: error.message });
    process.exit(1);
  }
}

// Signal handlers for graceful shutdown
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception:', { error: error.message, stack: error.stack });
  gracefulShutdown('uncaughtException');
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection:', { reason: reason?.message || reason, promise });
  gracefulShutdown('unhandledRejection');
});

==================================================

FILE: backend/package.json
----------------------------------------
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "start:prod": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^1.11.0",
    "bcryptjs": "^2.4.3",
    "cookie": "^0.6.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "express-rate-limit": "^8.0.1",
    "file-type": "^21.0.0",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.2",
    "pg": "^8.16.3",
    "uuid": "^11.1.0",
    "winston": "^3.15.0",
    "zod": "^4.1.5"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}


==================================================

FILE: backend/database/pool.js
----------------------------------------
const { Pool } = require('pg');
const logger = require('../utils/logger');
const { env } = require('../src/shared/env');

// Create a single global pool instance with improved configuration
const pool = new Pool({
  connectionString: env.DATABASE_URL,
  ssl: env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
  
  // Connection pool settings
  max: 25,                    // Increased from 20 to handle more concurrent requests
  min: 2,                     // Keep at least 2 connections ready
  idleTimeoutMillis: 60000,   // Increased idle timeout to 1 minute
  connectionTimeoutMillis: 15000,  // Increased connection timeout to 15 seconds
  
  // Better connection management
  allowExitOnIdle: false,     // Don't exit when idle
  maxUses: 7500,             // Recycle connections after 7500 queries (prevents memory leaks)
  
  // Statement timeout (prevents long-running queries from blocking)
  statement_timeout: 30000,   // 30 seconds
  query_timeout: 30000        // 30 seconds
});

// Enhanced error handling
pool.on('error', (err) => {
  logger.error('Unexpected error on idle client:', { 
    error: err.message, 
    code: err.code,
    stack: err.stack 
  });
});

// Connection acquired event
pool.on('acquire', (client) => {
  logger.debug('Client acquired from pool');
});

// Connection released event
pool.on('release', (client) => {
  logger.debug('Client released back to pool');
});

// Connection connect event
pool.on('connect', (client) => {
  logger.debug('New client connected to database');
});

// Health check function
const checkPoolHealth = async () => {
  try {
    const client = await pool.connect();
    await client.query('SELECT 1');
    client.release();
    logger.debug('Database pool health check passed');
    return true;
  } catch (error) {
    logger.error('Database pool health check failed:', { error: error.message });
    return false;
  }
};

// Periodic health check every 5 minutes
setInterval(checkPoolHealth, 5 * 60 * 1000);

// Graceful shutdown
process.on('SIGINT', async () => {
  logger.info('Shutting down database pool gracefully...');
  await pool.end();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('Shutting down database pool gracefully...');
  await pool.end();
  process.exit(0);
});

// Export the pool and health check function
module.exports = { pool, checkPoolHealth };


==================================================



ENVIRONMENT CONFIGURATION
==================================================

# Environment Variables Example
# Copy to .env and fill values

# Database
DB_HOST=localhost
DB_PORT=5432
DB_NAME=mdh
DB_USER=postgres
DB_PASSWORD=your_password_here
DATABASE_URL=postgresql://username:password@localhost:5432/database_name

# JWT
JWT_SECRET=your_jwt_secret_here
JWT_REFRESH_SECRET=your_refresh_secret_here
JWT_EXPIRES_IN=1h
JWT_REFRESH_EXPIRES_IN=7d

# Server
PORT=3001
NODE_ENV=development

# CORS
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:5173

# Admin
ADMIN_EMAILS=admin@example.com,admin2@example.com

# Uploads
UPLOAD_MAX_SIZE=5242880
UPLOAD_ALLOWED_TYPES=image/jpeg,image/png,image/gif

# Rate limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Logging
LOG_LEVEL=info
LOG_FILE=logs/app.log


API CONTRACT
==================================================

# API Contract

## Authentication
### POST /api/auth/register
Body: { name, email, password, phone } → { user, token }
### POST /api/auth/login
Body: { email, password } → { user, token, refreshToken }
### GET /api/auth/me
Header: Authorization: Bearer <token> → { user }

## Affiliates
### GET /api/affiliates/slugs → { slugs: string[] }
### GET /api/affiliates/lookup?zip=12345&state=CA → { affiliates: Affiliate[] }
### GET /api/affiliates/:slug → { affiliate: Affiliate }

## Services
### GET /api/services → { services: Service[] }
### GET /api/services/:id → { service: Service }

## Reviews
### GET /api/reviews → { reviews: Review[] }
### POST /api/reviews (auth) Body: { rating, comment, affiliateId } → { review: Review }

## Health
### GET /api/health → { status: "ok", database: "connected" }

## Admin
### GET /admin (admin) → { dashboard: AdminDashboard }
### POST /admin/query (admin) Body: { query: string } → { results: any[] }


BUILD & ASSET CONFIGURATION
==================================================

BUILD & ASSET CONFIGURATION
==================================================

FILE: frontend/scripts/convert-images.js
----------------------------------------
#!/usr/bin/env node

/**
 * Image Optimization Script for Mobile Detail Hub
 * 
 * This script converts PNG images to WebP format with multiple responsive sizes
 * and generates the necessary PWA icons.
 * 
 * Prerequisites:
 * npm install sharp
 * 
 * Usage:
 * node scripts/convert-images.js
 */

import fs from 'fs/promises';
import path from 'path';
import sharp from 'sharp';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const INPUT_DIR = path.join(__dirname, '../dist');
const OUTPUT_DIR = path.join(__dirname, '../public');

// Responsive sizes for hero images
const HERO_SIZES = [
  { width: 640, suffix: '-sm' },   // Mobile
  { width: 1024, suffix: '-md' },  // Tablet  
  { width: 1920, suffix: '-lg' },  // Desktop
  { width: 2560, suffix: '-xl' }   // Large desktop
];

// PWA icon sizes
const ICON_SIZES = [
  { size: 192, name: 'icon-192.webp' },
  { size: 512, name: 'icon-512.webp' },
  { size: 64, name: 'favicon.webp' }
];

async function ensureDirectoryExists(dirPath) {
  try {
    await fs.access(dirPath);
  } catch {
    await fs.mkdir(dirPath, { recursive: true });
    // Created directory
  }
}

async function convertHeroImages() {
  // Converting hero images
  
  const heroInputDir = path.join(INPUT_DIR, 'hero');
  const heroOutputDir = path.join(OUTPUT_DIR, 'hero');
  
      // Looking in hero directory
  
  await ensureDirectoryExists(heroOutputDir);
  
  try {
    const files = await fs.readdir(heroInputDir);
    const pngFiles = files.filter(file => file.endsWith('.png'));
    
    // Found PNG files
    
    if (pngFiles.length === 0) {
              // No PNG files found in hero directory
      return;
    }
    
    for (const file of pngFiles) {
      const inputPath = path.join(heroInputDir, file);
      const baseName = path.parse(file).name;
      
      // Converting file
      
      // Generate responsive sizes
      for (const size of HERO_SIZES) {
        const outputPath = path.join(heroOutputDir, `${baseName}${size.suffix}.webp`);
        
        await sharp(inputPath)
          .resize(size.width, null, { 
            withoutEnlargement: true,
            fit: 'cover'
          })
          .webp({ quality: 85, effort: 6 })
          .toFile(outputPath);
          
                  // Generated webp file
      }
      
      // Generate AVIF for modern browsers (optional)
      const avifPath = path.join(heroOutputDir, `${baseName}.avif`);
      await sharp(inputPath)
        .resize(1920, null, { 
          withoutEnlargement: true,
          fit: 'cover'
        })
        .avif({ quality: 75, effort: 6 })
        .toFile(avifPath);
        
              // Generated avif file
    }
  } catch (error) {
    if (error.code === 'ENOENT') {
      // Hero directory not found - skipping hero image conversion
    } else {
      console.error(`❌ Error processing hero images: ${error.message}`);
    }
  }
}

async function generatePWAIcons() {
  // Generating PWA icons
  
  const logoInputPath = path.join(INPUT_DIR, 'assets', 'logo.webp');
  const assetsOutputDir = path.join(OUTPUT_DIR, 'assets');
  
  await ensureDirectoryExists(assetsOutputDir);
  
  try {
    // Check if logo exists
    await fs.access(logoInputPath);
    
    for (const iconConfig of ICON_SIZES) {
      const outputPath = path.join(assetsOutputDir, iconConfig.name);
      
      await sharp(logoInputPath)
        .resize(iconConfig.size, iconConfig.size, {
          fit: 'contain',
          background: { r: 11, g: 11, b: 11, alpha: 1 } // Match theme color
        })
        .webp({ quality: 90 })
        .toFile(outputPath);
        
              // Generated icon
    }
  } catch (error) {
    if (error.code === 'ENOENT') {
              // Logo file not found - skipping PWA icon generation
              // Expected: dist/assets/logo.webp
    } else {
      console.error(`❌ Error generating PWA icons: ${error.message}`);
    }
  }
}

async function optimizeAssetImages() {
  // Optimizing asset images
  
  const assetsInputDir = path.join(INPUT_DIR, 'assets');
  const assetsOutputDir = path.join(OUTPUT_DIR, 'assets');
  
      // Looking in assets directory
  
  await ensureDirectoryExists(assetsOutputDir);
  
  try {
    const files = await fs.readdir(assetsInputDir);
    const imageFiles = files.filter(file => 
      file.endsWith('.png') && !file.includes('logo')
    );
    
    // Found PNG files
    
    if (imageFiles.length === 0) {
              // No PNG files found in assets directory
      return;
    }
    
    for (const file of imageFiles) {
      const inputPath = path.join(assetsInputDir, file);
      const baseName = path.parse(file).name;
      const outputPath = path.join(assetsOutputDir, `${baseName}.webp`);
      
      await sharp(inputPath)
        .webp({ quality: 85, effort: 6 })
        .toFile(outputPath);
        
              // Converted file to webp
    }
  } catch (error) {
    if (error.code === 'ENOENT') {
              // Assets directory not found - skipping asset optimization
    } else {
      console.error(`❌ Error optimizing asset images: ${error.message}`);
    }
  }
}

async function main() {
  // Starting image optimization
      // Looking for images in input directory
      // Output directory
  
  try {
    await convertHeroImages();
    await generatePWAIcons();
    await optimizeAssetImages();
    
    // Image optimization complete
    // Next steps:
    // 1. Update image references in components
    // 2. Add manifest link to index.html
    // 3. Test PWA installability
    
  } catch (error) {
    console.error(`❌ Fatal error: ${error.message}`);
    process.exit(1);
  }
}

// Run only if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export { convertHeroImages, generatePWAIcons, optimizeAssetImages };


==================================================

FILE: frontend/public/manifest.webmanifest
----------------------------------------
{
  "name": "Mobile Detail Hub",
  "short_name": "MDH",
  "description": "Find trusted mobile detailers for cars, boats, and RVs with Mobile Detail Hub",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#0b0b0b",
  "theme_color": "#0b0b0b",
  "orientation": "portrait-primary",
  "scope": "/",
  "lang": "en",
  "categories": ["business", "automotive"],
  "icons": [
    {
      "src": "/assets/favicon.webp",
      "sizes": "64x64",
      "type": "image/webp",
      "purpose": "any"
    },
    {
      "src": "/assets/favicon.webp",
      "sizes": "64x64", 
      "type": "image/webp",
      "purpose": "maskable"
    }
  ]
}


==================================================

FILE: frontend/public/sw.js
----------------------------------------
/**
 * Service Worker for Mobile Detail Hub PWA
 * Provides basic caching for assets and offline functionality
 */

const CACHE_NAME = 'mdh-v1.0.0';
const STATIC_CACHE_URLS = [
  '/',
  '/manifest.webmanifest',
  '/assets/favicon.webp',
  '/assets/icon-192.webp', 
  '/assets/icon-512.webp',
  '/hero/image1-lg.webp',
  '/hero/image2-lg.webp'
];

// Install event - cache static assets
self.addEventListener('install', (event) => {
      // Service Worker installing
  
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        // Caching static assets
        return cache.addAll(STATIC_CACHE_URLS);
      })
      .then(() => {
                  // Static assets cached successfully
        return self.skipWaiting();
      })
      .catch((_error) => {
        // Failed to cache static assets
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
      // Service Worker activating
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== CACHE_NAME) {
              // Deleting old cache
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => {
        // Service Worker activated
        return self.clients.claim();
      })
  );
});

// Fetch event - serve from cache, fallback to network
self.addEventListener('fetch', (event) => {
  // Only handle GET requests
  if (event.request.method !== 'GET') {
    return;
  }

  // Skip cross-origin requests
  if (!event.request.url.startsWith(self.location.origin)) {
    return;
  }

  event.respondWith(
    caches.match(event.request)
      .then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse;
        }

        // Network first for HTML pages, cache first for assets
        if (event.request.destination === 'document') {
          return networkFirst(event.request);
        } else {
          return cacheFirst(event.request);
        }
      })
      .catch(() => {
        // Offline fallback for HTML pages
        if (event.request.destination === 'document') {
          return caches.match('/');
        }
      })
  );
});

/**
 * Network first strategy - for HTML pages
 */
async function networkFirst(request) {
  try {
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      const cache = await caches.open(CACHE_NAME);
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    const cachedResponse = await caches.match(request);
    return cachedResponse || new Response('Offline', { status: 503 });
  }
}

/**
 * Cache first strategy - for static assets
 */
async function cacheFirst(request) {
  const cachedResponse = await caches.match(request);
  
  if (cachedResponse) {
    return cachedResponse;
  }
  
  try {
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      const cache = await caches.open(CACHE_NAME);
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    return new Response('Asset unavailable', { status: 503 });
  }
}


==================================================

FILE: frontend/vite.config.ts
----------------------------------------
import react from '@vitejs/plugin-react';
import { fileURLToPath } from 'node:url';
import { URL } from 'node:url';
import { defineConfig } from 'vite';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      'shared': fileURLToPath(new URL('./src/components/shared', import.meta.url)),
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  optimizeDeps: {
    exclude: ['lucide-react'],
  },
  server: {
    proxy: {
      '/api': 'http://localhost:3001',
      '/uploads': 'http://localhost:3001',
    },
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: undefined,
      },
    },
  },
});


==================================================

FILE: frontend/tailwind.config.js
----------------------------------------
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {},
  },
  plugins: [],
};


==================================================

FILE: frontend/postcss.config.js
----------------------------------------
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};


==================================================

FILE: backend/package.json
----------------------------------------
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "start:prod": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^1.11.0",
    "bcryptjs": "^2.4.3",
    "cookie": "^0.6.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "express-rate-limit": "^8.0.1",
    "file-type": "^21.0.0",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.2",
    "pg": "^8.16.3",
    "uuid": "^11.1.0",
    "winston": "^3.15.0",
    "zod": "^4.1.5"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}


==================================================

FILE: package.json
----------------------------------------
{
  "name": "mobiledetailhub",
  "version": "1.0.0",
  "description": "Mobile Detail Hub - Multi-business detailing services platform",
  "private": true,
  "scripts": {
    "build": "cd frontend && npm run build",
    "dev": "concurrently \"npm run dev --workspace=frontend\" \"npm run dev --workspace=backend\"",
    "install:all": "npm install && npm install --workspace=frontend && npm install --workspace=backend",
    "overview": "node scripts/generate-codebase-overview.js",
    "error-monitor": "node scripts/unified-error-monitor.js",
    "error-monitor:backend": "node backend/scripts/error-monitor.js",
    "error-monitor:frontend": "echo 'Frontend error monitoring is automatic when the app is running. Open browser console to see errors.'"
  },
  "devDependencies": {
    "concurrently": "^8.2.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "dependencies": {
    "dotenv": "^17.2.1",
    "pg": "^8.16.3"
  }
}


==================================================

