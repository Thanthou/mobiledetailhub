

/*──────────────── package.json ────────────────*/

{
  "name": "thatsmartsite",
  "version": "1.0.0",
  "description": "That Smart Site - Smart websites for smart businesses",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "cd frontend && npm run build",
    "install:all": "npm install && cd frontend && npm install && cd ../backend && npm install",

    "dev": "concurrently \"cd frontend && npm run dev\" \"cd backend && npm run dev\" \"node scripts/error-monitor/index.js --target=all\"",
    "dev:frontend": "node scripts/devtools/cli/find-free-port.js && node scripts/devtools/cli/start-frontend.js",
    "dev:backend": "node scripts/devtools/cli/find-free-backend-port.js && cd backend && npm run dev",
    "dev:main": "node scripts/devtools/cli/start-main-app.js",
    "dev:admin": "node scripts/devtools/cli/start-admin-app.js",
    "dev:tenant": "node scripts/devtools/cli/start-tenant-app.js",
    "dev:hub": "node scripts/devtools/dev-hub.js",
    "dev:monitor": "node scripts/devtools/cli/dev-monitor.js",
    "predev:all": "node scripts/automation/cleanup/kill-node-processes.js && node scripts/automation/port-registry.js clear",
    "dev:all": "npm run predev:all && concurrently -n HUB,MAIN,ADMIN,TENANT,BACKEND -c gray,cyan,magenta,yellow,green \"npm run dev:hub\" \"npm run dev:main\" \"npm run dev:admin\" \"npm run dev:tenant\" \"npm run dev:backend\"",
    "dev:apps": "npm run predev:all && concurrently -n HUB,MAIN,ADMIN,TENANT -c gray,cyan,magenta,yellow \"npm run dev:hub\" \"npm run dev:main\" \"npm run dev:admin\" \"npm run dev:tenant\"",
    "dev:clean": "scripts/automation/cleanup/cleanup-and-dev.bat",

    "audit:all": "node scripts/project/run-all.js",
    "audit:env": "node scripts/audits/audit-env.js",
    "audit:schema": "node scripts/audits/audit-schema.js",
    "audit:routes": "node scripts/audits/audit-routes.js",
    "audit:routing": "node scripts/audits/audit-routing.js",
    "audit:performance": "node scripts/audits/audit-performance.js",
    "audit:seo": "node scripts/audits/audit-seo.js",
    "audit:overview": "node scripts/audits/audit-overview.js",
    "audit:db": "node scripts/audits/audit-db.js",

    "fix:routes": "node scripts/devtools/fixers/fix-express-routes.js",
    "fix:remaining": "node scripts/devtools/fixers/fix-remaining-routes.js",
    "fix:final": "node scripts/devtools/fixers/fix-final-routes.js",

    "test:all": "npm run test:backend && npm run test:frontend",
    "test:backend": "node scripts/testing/backend/test-subdomain.js",
    "test:frontend": "node scripts/testing/frontend/validate-build.js",
    "test:subdomain": "node scripts/testing/backend/test-subdomain.js",
    "test:domains": "node scripts/test-custom-domains.js",
    "test:integration": "node scripts/testing/integration/verify-onboarding.js",
    "validate": "node scripts/testing/frontend/validate-build.js",
    "validate:env": "node scripts/devtools/validate-env.js",

    "lint": "eslint backend/ scripts/",
    "lint:fix": "eslint backend/ scripts/ --fix",
    "lint:all": "npm run lint && cd frontend && npm run lint",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,json,md,css,scss}\"",
    "format:check": "prettier --check \"**/*.{js,jsx,ts,tsx,json,md,css,scss}\"",

    "deploy:check": "node scripts/automation/build/deploy-render.js",
    "deploy:build": "cd frontend && npm run build && cd ../backend && npm run migrate",
    "deploy:production": "node scripts/automation/deploy/deploy-production.js",

    "seo:provision": "node scripts/setup/seo-provision.js --all",

    "setup:hosts": "node scripts/setup-hosts.js",
    "prepare": "husky install",

    "overview": "node scripts/project/project-overview.js",
    "score": "node scripts/devtools/metrics/scorecard.js",
    "chatgpt": "node scripts/devtools/chatgpt-snapshot.js",
    
    "devtools:metrics": "node scripts/devtools/metrics/scorecard.js",
    "devtools:fix": "node scripts/devtools/fixers/fix-express-routes.js",
    "cli": "node scripts/devtools/cli/index.js",
    "folder-dump": "node scripts/project/folder-dump.js"
  },

  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "concurrently": "^8.2.2",
    "eslint": "^9.17.0",
    "globals": "^15.14.0",
    "husky": "^9.1.7",
    "lint-staged": "^15.2.11",
    "madge": "^8.0.0",
    "node-fetch": "^3.3.2",
    "nodemon": "^3.1.0",
    "prettier": "^3.4.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "dependencies": {
    "chalk": "^5.6.2",
    "cli-table3": "^0.6.5",
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "http-proxy-middleware": "^3.0.5",
    "pg": "^8.16.3"
  }
}


/*──────────────── frontend\src\shared\env.ts ────────────────*/

/**
 * Centralized Environment Configuration
 * 
 * This module validates and exports all environment variables used in the application.
 * Always import from this module instead of using import.meta.env directly.
 * 
 * @example
 * ```ts
 * import { env, config } from '@/shared/env';
 * 
 * // Use env for raw values
 * if (env.DEV) { ... }
 * 
 * // Use config for computed/derived values
 * const apiUrl = config.apiBaseUrl;
 * ```
 */

import { z } from "zod";

const EnvSchema = z.object({
  // Vite built-in variables
  MODE: z.enum(["development", "production", "test"]),
  DEV: z.boolean(),
  PROD: z.boolean(),
  
  // API Configuration
  VITE_API_URL: z.string().optional(),
  VITE_API_URL_LOCAL: z.string().optional(),
  VITE_API_URL_LIVE: z.string().optional(),
  VITE_API_BASE_URL: z.string().optional(),
  
  // Third-party API Keys
  VITE_GOOGLE_MAPS_API_KEY: z.string().optional(),
  VITE_STRIPE_PUBLISHABLE_KEY: z.string().optional(),
  
  // Feature Flags
  VITE_ENABLE_SW: z.string().optional(), // Service worker flag ('1' or '0')
});

/**
 * Validated environment variables
 * Raw access to env vars - prefer using `config` for derived values
 */
export const env = EnvSchema.parse(import.meta.env);

/**
 * Computed configuration derived from environment variables
 * This provides cleaner access patterns and type-safe defaults
 */
export const config = {
  // Environment
  isDevelopment: env.DEV,
  isProduction: env.PROD,
  mode: env.MODE,
  
  // API Configuration
  apiBaseUrl: env.VITE_API_BASE_URL || '/api', // Use relative path for Vite proxy
  apiUrl: env.PROD ? (env.VITE_API_URL_LIVE || '') : '', // Force empty in dev to use Vite proxy
  apiUrls: {
    local: env.VITE_API_URL_LOCAL || env.VITE_BACKEND_URL || 'http://localhost:3001',
    live: env.VITE_API_URL_LIVE || '',
  },
  
  // Third-party Services
  googleMapsApiKey: env.VITE_GOOGLE_MAPS_API_KEY,
  stripePublishableKey: env.VITE_STRIPE_PUBLISHABLE_KEY || 'pk_test_placeholder',
  
  // Feature Flags
  serviceWorkerEnabled: env.VITE_ENABLE_SW === '1' && env.PROD,
} as const;

/*──────────────── frontend\src\shared\index.ts ────────────────*/

// Environment utilities
export * from './env';

// Type guards
export * from './types/guards';

// API services
export * from './api';

// UI Components
export * from './ui';

// Shared hooks
export * from './hooks';

// Shared utilities
export * from './utils';

// Shared data
export * from './data/states';

// Google Maps utilities and types
export * from './types/googlePlaces.types';
export * from './utils/googleMaps.helpers';

/*──────────────── frontend\src\shared\useRouterDebug.ts ────────────────*/

import { useInRouterContext } from 'react-router-dom';
import { useEffect } from 'react';

export function useRouterDebug(name: string) {
  const inside = useInRouterContext();
  useEffect(() => console.log(`[RouterDebug] ${name} in router?`, inside), [inside]);
}


/*──────────────── backend\routes\admin.js ────────────────*/

import express from 'express';
import { getPool } from '../database/pool.js';
import { authenticateToken, requireAdmin } from '../middleware/auth.js';
import { validateBody, validateParams, sanitize } from '../middleware/validation.js';
import { adminSchemas, sanitizationSchemas } from '../utils/validationSchemas.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { createModuleLogger } from '../config/logger.js';
import { criticalAdminLimiter } from '../middleware/rateLimiter.js';

const router = express.Router();
const logger = createModuleLogger('adminRoutes');

/**
 * @fileoverview Admin API routes for tenant management, user administration, and platform operations
 * @version 1.0.0
 * @author That Smart Site
 */

/**
 * DELETE /api/admin/tenants/:id
 * Delete tenant and all associated data
 * @param {string} id - Tenant ID
 * @returns {Object} Success response with deleted tenant info
 */
router.delete('/tenants/:id', criticalAdminLimiter, authenticateToken, requireAdmin, asyncHandler(async (req, res) => {
  logger.info('[ADMIN] DELETE /tenants/:id called with id:', { id: req.params.id });
  

  const pool = await getPool();
  const { id } = req.params;
  
  // Start a transaction to ensure data consistency
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    
    // First, try to find the tenant by ID
    const findTenantQuery = 'SELECT business_email as email, business_name, slug FROM tenants.business WHERE id = $1';
    const tenantResult = await client.query(findTenantQuery, [id]);
    
    // If not found in tenants table, try to find by user ID
    if (tenantResult.rowCount === 0) {
      logger.debug(`Tenant ID ${id} not found in tenants table, checking users table...`);
      const findUserQuery = 'SELECT email, name FROM auth.users WHERE id = $1';
      const userResult = await client.query(findUserQuery, [id]);
      
      if (userResult.rowCount === 0) {
        await client.query('ROLLBACK');
        const error = new Error('Tenant not found in either tenants or users table');
        error.statusCode = 404;
        throw error;
      }
      
      // User exists but no tenant record - just delete the user
      const user = userResult.rows[0];
      const deleteUserQuery = 'DELETE FROM auth.users WHERE id = $1';
      await client.query(deleteUserQuery, [id]);
      
      // Audit log the user deletion
      logger.audit('DELETE_USER', 'users', { id: parseInt(id), name: user.name, email: user.email }, null, {
        userId: req.user.userId,
        email: req.user.email
      });
      
      logger.info(`Deleted user record ${id} (${user.name})`);
      
      await client.query('COMMIT');
      
      res.json({
        success: true,
        message: `User "${user.name}" has been deleted successfully`,
        deletedUser: {
          id: parseInt(id),
          name: user.name,
          email: user.email
        }
      });
      return;
    }
    
    // Tenant found - proceed with full deletion
    const tenant = tenantResult.rows[0];
    
    // Log the tenant data before deletion for audit
    const tenantBeforeState = {
      id: parseInt(id),
      business_name: tenant.business_name,
      slug: tenant.slug,
      email: tenant.email
    };
    
    logger.info(`Starting comprehensive deletion for tenant: ${tenant.business_name} (ID: ${id})`);
    
    // Delete in order to respect foreign key constraints
    // 1. Delete reviews for this tenant
    await client.query('DELETE FROM reputation.reviews WHERE tenant_slug = $1', [tenant.slug]);
    logger.info(`Deleted reviews for tenant: ${tenant.slug}`);
    
    // 2. Delete tenant images
    await client.query('DELETE FROM tenants.tenant_images WHERE tenant_slug = $1', [tenant.slug]);
    logger.info(`Deleted tenant images for: ${tenant.slug}`);
    
    // 3. Delete website content
    await client.query('DELETE FROM website.content WHERE business_id = $1', [id]);
    logger.info(`Deleted website content for business ID: ${id}`);
    
    // 4. Delete health monitoring records
    await client.query('DELETE FROM system.health_monitoring WHERE business_id = $1 OR tenant_slug = $2', [id, tenant.slug]);
    logger.info(`Deleted health monitoring records for: ${tenant.slug}`);
    
    // 5. Delete subscriptions
    await client.query('DELETE FROM tenants.subscriptions WHERE business_id = $1', [id]);
    logger.info(`Deleted subscriptions for business ID: ${id}`);
    
    // 6. Delete service tiers (which reference services)
    const serviceTiersResult = await client.query(
      'DELETE FROM tenants.service_tiers WHERE service_id IN (SELECT id FROM tenants.services WHERE business_id = $1)',
      [id]
    );
    logger.info(`Deleted ${serviceTiersResult.rowCount} service tiers for business ID: ${id}`);
    
    // 7. Delete services
    await client.query('DELETE FROM tenants.services WHERE business_id = $1', [id]);
    logger.info(`Deleted services for business ID: ${id}`);
    
    // 8. Delete booking-related records
    await client.query('DELETE FROM booking.bookings WHERE affiliate_id = $1', [id]);
    logger.info(`Deleted bookings for affiliate ID: ${id}`);
    
    await client.query('DELETE FROM booking.quotes WHERE affiliate_id = $1', [id]);
    logger.info(`Deleted quotes for affiliate ID: ${id}`);
    
    await client.query('DELETE FROM booking.availability WHERE affiliate_id = $1', [id]);
    logger.info(`Deleted availability records for affiliate ID: ${id}`);
    
    // 9. Delete schedule-related records
    await client.query('DELETE FROM schedule.time_blocks WHERE affiliate_id = $1', [id]);
    logger.info(`Deleted time blocks for affiliate ID: ${id}`);
    
    await client.query('DELETE FROM schedule.blocked_days WHERE affiliate_id = $1', [id]);
    logger.info(`Deleted blocked days for affiliate ID: ${id}`);
    
    await client.query('DELETE FROM schedule.appointments WHERE affiliate_id = $1', [id]);
    logger.info(`Deleted appointments for affiliate ID: ${id}`);
    
    await client.query('DELETE FROM schedule.schedule_settings WHERE affiliate_id = $1', [id]);
    logger.info(`Deleted schedule settings for affiliate ID: ${id}`);
    
    // 10. Delete customer-related records (if any customers are linked to this tenant's bookings)
    // Note: We don't delete customers themselves as they may have interacted with other tenants
    // But we do delete communications and vehicles linked to this tenant's customers
    const customerIds = await client.query(
      'SELECT DISTINCT customer_id FROM booking.bookings WHERE affiliate_id = $1 AND customer_id IS NOT NULL',
      [id]
    );
    if (customerIds.rowCount > 0) {
      const ids = customerIds.rows.map(r => r.customer_id);
      // Only delete communications/vehicles if customers are exclusive to this tenant
      logger.info(`Found ${ids.length} customers associated with tenant`);
    }
    
    // 11. Get user_id before deleting tenant record
    const userIdResult = await client.query('SELECT user_id FROM tenants.business WHERE id = $1', [id]);
    const userId = userIdResult.rowCount > 0 ? userIdResult.rows[0].user_id : null;
    
    // 12. Delete the tenant record itself
    const deleteTenantQuery = 'DELETE FROM tenants.business WHERE id = $1';
    await client.query(deleteTenantQuery, [id]);
    logger.info(`Deleted tenant record ${id}`);
    
    // 13. Finally, delete the corresponding user record (if exists)
    if (userId) {
      await client.query('DELETE FROM auth.users WHERE id = $1', [userId]);
      logger.info(`Deleted user record for user ID: ${userId}`);
    } else if (tenant.email) {
      // Fallback: try deleting by email
      const userDeleteResult = await client.query('DELETE FROM auth.users WHERE email = $1', [tenant.email]);
      logger.info(`Deleted ${userDeleteResult.rowCount} user record(s) for email: ${tenant.email}`);
    }
    
    // Audit log the tenant deletion
    logger.audit('DELETE_TENANT', 'tenants', tenantBeforeState, null, {
      userId: req.user.userId,
      email: req.user.email
    });
    
    // Commit the transaction
    await client.query('COMMIT');
    
    logger.info(`Successfully deleted tenant: ${tenant.business_name} (${tenant.slug})`);
    
    res.json({
      success: true,
      message: `Tenant "${tenant.business_name}" has been deleted successfully`,
      deletedTenant: {
        id: parseInt(id),
        business_name: tenant.business_name,
        slug: tenant.slug,
        email: tenant.email
      }
    });
    
  } catch (transactionError) {
    await client.query('ROLLBACK');
    throw transactionError;
  } finally {
    client.release();
  }
}));

/**
 * GET /api/admin/users
 * Get all users with their roles and tenant information
 * @param {string} [status] - Filter by user status (admin, tenant, customer, all-users)
 * @param {string} [slug] - Filter tenants by slug
 * @returns {Object} Success response with users array and count
 */
router.get('/users', authenticateToken, requireAdmin, asyncHandler(async (req, res) => {
  try {
    const pool = await getPool();
    
    const { status } = req.query;
    
    // Audit log the users query
    logger.adminAction('QUERY_USERS', 'users', { 
      status: status || 'all-users',
      query: status === 'tenants' ? 'tenants_table' : 'users_table'
    }, {
      userId: req.user?.userId || 'anonymous',
      email: req.user?.email || 'anonymous'
    });
  
  if (status === 'tenants') {
    // For tenants, query the tenants table directly
    try {
      let query = `
        SELECT 
          t.id,
          t.business_name as name,
          t.business_email as email,
          t.owner,
          t.slug,
          t.application_status,
          t.business_phone as phone,
          t.created_at,
          'tenant' as role,
          t.service_areas
        FROM tenants.business t
        WHERE t.application_status = 'approved'
      `;
      
      const params = [];
      let paramIndex = 1;
      
      // Add slug filter if provided
      if (req.query.slug) {
        query += ` AND t.slug = $${paramIndex}`;
        params.push(req.query.slug);
        paramIndex++;
        logger.debug(`[ADMIN] Adding slug filter: ${req.query.slug}`);
      }
      
      query += ' ORDER BY t.created_at DESC';
      
      const result = await pool.query(query, params);
      
      logger.debug(`[ADMIN] Tenants query returned ${result.rowCount} approved tenants`);
      
      res.json({
        success: true,
        users: result.rows,
        count: result.rowCount,
        message: `Found ${result.rowCount} approved tenants in database`
      });
      return;
    } catch (tenantErr) {
      logger.error('Error in tenants query:', { error: tenantErr.message });
      throw tenantErr;
    }
  }
  
  // Get all users with their roles (admin, tenant, customer)
  let query = `
    SELECT 
      u.id, 
      u.name, 
      u.email, 
      u.is_admin, 
      u.created_at,
      t.id as tenant_id,
      t.business_name,
      t.slug,
      CASE 
        WHEN u.is_admin = true THEN 'admin'
        WHEN t.id IS NOT NULL AND t.application_status = 'approved' THEN 'tenant'
        ELSE 'customer'
      END as role
    FROM auth.users u
    LEFT JOIN tenants.business t ON u.id = t.user_id
  `;
  const params = [];
  let paramIndex = 1;
  
  if (status && status !== 'all-users') {
    // Filter by specific role
    if (status === 'admin') {
      query += ` WHERE u.is_admin = $${paramIndex}`;
      params.push(true);
      paramIndex++;
    } else if (status === 'tenant') {
      query += ` WHERE t.id IS NOT NULL AND t.application_status = 'approved'`;
    } else if (status === 'customer') {
      query += ` WHERE u.is_admin = $${paramIndex} AND t.id IS NULL`;
      params.push(false);
      paramIndex++;
    }
  }
  
  query += ' ORDER BY u.created_at DESC';
  
  const result = await pool.query(query, params);
  
  // Transform the results to include role information
  const usersWithRoles = result.rows.map(row => ({
    ...row,
    role: row.role || (row.is_admin ? 'admin' : row.tenant_id ? 'tenant' : 'customer')
  }));
  
    res.json({
      success: true,
      users: usersWithRoles,
      count: result.rowCount,
      message: `Found ${result.rowCount} users in database`
    });
  } catch (error) {
    logger.error('Error in admin users endpoint:', { 
      error: error.message, 
      stack: error.stack,
      userId: req.user?.userId,
      email: req.user?.email
    });
    throw error;
  }
}));

/**
 * GET /api/admin/pending-applications
 * Get all pending tenant applications
 * @returns {Object} Success response with applications array and count
 */
router.get('/pending-applications', authenticateToken, requireAdmin, asyncHandler(async (req, res) => {

  const pool = await getPool();
  
  // Audit log the pending applications query
  logger.adminAction('QUERY_PENDING_APPLICATIONS', 'tenants', { 
    status: 'pending',
    query_type: 'pending_applications'
  }, {
    userId: req.user.userId,
    email: req.user.email
  });
  
        const query = `
      SELECT 
        a.id, a.slug, a.business_name, a.owner, a.business_phone as phone, a.business_email as email, 
        a.has_insurance, a.source, a.notes, a.application_date, a.created_at,
        a.service_areas
      FROM tenants.business a
      WHERE a.application_status = 'pending' 
      ORDER BY a.application_date DESC
    `;
  
  const result = await pool.query(query);
  
  res.json({
    success: true,
    applications: result.rows,
    count: result.rowCount,
    message: `Found ${result.rowCount} pending applications`
  });
}));

/**
 * POST /api/admin/approve-application/:id
 * Approve a pending tenant application
 * @param {string} id - Application ID
 * @param {string} approved_slug - Approved business slug
 * @param {string} [admin_notes] - Optional admin notes
 * @returns {Object} Success response with tenant info and temp password
 */
router.post('/approve-application/:id', authenticateToken, requireAdmin, asyncHandler(async (req, res) => {

  const pool = await getPool();
  const { id } = req.params;
  const { approved_slug, admin_notes } = req.body;
  
  // Validate admin notes length
  if (admin_notes && admin_notes.length > 1000) {
    const error = new Error('Admin notes must be less than 1000 characters long');
    error.statusCode = 400;
    throw error;
  }
  
  // Validate slug format and length
  if (!approved_slug || approved_slug.length < 3 || approved_slug.length > 50) {
    const error = new Error('Slug must be between 3 and 50 characters long');
    error.statusCode = 400;
    throw error;
  }
  
  if (!/^[a-z0-9-]+$/.test(approved_slug)) {
    const error = new Error('Slug must contain only lowercase letters, numbers, and hyphens');
    error.statusCode = 400;
    throw error;
  }
  
  if (approved_slug.startsWith('-') || approved_slug.endsWith('-')) {
    const error = new Error('Slug cannot start or end with a hyphen');
    error.statusCode = 400;
    throw error;
  }
  
  if (approved_slug.includes('--')) {
    const error = new Error('Slug cannot contain consecutive hyphens');
    error.statusCode = 400;
    throw error;
  }
  

  
  // Check if slug is already taken
  const slugCheckQuery = 'SELECT id FROM tenants.business WHERE slug = $1 AND id != $2';
  const slugCheck = await pool.query(slugCheckQuery, [approved_slug, id]);
  
  if (slugCheck.rowCount > 0) {
    const error = new Error('Slug is already taken by another tenant');
    error.statusCode = 400;
    throw error;
  }
  
  // Check if application is still pending before updating
  const statusCheckQuery = 'SELECT application_status FROM tenants.business WHERE id = $1';
  const statusCheck = await pool.query(statusCheckQuery, [id]);
  
  if (statusCheck.rowCount === 0) {
    const error = new Error('Application not found');
    error.statusCode = 404;
    throw error;
  }
  
  if (statusCheck.rows[0].application_status !== 'pending') {
    const error = new Error('Application has already been processed');
    error.statusCode = 400;
    throw error;
  }
  
  // Get the current state for audit logging
  const currentStateQuery = 'SELECT * FROM tenants.business WHERE id = $1';
  const currentStateResult = await pool.query(currentStateQuery, [id]);
  const beforeState = currentStateResult.rows[0];
  
  // Update tenant status to approved
  const updateQuery = `
    UPDATE tenants.business 
    SET 
      application_status = 'approved',
      slug = $1,
      approved_date = NOW(),
      notes = CASE 
        WHEN notes IS NULL THEN $2
        ELSE notes || E'\n\nAdmin Approval Notes: ' || $2
      END
    WHERE id = $3 AND application_status = 'pending'
    RETURNING *
  `;
  
  const result = await pool.query(updateQuery, [approved_slug, admin_notes, id]);
  
  if (result.rowCount === 0) {
    const error = new Error('Application was modified by another admin. Please refresh and try again.');
    error.statusCode = 409;
    throw error;
  }
  
  const tenant = result.rows[0];
  
  // Create user account for approved tenant
  const userQuery = `
    INSERT INTO auth.users (email, password_hash, name, phone, is_admin, created_at)
    VALUES ($1, $2, $3, $4, $5, NOW())
    RETURNING id
  `;
  
  // Generate a temporary password (tenant will reset this)
  const tempPassword = Math.random().toString(36).substring(2, 15);
  const bcrypt = await import('bcryptjs');
  const hashedPassword = await bcrypt.hash(tempPassword, 10);
  
  const userResult = await pool.query(userQuery, [
    tenant.business_email,
    hashedPassword,
    tenant.owner,
    tenant.business_phone,
    false  // is_admin = false for tenants
  ]);
  
  const userId = userResult.rows[0].id;
  
  // Audit log the tenant approval
  const afterState = {
    ...tenant,
    user_id: userId
  };
  
  logger.audit('APPROVE_TENANT', 'tenants', beforeState, afterState, {
    userId: req.user.userId,
    email: req.user.email
  });
  
  // User account is created for tenant access
  // No need for additional junction table
  
        // Process service areas if provided
      let serviceAreaResult = null;

      // Use existing service areas from the tenant record
      let serviceAreasToProcess = tenant.service_areas || [];
      if (!serviceAreasToProcess || !Array.isArray(serviceAreasToProcess) || serviceAreasToProcess.length === 0) {
        logger.warn(`No service areas found for tenant ${tenant.id}`);
        serviceAreasToProcess = [];
      }

      if (serviceAreasToProcess && Array.isArray(serviceAreasToProcess) && serviceAreasToProcess.length > 0) {
        try {
          // CLEAN APPROACH: Direct database inserts with proper service area structure
          logger.info(`Processing ${serviceAreasToProcess.length} service areas for tenant ${tenant.id}`);
          
          let processed = 0;
          const cleanServiceAreas = [];
          
          for (const area of serviceAreasToProcess) {
            const { city, state, zip } = area;
            
            if (!city || !state) {
              logger.warn(`Skipping service area with missing city or state: ${JSON.stringify(area)}`);
              continue;
            }

            // Create clean service area without slug (Option 1: Clean Separation)
            const serviceArea = {
              city: city,
              state: state.toUpperCase(),
              zip: zip ? parseInt(zip) : null,
              primary: true, // Base location is always primary
              minimum: 0, // Default minimum
              multiplier: 1.0 // Default multiplier
            };
            
            cleanServiceAreas.push(serviceArea);
            processed++;
            logger.debug(`Prepared service area: ${city}, ${state} (clean structure, no slug)`);
          }
          
          // Update tenant with clean service areas (no slugs)
          await pool.query(
            'UPDATE tenants.business SET service_areas = $1 WHERE id = $2',
            [JSON.stringify(cleanServiceAreas), tenant.id]
          );
          
          serviceAreaResult = { processed, errors: [], total: serviceAreasToProcess.length, serviceAreas: cleanServiceAreas };
          logger.info(`✅ Successfully processed ${processed} service areas for tenant ${tenant.id} with clean structure`);
          
        } catch (serviceAreaError) {
          logger.error(`Failed to process service areas for tenant ${tenant.id}:`, serviceAreaError);
          // Don't fail the approval if service area processing fails
          serviceAreaResult = { error: serviceAreaError.message };
        }
      }
  
  res.json({
    success: true,
    message: 'Application approved successfully',
    tenant: {
      ...tenant,
      user_id: userId,
      temp_password: tempPassword
    },
    service_areas: serviceAreaResult,
    note: 'User account created with temporary password. Tenant should reset password on first login.'
  });
}));

// Reject tenant application endpoint
router.post('/reject-application/:id', authenticateToken, requireAdmin, asyncHandler(async (req, res) => {

  const pool = await getPool();
  const { id } = req.params;
  const { rejection_reason, admin_notes } = req.body;
  
  // Validate admin notes length
  if (admin_notes && admin_notes.length > 1000) {
    const error = new Error('Admin notes must be less than 1000 characters long');
    error.statusCode = 400;
    throw error;
  }
  
  // Validate rejection reason
  if (!rejection_reason || rejection_reason.trim().length < 10) {
    const error = new Error('Rejection reason must be at least 10 characters long');
    error.statusCode = 400;
    throw error;
  }
  
  if (rejection_reason.trim().length > 500) {
    const error = new Error('Rejection reason must be less than 500 characters long');
    error.statusCode = 400;
    throw error;
  }
  
  // Check if application is still pending before updating
  const statusCheckQuery = 'SELECT application_status FROM tenants.business WHERE id = $1';
  const statusCheck = await pool.query(statusCheckQuery, [id]);
  
  if (statusCheck.rowCount === 0) {
    const error = new Error('Application not found');
    error.statusCode = 404;
    throw error;
  }
  
  if (statusCheck.rows[0].application_status !== 'pending') {
    const error = new Error('Application has already been processed');
    error.statusCode = 400;
    throw error;
  }
  
  // Get the current state for audit logging
  const currentStateQuery = 'SELECT * FROM tenants.business WHERE id = $1';
  const currentStateResult = await pool.query(currentStateQuery, [id]);
  const beforeState = currentStateResult.rows[0];
  
  const updateQuery = `
    UPDATE tenants.business 
    SET 
      application_status = 'rejected',
      notes = CASE 
        WHEN notes IS NULL THEN $1
        ELSE notes || E'\n\nRejection Reason: ' || $1 || E'\nAdmin Notes: ' || $2
      END
    WHERE id = $3 AND application_status = 'pending'
    RETURNING *
  `;
  
  const result = await pool.query(updateQuery, [rejection_reason, admin_notes, id]);
  
  if (result.rowCount === 0) {
    const error = new Error('Application was modified by another admin. Please refresh and try again.');
    error.statusCode = 409;
    throw error;
  }
  
  const afterState = result.rows[0];
  
  // Audit log the tenant rejection
  logger.audit('REJECT_TENANT', 'tenants', beforeState, afterState, {
    userId: req.user.userId,
    email: req.user.email
  });
  
  res.json({
    success: true,
    message: 'Application rejected successfully',
    tenant: result.rows[0]
  });
}));

// Get platform service areas (all cities/states where approved tenants serve)
router.get('/service-areas', authenticateToken, requireAdmin, asyncHandler(async (req, res) => {
  const pool = await getPool();

  try {
    const { getPlatformServiceAreas } = await import('../utils/serviceAreaProcessor.js');
    const serviceAreas = await getPlatformServiceAreas();
    
    res.json({
      success: true,
      service_areas: serviceAreas,
      count: serviceAreas.length
    });
  } catch (error) {
    logger.error('Error fetching platform service areas:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch service areas'
    });
  }
}));

// Seed reviews endpoint
router.post('/seed-reviews', authenticateToken, requireAdmin, asyncHandler(async (req, res) => {
  logger.debug('Seed reviews endpoint called', { 
    userId: req.user?.userId,
    email: req.user?.email,
    ip: req.ip
  });
  
  const pool = await getPool();

  const { reviews } = req.body;

  if (!reviews || !Array.isArray(reviews) || reviews.length === 0) {
    const error = new Error('Reviews array is required and must not be empty');
    error.statusCode = 400;
    throw error;
  }

  // Validate each review
  for (const review of reviews) {
    if (!review.name || !review.title || !review.content || !review.stars || !review.type) {
      const error = new Error('Each review must have name, title, content, stars, and type');
      error.statusCode = 400;
      throw error;
    }

    if (review.stars < 1 || review.stars > 5) {
      const error = new Error('Stars must be between 1 and 5');
      error.statusCode = 400;
      throw error;
    }

    if (review.type === 'tenant' && !review.businessSlug) {
      const error = new Error('Tenant reviews must have a businessSlug');
      error.statusCode = 400;
      throw error;
    }
  }

  const client = await pool.connect();
  let successCount = 0;
  let errorCount = 0;
  const errors = [];
  const result = { reviewIds: [] };

  try {
    await client.query('BEGIN');

    for (const review of reviews) {
      try {
        let tenantId = null;

        // Get tenant_id if this is a tenant review
        if (review.type === 'tenant') {
          const tenantQuery = 'SELECT id FROM tenants.business WHERE slug = $1';
          const tenantResult = await client.query(tenantQuery, [review.businessSlug]);
          
          if (tenantResult.rowCount === 0) {
            errors.push(`Business slug '${review.businessSlug}' not found`);
            errorCount++;
            continue;
          }
          
          // Double-check that we have a valid result before accessing it
          if (tenantResult.rows && tenantResult.rows.length > 0) {
            tenantId = tenantResult.rows[0].id;
          } else {
            errors.push(`Business slug '${review.businessSlug}' query returned no results`);
            errorCount++;
            continue;
          }
        }

        // Generate automatic fields
        const generateEmail = (name) => {
          const cleanName = name.toLowerCase()
            .replace(/[^a-z0-9\s]/g, '')
            .replace(/\s+/g, '.');
          return `${cleanName}@email.com`;
        };

        // Import avatar utilities
        const { getAvatarUrl, findCustomAvatar } = await import('../utils/avatarUtils.js');

        // Helper function to determine service category from review content
        // TODO: Move to shared utils if needed elsewhere
        const _getServiceCategory = (content) => {
          const lowerContent = content.toLowerCase();
          if (lowerContent.includes('ceramic') || lowerContent.includes('coating')) {return 'ceramic';}
          if (lowerContent.includes('paint correction') || lowerContent.includes('paint')) {return 'paint_correction';}
          if (lowerContent.includes('boat') || lowerContent.includes('marine')) {return 'boat';}
          if (lowerContent.includes('rv') || lowerContent.includes('recreational')) {return 'rv';}
          if (lowerContent.includes('ppf') || lowerContent.includes('film')) {return 'ppf';}
          return 'auto';
        };

        // Helper function to generate service dates for reviews
        // TODO: Move to shared utils if needed elsewhere
        const _generateServiceDate = (daysAgo, weeksAgo) => {
          const now = new Date();
          let reviewDate;
          
          if (daysAgo > 0) {
            // Use days ago (0-6 days)
            reviewDate = new Date(now.getTime() - (daysAgo * 24 * 60 * 60 * 1000));
          } else if (weeksAgo > 0) {
            // Use weeks ago (1+ weeks)
            reviewDate = new Date(now.getTime() - (weeksAgo * 7 * 24 * 60 * 60 * 1000));
          } else {
            // Default to random date within last 6 months
            const sixMonthsAgo = new Date(now.getTime() - (6 * 30 * 24 * 60 * 60 * 1000));
            const randomTime = sixMonthsAgo.getTime() + Math.random() * (now.getTime() - sixMonthsAgo.getTime());
            reviewDate = new Date(randomTime);
          }
          
          return reviewDate.toISOString().split('T')[0];
        };

        const shouldBeFeatured = (stars, content) => {
          return stars === 5 && content.length > 100;
        };

        const email = generateEmail(review.name);
        const avatarUrl = getAvatarUrl(review.name, null, review.source); // reviewId will be null for new reviews
        
        // Use service category from form selection
        let serviceCategory = null;
        if (review.serviceCategory && review.serviceCategory !== 'none') {
          serviceCategory = review.serviceCategory;
        }
        
        const isFeatured = shouldBeFeatured(review.stars, review.content);
        
        // Calculate service_date based on days/weeks ago or specific date
        const now = new Date();
        let serviceDate;
        if (review.specificDate) {
          // Use specific date if provided
          serviceDate = new Date(review.specificDate).toISOString();
        } else if (review.daysAgo > 0) {
          serviceDate = new Date(now.getTime() - (review.daysAgo * 24 * 60 * 60 * 1000)).toISOString();
        } else if (review.weeksAgo > 0) {
          serviceDate = new Date(now.getTime() - (review.weeksAgo * 7 * 24 * 60 * 60 * 1000)).toISOString();
        } else {
          serviceDate = new Date().toISOString();
        }

        // Insert review
        const insertQuery = `
          INSERT INTO reputation.reviews (
            review_type,
            tenant_id,
            business_slug,
            rating,
            title,
            content,
            reviewer_name,
            reviewer_email,
            reviewer_avatar_url,
            reviewer_url,
            review_source,
            status,
            is_verified,
            service_category,
            service_date,
            is_featured,
            published_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
          RETURNING id
        `;

        const values = [
          review.type,
          tenantId,
          review.businessSlug,
          review.stars,
          review.title,
          review.content,
          review.name,
          email,
          avatarUrl,
          review.reviewerUrl || null,
          review.source || 'website',
          'approved',
          true,
          serviceCategory,
          serviceDate,
          isFeatured,
          serviceDate // Use serviceDate for published_at as well
        ];
        

        logger.debug('Executing review insert query', { 
          reviewTitle: review.title,
          businessSlug: review.businessSlug
        });
        const insertResult = await client.query(insertQuery, values);
        
        // Check if the insert was successful
        if (!insertResult.rows || insertResult.rows.length === 0) {
          errors.push(`Failed to insert review "${review.title}" - no result returned`);
          errorCount++;
          continue;
        }
        
        const reviewId = insertResult.rows[0].id;
        successCount++;
        
        // Store review ID for avatar upload
        result.reviewIds.push(reviewId);
        
        // Check if there's a custom avatar for this review and update the database
        const customAvatar = findCustomAvatar(review.name, reviewId);
        if (customAvatar) {
          await client.query(
            'UPDATE reputation.reviews SET reviewer_avatar_url = $1 WHERE id = $2',
            [customAvatar, reviewId]
          );
          logger.debug('Updated review with custom avatar', { 
            reviewId, 
            customAvatar 
          });
        }

      } catch (reviewError) {
        errors.push(`Error adding review "${review.title}": ${reviewError.message}`);
        errorCount++;
      }
    }

    await client.query('COMMIT');

    // Audit log the review seeding
    logger.audit('SEED_REVIEWS', 'reviews', { 
      totalSubmitted: reviews.length,
      successCount,
      errorCount,
      errors: errors.slice(0, 5) // Log first 5 errors
    }, null, {
      userId: req.user.userId,
      email: req.user.email
    });

    res.json({
      success: true,
      message: `Successfully seeded ${successCount} reviews`,
      count: successCount,
      errors: errorCount,
      errorDetails: errors,
      reviewIds: result.reviewIds
    });

  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}));

export default router;


/*──────────────── backend\routes\analytics.js ────────────────*/

import express from 'express';
const router = express.Router();
import { getPool } from '../database/pool.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import logger from '../utils/logger.js';

// Initialize pool
let pool;
(async () => { 
  try {
    pool = await getPool(); 
  } catch (error) {
    logger.warn('Failed to initialize analytics pool:', error.message);
  }
})();

/**
 * POST /api/analytics/track
 * Track custom analytics events
 */
router.post('/track', asyncHandler(async (req, res) => {
  const { event, parameters, userProperties, customDimensions, timestamp } = req.body;
  
  // Validate required fields
  if (!event) {
    const error = new Error('Event name is required for analytics tracking');
    error.statusCode = 400;
    throw error;
  }

    // Get client information
    const clientInfo = {
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      referer: req.get('Referer'),
      timestamp: timestamp || new Date().toISOString()
    };

    // Extract tenant information from domain
    const host = req.get('host');
    let tenantId = null;
    
    if (pool) {
      try {
        const result = await pool.query(`
          SELECT id, slug, business_name
          FROM tenants.business 
          WHERE website_domain = $1 
             OR $1 LIKE '%' || slug || '%'
          ORDER BY approved_date DESC
          LIMIT 1
        `, [host]);
        
        if (result.rows.length > 0) {
          tenantId = result.rows[0].id;
        }
      } catch (dbError) {
        logger.warn('Database error while tracking analytics:', dbError.message);
      }
    }

    // Store analytics event (if database is available)
    if (pool && tenantId) {
      try {
        await pool.query(`
          INSERT INTO analytics.events (
            tenant_id,
            event_name,
            event_parameters,
            user_properties,
            custom_dimensions,
            client_info,
            created_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        `, [
          tenantId,
          event,
          JSON.stringify(parameters || {}),
          JSON.stringify(userProperties || {}),
          JSON.stringify(customDimensions || {}),
          JSON.stringify(clientInfo),
          new Date()
        ]);
      } catch (dbError) {
        logger.warn('Failed to store analytics event in database:', dbError.message);
      }
    }

    // Log analytics event
    logger.info('Analytics event tracked', {
      event,
      tenantId,
      host,
      parameters: parameters ? Object.keys(parameters).length : 0
    });

  res.status(200).json({
    success: true,
    message: 'Analytics event tracked successfully',
    eventId: Date.now() // Simple event ID for confirmation
  });
}));

/**
 * GET /api/analytics/events/:tenantId
 * Get analytics events for a tenant (admin only)
 */
router.get('/events/:tenantId', asyncHandler(async (req, res) => {
  const { tenantId } = req.params;
  const { limit = 100, offset = 0, eventType } = req.query;

  if (!pool) {
    const error = new Error('Analytics data is not available');
    error.statusCode = 503;
    throw error;
  }

    let query = `
      SELECT 
        id,
        event_name,
        event_parameters,
        user_properties,
        custom_dimensions,
        client_info,
        created_at
      FROM analytics.events
      WHERE tenant_id = $1
    `;
    
    const queryParams = [tenantId];
    
    if (eventType) {
      query += ` AND event_name = $${queryParams.length + 1}`;
      queryParams.push(eventType);
    }
    
    query += ` ORDER BY created_at DESC LIMIT $${queryParams.length + 1} OFFSET $${queryParams.length + 2}`;
    queryParams.push(parseInt(limit), parseInt(offset));

    const result = await pool.query(query, queryParams);

  res.json({
    success: true,
    events: result.rows,
    total: result.rows.length,
    limit: parseInt(limit),
    offset: parseInt(offset)
  });
}));

/**
 * GET /api/analytics/summary/:tenantId
 * Get analytics summary for a tenant (admin only)
 */
router.get('/summary/:tenantId', asyncHandler(async (req, res) => {
  const { tenantId } = req.params;
  const { days = 30 } = req.query;

  if (!pool) {
    const error = new Error('Analytics summary is not available');
    error.statusCode = 503;
    throw error;
  }

    const result = await pool.query(`
      SELECT 
        event_name,
        COUNT(*) as event_count,
        COUNT(DISTINCT client_info->>'ip') as unique_visitors,
        DATE_TRUNC('day', created_at) as date
      FROM analytics.events
      WHERE tenant_id = $1 
        AND created_at >= NOW() - INTERVAL '${parseInt(days)} days'
      GROUP BY event_name, DATE_TRUNC('day', created_at)
      ORDER BY date DESC
    `, [tenantId]);

    // Process results into summary format
    const summary = {
      totalEvents: 0,
      uniqueVisitors: 0,
      eventsByType: {},
      eventsByDay: {},
      dateRange: {
        start: new Date(Date.now() - parseInt(days) * 24 * 60 * 60 * 1000).toISOString(),
        end: new Date().toISOString()
      }
    };

    result.rows.forEach(row => {
      summary.totalEvents += parseInt(row.event_count);
      summary.uniqueVisitors += parseInt(row.unique_visitors);
      
      // Events by type
      if (!summary.eventsByType[row.event_name]) {
        summary.eventsByType[row.event_name] = 0;
      }
      summary.eventsByType[row.event_name] += parseInt(row.event_count);
      
      // Events by day
      const date = row.date.toISOString().split('T')[0];
      if (!summary.eventsByDay[date]) {
        summary.eventsByDay[date] = 0;
      }
      summary.eventsByDay[date] += parseInt(row.event_count);
    });

  res.json({
    success: true,
    summary,
    days: parseInt(days)
  });
}));

export default router;


/*──────────────── backend\routes\auth.js ────────────────*/

import express from 'express';
import { authenticateToken } from '../middleware/auth.js';
import { validateBody, validateQuery } from '../middleware/zodValidation.js';
import { authSchemas } from '../schemas/apiSchemas.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { authLimiter, sensitiveAuthLimiter, refreshTokenLimiter } from '../middleware/rateLimiter.js';
import * as authController from '../controllers/authController.js';
import * as passwordResetController from '../controllers/passwordResetController.js';
import * as passwordSetupController from '../controllers/passwordSetupController.js';
import { getPool } from '../database/pool.js';
import * as authService from '../services/authService.js';
import { createModuleLogger } from '../config/logger.js';

const router = express.Router();
const logger = createModuleLogger('authRoutes');

// Check if email exists (for onboarding validation)
router.get('/check-email', 
  authLimiter, 
  validateQuery(authSchemas.checkEmail),
  asyncHandler(authController.checkEmail)
);

// User Registration
router.post('/register', 
  sensitiveAuthLimiter,
  validateBody(authSchemas.register),
  asyncHandler(authController.register)
);

// User Login
router.post('/login', 
  sensitiveAuthLimiter,
  validateBody(authSchemas.login),
  asyncHandler(authController.login)
);

// Get Current User (Protected Route)
router.get('/me', authenticateToken, asyncHandler(async (req, res) => {

  const pool = await getPool();
  
  const result = await pool.query('SELECT id, email, name, phone, is_admin, created_at FROM auth.users WHERE id = $1', [req.user.userId]);
  if (result.rows.length === 0) {
    const error = new Error('User not found');
    error.statusCode = 404;
    throw error;
  }
  
  const user = result.rows[0];
  
  // Check if user should be admin based on environment variable
  const ADMIN_EMAILS = process.env.ADMIN_EMAILS?.split(',') || [];
  let isAdmin = user.is_admin || false;
  
  // Auto-promote to admin if email is in ADMIN_EMAILS list
  if (ADMIN_EMAILS.includes(user.email) && !user.is_admin) {
    await pool.query('UPDATE auth.users SET is_admin = TRUE WHERE id = $1', [user.id]);
    isAdmin = true;
  }
  
  // Check if user is a tenant and get tenant ID
  let tenantId = null;
  if (!isAdmin) {
    const tenantResult = await pool.query(
      'SELECT id FROM tenants.business WHERE user_id = $1 LIMIT 1',
      [user.id]
    );
    if (tenantResult.rows.length > 0) {
      tenantId = tenantResult.rows[0].id;
    }
  }
  
  res.json({
    ...user,
    is_admin: isAdmin,
    tenant_id: tenantId
  });
}));

/**
 * Refresh token endpoint
 * 
 * Accepts refresh token from:
 * - Request body: { "refreshToken": "..." }
 * - Cookie: refreshToken=...
 * 
 * Returns new access token + optional refresh token
 * No Authorization header required (uses refresh token for authentication)
 */
router.post('/refresh', refreshTokenLimiter, asyncHandler(async (req, res) => {
  // Accept refresh token from body or cookie (flexible input)
  const refreshToken = req.body.refreshToken || req.cookies?.refreshToken;
  
  if (!refreshToken) {
    const error = new Error('Refresh token is required in body or cookie');
    error.statusCode = 400;
    throw error;
  }

  // Hash the refresh token for database lookup
  const crypto = await import('crypto');
  const tokenHash = crypto.createHash('sha256').update(refreshToken).digest('hex');
  
  // Validate refresh token
  const tokenRecord = await authService.validateRefreshToken(tokenHash);
  if (!tokenRecord) {
    const error = new Error('Invalid or expired refresh token');
    error.statusCode = 401;
    throw error;
  }

  // Generate new token pair
  const tokenPayload = {
    userId: tokenRecord.user_id,
    email: tokenRecord.email,
    isAdmin: tokenRecord.is_admin
  };
  
  const tokens = authService.generateTokenPair(tokenPayload);
  
  // Update refresh token in database
  const deviceId = authService.generateDeviceId(req.get('User-Agent'), req.ip);
  const newTokenHash = crypto.createHash('sha256').update(tokens.refreshToken).digest('hex');
  
  await authService.storeRefreshToken(
    tokenRecord.user_id,
    newTokenHash,
    new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
    req.ip,
    req.get('User-Agent'),
    deviceId
  );

  // Revoke old refresh token
  await authService.revokeRefreshToken(tokenHash);

  // Set HttpOnly cookies for enhanced security
  const { AUTH_CONFIG } = await import('../config/auth.js');
  res.cookie('access_token', tokens.accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    path: '/',
    maxAge: 15 * 60 * 1000 // 15 minutes (matches access token expiry)
  });
  
  res.cookie(AUTH_CONFIG.REFRESH_COOKIE_NAME, tokens.refreshToken, AUTH_CONFIG.getRefreshCookieOptions());

  // Consistent response format matching login endpoint
  res.json({
    success: true,
    user: {
      id: tokenRecord.user_id,
      email: tokenRecord.email,
      is_admin: tokenRecord.is_admin
    },
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken,
    expiresIn: tokens.expiresIn,
    refreshExpiresIn: tokens.refreshExpiresIn
  });
}));

// Logout endpoint
router.post('/logout', authenticateToken, asyncHandler(async (req, res) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (token) {
    // Blacklist the access token with additional context
    await authService.blacklistToken(token, {
      reason: 'logout',
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    });
  }

  // Revoke all refresh tokens for the user
  await authService.revokeAllUserTokens(req.user.userId);

  // Clear HttpOnly cookies
  res.clearCookie('access_token', {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    path: '/'
  });
  
  const { AUTH_CONFIG: AUTH_CFG } = await import('../config/auth.js');
  res.clearCookie(AUTH_CFG.REFRESH_COOKIE_NAME, AUTH_CFG.getRefreshCookieOptions());

  res.json({ success: true, message: 'Logged out successfully' });
}));

// Logout from specific device
router.post('/logout-device', authenticateToken, asyncHandler(async (req, res) => {
  const { deviceId } = req.body;
  
  if (!deviceId) {
    const error = new Error('Device ID is required');
    error.statusCode = 400;
    throw error;
  }

  // Revoke refresh token for specific device
  const revoked = await authService.revokeDeviceToken(req.user.userId, deviceId);
  
  if (revoked) {
    res.json({ success: true, message: 'Device logged out successfully' });
  } else {
    const error = new Error('Device not found or already logged out');
    error.statusCode = 404;
    throw error;
  }
}));

// Get user's active sessions
router.get('/sessions', authenticateToken, asyncHandler(async (req, res) => {
  const sessions = await authService.getUserTokenList(req.user.userId);
  
  res.json({
    success: true,
    sessions: sessions.map(session => ({
      deviceId: session.device_id,
      createdAt: session.created_at,
      expiresAt: session.expires_at,
      ipAddress: session.ip_address,
      userAgent: session.user_agent
    }))
  });
}));

// Password Reset Routes
router.post('/request-password-reset', 
  authLimiter,
  validateBody(authSchemas.requestPasswordReset),
  passwordResetController.requestPasswordReset
);

router.post('/reset-password', 
  authLimiter,
  validateBody(authSchemas.resetPassword),
  passwordResetController.resetPassword
);

router.get('/validate-reset-token', 
  authLimiter,
  passwordResetController.validateResetToken
);

router.get('/reset-stats', 
  authenticateToken,
  passwordResetController.getResetStats
);

// Password Setup Routes (for new users)
router.post('/create-password-setup', 
  authLimiter,
  passwordSetupController.createPasswordSetup
);

router.post('/setup-password', 
  authLimiter,
  passwordSetupController.setupPassword
);

router.get('/validate-setup-token', 
  authLimiter,
  passwordSetupController.validateSetupToken
);

router.get('/setup-stats', 
  authenticateToken,
  passwordSetupController.getSetupStats
);

// Admin promotion endpoint (for development)
router.post('/promote-admin', authLimiter, asyncHandler(async (req, res) => {

  const pool = await getPool();
  
  const ADMIN_EMAILS = process.env.ADMIN_EMAILS?.split(',') || [];
  
  if (ADMIN_EMAILS.length === 0) {
    const error = new Error('No ADMIN_EMAILS configured');
    error.statusCode = 400;
    throw error;
  }
  
  // Update all users whose emails are in ADMIN_EMAILS to be admins
  const result = await pool.query(
    'UPDATE auth.users SET is_admin = TRUE WHERE email = ANY($1) RETURNING id, email, name',
    [ADMIN_EMAILS]
  );
  
  res.json({
    success: true,
    message: `Promoted ${result.rowCount} users to admin`,
    promoted: result.rows
  });
}));

export default router;


/*──────────────── backend\routes\avatar.js ────────────────*/

/**
 * @fileoverview API routes for avatar
 * @version 1.0.0
 * @author That Smart Site
 */

import express from 'express';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
const router = express.Router();
import { authenticateToken, requireAdmin } from '../middleware/auth.js';
import { generateAvatarFilename, ensureUploadsDir } from '../utils/avatarUtils.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { validateFileMagic } from '../utils/uploadValidator.js';
import logger from '../utils/logger.js';

// Configure multer for avatar uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    ensureUploadsDir();
    cb(null, 'uploads/avatars/');
  },
  filename: (req, file, cb) => {
    // Generate a simple filename since req.body isn't available yet
    const extension = path.extname(file.originalname || '').toLowerCase() || '.jpg';
    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').split('.')[0];
    const filename = `avatar_${timestamp}${extension}`;
    cb(null, filename);
  }
});

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit
  },
  fileFilter: (req, file, cb) => {
    // Only allow image files
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed'), false);
    }
  }
});

// Test avatar upload (no auth required for testing)
router.post('/test-upload', upload.single('avatar'), asyncHandler(async (req, res) => {
  logger.debug('Avatar test upload called', { 
    userId: req.user?.userId,
    ip: req.ip
  });

  if (!req.file) {
    logger.warn('Avatar test upload failed - no file provided', { 
      userId: req.user?.userId,
      ip: req.ip
    });
    return res.status(400).json({
      success: false,
      message: 'No file uploaded'
    });
  }

  // Magic number validation for avatar uploads
  const allowedImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
  const magicValidation = await validateFileMagic(req.file, allowedImageTypes);
  if (!magicValidation.success) {
    // Delete the uploaded file if validation fails
    fs.unlinkSync(req.file.path);
    return res.status(magicValidation.statusCode).json({
      success: false,
      message: magicValidation.errors[0]?.message || 'File validation failed'
    });
  }

  const { reviewerName, reviewId } = req.body;
  
  if (!reviewerName || !reviewId) {
    // Delete the uploaded file if validation fails
    fs.unlinkSync(req.file.path);
    return res.status(400).json({
      success: false,
      message: 'reviewerName and reviewId are required'
    });
  }

  // Generate proper filename and rename the file
  const extension = path.extname(req.file.originalname || '').toLowerCase() || '.jpg';
  const properFilename = generateAvatarFilename(reviewerName, reviewId, extension);
  const properPath = path.join('uploads/avatars', properFilename);
  
  try {
    // Rename the file to the proper name
    fs.renameSync(req.file.path, properPath);
    
    const avatarUrl = `/uploads/avatars/${properFilename}`;

    res.json({
      success: true,
      message: 'Avatar uploaded successfully (TEST MODE)',
      avatarUrl: avatarUrl,
      filename: properFilename
    });
  } catch (renameError) {
    // If rename fails, delete the original file and return error
    fs.unlinkSync(req.file.path);
    res.status(500).json({
      success: false,
      message: 'Error renaming uploaded file',
      error: renameError.message
    });
  }
}));

// Upload avatar for a specific review
router.post('/upload', authenticateToken, requireAdmin, upload.single('avatar'), asyncHandler(async (req, res) => {
  logger.debug('Avatar upload called', { 
    userId: req.user?.userId,
    email: req.user?.email,
    ip: req.ip
  });

  if (!req.file) {
    logger.warn('Avatar upload failed - no file provided', { 
      userId: req.user?.userId,
      ip: req.ip
    });
    return res.status(400).json({
      success: false,
      message: 'No file uploaded'
    });
  }

  // Magic number validation for avatar uploads
  const allowedImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
  const magicValidation = await validateFileMagic(req.file, allowedImageTypes);
  if (!magicValidation.success) {
    // Delete the uploaded file if validation fails
    fs.unlinkSync(req.file.path);
    return res.status(magicValidation.statusCode).json({
      success: false,
      message: magicValidation.errors[0]?.message || 'File validation failed'
    });
  }

  const { reviewerName, reviewId } = req.body;
  
  if (!reviewerName || !reviewId) {
    // Delete the uploaded file if validation fails
    fs.unlinkSync(req.file.path);
    return res.status(400).json({
      success: false,
      message: 'reviewerName and reviewId are required'
    });
  }

  // Generate proper filename and rename the file
  const extension = path.extname(req.file.originalname || '').toLowerCase() || '.jpg';
  const properFilename = generateAvatarFilename(reviewerName, reviewId, extension);
  const properPath = path.join('uploads/avatars', properFilename);
  
  try {
    // Rename the file to the proper name
    fs.renameSync(req.file.path, properPath);
    
    const avatarUrl = `/uploads/avatars/${properFilename}`;

    // Update the review record with the new avatar URL
    try {
      import {  pool  } from '../database/pool';;
      await pool.query(
        'UPDATE reputation.reviews SET reviewer_avatar_url = $1 WHERE id = $2',
        [avatarUrl, parseInt(reviewId)]
      );
      logger.info(`Updated review ${reviewId} with avatar URL: ${avatarUrl}`);
    } catch (dbError) {
      logger.error('Failed to update review with avatar URL:', dbError);
      // Don't fail the upload if database update fails, but log the error
    }

    // Log the avatar upload
    logger.audit('UPLOAD_AVATAR', 'reviews', {
      reviewerName,
      reviewId: parseInt(reviewId),
      filename: properFilename,
      originalName: req.file.originalname,
      size: req.file.size,
      avatarUrl: avatarUrl
    }, null, {
      userId: req.user.userId,
      email: req.user.email
    });

    res.json({
      success: true,
      message: 'Avatar uploaded successfully',
      avatarUrl: avatarUrl,
      filename: properFilename
    });
  } catch (renameError) {
    // If rename fails, delete the original file and return error
    fs.unlinkSync(req.file.path);
    res.status(500).json({
      success: false,
      message: 'Error renaming uploaded file',
      error: renameError.message
    });
  }
}));

// Get avatar info for a review
router.get('/info/:reviewId', authenticateToken, requireAdmin, asyncHandler((req, res) => {
  const { reviewId } = req.params;
  const { reviewerName } = req.query;
  
  if (!reviewerName) {
    return res.status(400).json({
      success: false,
      message: 'reviewerName query parameter is required'
    });
  }

  import {  findCustomAvatar  } from '../utils/avatarUtils';;
  const customAvatar = findCustomAvatar(reviewerName, parseInt(reviewId));
  
  res.json({
    success: true,
    hasCustomAvatar: !!customAvatar,
    avatarUrl: customAvatar,
    reviewId: parseInt(reviewId),
    reviewerName
  });
}));

// Delete avatar for a review
router.delete('/:reviewId', authenticateToken, requireAdmin, asyncHandler((req, res) => {
  const { reviewId } = req.params;
  const { reviewerName } = req.query;
  
  if (!reviewerName) {
    return res.status(400).json({
      success: false,
      message: 'reviewerName query parameter is required'
    });
  }

  import {  findCustomAvatar  } from '../utils/avatarUtils';;
  const customAvatar = findCustomAvatar(reviewerName, parseInt(reviewId));
  
  if (!customAvatar) {
    return res.status(404).json({
      success: false,
      message: 'No custom avatar found for this review'
    });
  }

  // Extract filename from URL
  const filename = path.basename(customAvatar);
  const filePath = path.join(__dirname, '../uploads/avatars', filename);
  
  try {
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
      
      // Log the avatar deletion
      logger.audit('DELETE_AVATAR', 'reviews', {
        reviewerName,
        reviewId: parseInt(reviewId),
        filename: filename
      }, null, {
        userId: req.user.userId,
        email: req.user.email
      });
      
      res.json({
        success: true,
        message: 'Avatar deleted successfully'
      });
    } else {
      res.status(404).json({
        success: false,
        message: 'Avatar file not found'
      });
    }
  } catch (error) {
    logger.error('Error deleting avatar:', error);
    res.status(500).json({
      success: false,
      message: 'Error deleting avatar file'
    });
  }
}));

export default router;


/*──────────────── backend\routes\customers.js ────────────────*/

/**
 * @fileoverview API routes for customers
 * @version 1.0.0
 * @author That Smart Site
 */

import express from 'express';
const router = express.Router();
import { getPool } from '../database/pool.js';
import { validateParams } from '../middleware/validation.js';
import { customerSchemas } from '../utils/validationSchemas.js';
import { asyncHandler } from '../middleware/errorHandler.js';
// TODO: Add proper logging for customer operations
// import logger from '../utils/logger.js';

// Get customers
router.get('/', asyncHandler(async (req, res) => {

  const pool = await getPool();
  
  const result = await pool.query('SELECT * FROM customers.customers LIMIT 1');
  if (result.rows.length === 0) {
    const error = new Error('customers not found');
    error.statusCode = 404;
    throw error;
  }
  res.json(result.rows[0]);
}));

// Get customer field
router.get('/field/:field', 
  validateParams(customerSchemas.getField),
  asyncHandler(async (req, res) => {
    const { field } = req.params;
    
  
    const pool = await getPool();
    
    // Use a safer approach with explicit field selection
    const fieldMap = {
      'id': 'id',
      'user_id': 'user_id',
      'default_address_id': 'default_address_id',
      'preferences': 'preferences',
      'created_at': 'created_at',
      'updated_at': 'updated_at'
    };
    
    const safeField = fieldMap[field];
    if (!safeField) {
      const error = new Error('Invalid field');
      error.statusCode = 400;
      throw error;
    }
    
    const result = await pool.query(`SELECT ${safeField} FROM customers.customers LIMIT 1`);
    if (result.rows.length === 0) {
      const error = new Error('Customer not found');
      error.statusCode = 404;
      throw error;
    }
    res.json({ [field]: result.rows[0][safeField] });
  })
);

export default router;


/*──────────────── backend\routes\domains.js ────────────────*/

/**
 * Domain Management Routes
 * Handles custom domain operations for tenants
 * 
 * Routes:
 * - GET /api/domains/:domain - Lookup tenant by domain
 * - PUT /api/domains/:tenantId - Set custom domain
 * - DELETE /api/domains/:tenantId - Remove domain
 * - GET /api/domains/:tenantId/status - Get domain status
 * - POST /api/domains/:tenantId/verify - Verify domain
 * - GET /api/domains/:domain/available - Check domain availability
 */

import express from 'express';
import * as domainController from '../controllers/domainController.js';
import { createModuleLogger } from '../config/logger.js';

const logger = createModuleLogger('domainRoutes');
const router = express.Router();

// Log all domain route requests
router.use((req, res, next) => {
  logger.info({
    event: 'domain_route_request',
    method: req.method,
    path: req.path,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  }, 'Domain route requested');
  next();
});

/**
 * GET /api/domains/:domain
 * Lookup tenant by custom domain
 * 
 * @example
 * GET /api/domains/mycustomdomain.com
 * Response: { success: true, data: { id, slug, business_name, custom_domain, ... } }
 */
router.get('/:domain', domainController.getDomainTenant);

/**
 * GET /api/domains/:domain/available
 * Check if a domain is available for use
 * 
 * @example
 * GET /api/domains/mycustomdomain.com/available?excludeTenantId=123
 * Response: { success: true, data: { domain: "mycustomdomain.com", available: true } }
 */
router.get('/:domain/available', domainController.checkDomainAvailability);

/**
 * PUT /api/domains/:tenantId
 * Set or update custom domain for a tenant
 * 
 * @example
 * PUT /api/domains/123
 * Body: { "customDomain": "mycustomdomain.com" }
 * Response: { success: true, data: { id, slug, custom_domain, domain_verified, ... } }
 */
router.put('/:tenantId', domainController.setCustomDomain);

/**
 * DELETE /api/domains/:tenantId
 * Remove custom domain from a tenant
 * 
 * @example
 * DELETE /api/domains/123
 * Response: { success: true, data: { id, slug, custom_domain: null, ... } }
 */
router.delete('/:tenantId', domainController.removeCustomDomain);

/**
 * GET /api/domains/:tenantId/status
 * Get domain verification and SSL status for a tenant
 * 
 * @example
 * GET /api/domains/123/status
 * Response: { success: true, data: { custom_domain, domain_verified, ssl_enabled, domain_added_at } }
 */
router.get('/:tenantId/status', domainController.getDomainStatus);

/**
 * POST /api/domains/:tenantId/verify
 * Verify domain ownership (placeholder for DNS verification)
 * 
 * @example
 * POST /api/domains/123/verify
 * Response: { success: true, data: { id, custom_domain, domain_verified: true, message: "..." } }
 */
router.post('/:tenantId/verify', domainController.verifyDomain);

// Error handling middleware for domain routes
router.use((error, req, res, next) => {
  logger.error({
    event: 'domain_route_error',
    method: req.method,
    path: req.path,
    error: error.message,
    stack: error.stack
  }, 'Domain route error occurred');

  res.status(500).json({
    success: false,
    error: 'Internal server error in domain routes'
  });
});

export default router;


/*──────────────── backend\routes\errorTracking.js ────────────────*/

/**
 * Error Tracking API Routes
 * 
 * Handles frontend error reports and provides error statistics.
 */

import express from 'express';
import { unifiedErrorService } from '../services/unifiedErrorService.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { createModuleLogger } from '../config/logger.js';
import { getPool } from '../database/pool.js';

const router = express.Router();
const logger = createModuleLogger('errorTrackingRoutes');

/**
 * POST /api/errors/track
 * Receive frontend error reports
 */
router.post('/track', asyncHandler(async (req, res) => {
  try {
    const { errors, sessionId, timestamp } = req.body;

    if (!errors || !Array.isArray(errors)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_REQUEST',
          message: 'Errors array is required'
        }
      });
    }

    logger.info('Received frontend error report', {
      sessionId,
      errorCount: errors.length,
      timestamp
    });

    // Process each error
    const processedErrors = [];
    for (const frontendError of errors) {
      try {
        // Convert frontend error to unified error
        const unifiedError = new unifiedErrorService.UnifiedError(frontendError.message, {
          code: frontendError.code,
          statusCode: 500, // Frontend errors are treated as 500
          severity: frontendError.severity?.toLowerCase(),
          category: frontendError.category?.toLowerCase(),
          tenantId: frontendError.tenantId,
          userId: frontendError.userId,
          correlationId: frontendError.correlationId,
          metadata: {
            ...frontendError.metadata,
            frontendError: true,
            sessionId: frontendError.sessionId,
            userAgent: frontendError.userAgent,
            url: frontendError.url,
            stack: frontendError.stack,
            componentStack: frontendError.componentStack
          }
        });

        // Handle the error through unified service
        await unifiedErrorService.handleError(unifiedError, {
          frontendError: true,
          sessionId: frontendError.sessionId
        });

        processedErrors.push({
          id: frontendError.sessionId,
          code: frontendError.code,
          processed: true
        });

      } catch (processError) {
        logger.error('Failed to process frontend error', {
          frontendError: frontendError.code,
          error: processError.message
        });

        processedErrors.push({
          id: frontendError.sessionId,
          code: frontendError.code,
          processed: false,
          error: processError.message
        });
      }
    }

    res.json({
      success: true,
      data: {
        processed: processedErrors.length,
        errors: processedErrors
      },
      meta: {
        timestamp: new Date().toISOString(),
        sessionId
      }
    });

  } catch (error) {
    logger.error('Failed to process error tracking request', {
      error: error.message,
      body: req.body
    });

    res.status(500).json({
      success: false,
      error: {
        code: 'ERROR_TRACKING_FAILED',
        message: 'Failed to process error tracking request'
      }
    });
  }
}));

/**
 * GET /api/errors/stats
 * Get error statistics
 */
router.get('/stats', asyncHandler(async (req, res) => {
  try {
    const { tenantId, dateRange = '24h' } = req.query;

    // Calculate date filter
    const now = new Date();
    let startDate;
    
    switch (dateRange) {
      case '1h':
        startDate = new Date(now.getTime() - 60 * 60 * 1000);
        break;
      case '24h':
        startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        break;
      case '7d':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case '30d':
        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      default:
        startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    }

    const pool = await getPool();
    
    // Build query with optional tenant filter
    let query = `
      SELECT 
        error_category,
        severity,
        COUNT(*) as count,
        COUNT(DISTINCT tenant_id) as tenant_count,
        COUNT(DISTINCT user_id) as user_count
      FROM system.error_logs
      WHERE created_at >= $1
    `;
    
    const queryParams = [startDate];
    
    if (tenantId) {
      query += ` AND tenant_id = $2`;
      queryParams.push(tenantId);
    }
    
    query += ` GROUP BY error_category, severity ORDER BY count DESC`;

    const result = await pool.query(query, queryParams);

    // Get recent errors
    let recentQuery = `
      SELECT 
        error_code,
        error_message,
        error_category,
        severity,
        tenant_id,
        user_id,
        created_at
      FROM system.error_logs
      WHERE created_at >= $1
    `;
    
    const recentParams = [startDate];
    
    if (tenantId) {
      recentQuery += ` AND tenant_id = $2`;
      recentParams.push(tenantId);
    }
    
    recentQuery += ` ORDER BY created_at DESC LIMIT 20`;

    const recentResult = await pool.query(recentQuery, recentParams);

    // Get error trends (hourly for last 24h)
    const trendsQuery = `
      SELECT 
        DATE_TRUNC('hour', created_at) as hour,
        error_category,
        COUNT(*) as count
      FROM system.error_logs
      WHERE created_at >= $1
    `;
    
    const trendsParams = [startDate];
    
    if (tenantId) {
      trendsQuery += ` AND tenant_id = $2`;
      trendsParams.push(tenantId);
    }
    
    trendsQuery += ` GROUP BY DATE_TRUNC('hour', created_at), error_category ORDER BY hour DESC`;

    const trendsResult = await pool.query(trendsQuery, trendsParams);

    // Get service-level stats
    const serviceStats = unifiedErrorService.getErrorStats();

    res.json({
      success: true,
      data: {
        summary: {
          totalErrors: result.rows.reduce((sum, row) => sum + parseInt(row.count), 0),
          uniqueTenants: new Set(result.rows.map(row => row.tenant_count)).size,
          uniqueUsers: new Set(result.rows.map(row => row.user_count)).size,
          dateRange,
          startDate: startDate.toISOString(),
          endDate: now.toISOString()
        },
        byCategory: result.rows.reduce((acc, row) => {
          if (!acc[row.error_category]) {
            acc[row.error_category] = {};
          }
          acc[row.error_category][row.severity] = parseInt(row.count);
          return acc;
        }, {}),
        recentErrors: recentResult.rows.map(row => ({
          code: row.error_code,
          message: row.error_message,
          category: row.error_category,
          severity: row.severity,
          tenantId: row.tenant_id,
          userId: row.user_id,
          timestamp: row.created_at
        })),
        trends: trendsResult.rows.map(row => ({
          hour: row.hour,
          category: row.error_category,
          count: parseInt(row.count)
        })),
        serviceStats
      },
      meta: {
        timestamp: new Date().toISOString(),
        tenantId: tenantId || null
      }
    });

  } catch (error) {
    logger.error('Failed to get error statistics', {
      error: error.message,
      query: req.query
    });

    res.status(500).json({
      success: false,
      error: {
        code: 'STATS_ERROR',
        message: 'Failed to get error statistics'
      }
    });
  }
}));

/**
 * GET /api/errors/health
 * Get error health status
 */
router.get('/health', asyncHandler(async (req, res) => {
  try {
    const stats = unifiedErrorService.getErrorStats();
    
    // Determine health status based on error rates
    const criticalErrors = stats.recentErrors.filter(e => e.severity === 'critical').length;
    const highErrors = stats.recentErrors.filter(e => e.severity === 'high').length;
    
    let healthStatus = 'healthy';
    if (criticalErrors > 0) {
      healthStatus = 'critical';
    } else if (highErrors > 5) {
      healthStatus = 'warning';
    } else if (stats.totalErrors > 50) {
      healthStatus = 'degraded';
    }

    res.json({
      success: true,
      data: {
        status: healthStatus,
        criticalErrors,
        highErrors,
        totalErrors: stats.totalErrors,
        errorRates: stats.errorRate,
        lastChecked: new Date().toISOString()
      }
    });

  } catch (error) {
    logger.error('Failed to get error health status', {
      error: error.message
    });

    res.status(500).json({
      success: false,
      error: {
        code: 'HEALTH_CHECK_ERROR',
        message: 'Failed to get error health status'
      }
    });
  }
}));

export default router;


/*──────────────── backend\routes\gallery.js ────────────────*/

/**
 * @fileoverview API routes for gallery
 * @version 1.0.0
 * @author That Smart Site
 */

import express from 'express';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createModuleLogger } from '../config/logger.js';
const router = express.Router();
const logger = createModuleLogger('routeName');


// ESM __dirname equivalent
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Get list of gallery images
router.get('/images', (req, res) => {
  try {
    // Read from the frontend public folder
    const galleryPath = path.join(__dirname, '../../frontend/public/images/gallery');
    
    // Check if gallery directory exists
    if (!fs.existsSync(galleryPath)) {
      return res.json([]);
    }
    
    // Read directory contents
    const files = fs.readdirSync(galleryPath);
    
    // Filter for image files
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.PNG', '.JPG', '.JPEG', '.gif', '.GIF', '.webp', '.WEBP'];
    const imageFiles = files.filter(file => {
      const ext = path.extname(file);
      return imageExtensions.includes(ext);
    });
    
    // Convert to URLs (frontend will serve these from public folder)
    const imageUrls = imageFiles.map(file => `/images/gallery/${file}`);
    
    res.json(imageUrls);
  } catch (error) {
    logger.error('Error reading gallery directory:', error);
    res.status(500).json({ error: 'Failed to read gallery images' });
  }
});

export default router;


/*──────────────── backend\routes\googleAnalytics.js ────────────────*/

import express from 'express';
import { asyncHandler } from '../middleware/errorHandler.js';
import { logger } from '../config/logger.js';
import { getPool } from '../database/pool.js';
import { env } from '../config/env.js';
import * as analyticsService from '../services/googleAnalytics.js';
import { sendSuccess, sendError, sendValidationError } from '../utils/responseFormatter.js';

const router = express.Router();

/**
 * Google Analytics OAuth Routes
 * Handles OAuth flow for GA4 integration
 */

// Test route to verify the router is working
router.get('/test', (req, res) => {
  sendSuccess(res, 'Google Analytics routes are working!', { timestamp: new Date().toISOString() });
});

/**
 * GET /api/google/analytics/auth
 * Initiates OAuth flow by redirecting to Google's consent screen
 */
router.get('/auth', asyncHandler(async (req, res) => {
  logger.info('Google Analytics auth route called');
  try {
    // Get tenant_id from session or query params
    const tenantId = req.query.tenant_id || req.user?.tenant_id;
    logger.info('Tenant ID:', tenantId);
    
    if (!tenantId) {
      return sendValidationError(res, 'Tenant ID is required', 'Missing tenant_id');
    }

    // Verify tenant exists and is approved
    const tenantResult = await pool.query(
      'SELECT id, slug FROM tenants.business WHERE id = $1 AND application_status = $2',
      [tenantId, 'approved']
    );

    if (tenantResult.rows.length === 0) {
      return res.status(404).json({
        status: 'error',
        error: 'Tenant not found',
        message: 'Tenant not found or not approved'
      });
    }

    // Build OAuth URL
    logger.info('Environment variables:', {
      GOOGLE_CLIENT_ID: env.GOOGLE_CLIENT_ID ? 'SET' : 'MISSING',
      GOOGLE_REDIRECT_URI: env.GOOGLE_REDIRECT_URI || 'MISSING'
    });
    
    const authUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth');
    authUrl.searchParams.append('client_id', env.GOOGLE_CLIENT_ID);
    authUrl.searchParams.append('redirect_uri', `${env.GOOGLE_REDIRECT_URI.replace('/oauth/callback', '/analytics/callback')}`);
    authUrl.searchParams.append('response_type', 'code');
    authUrl.searchParams.append('scope', [
      'https://www.googleapis.com/auth/analytics.readonly',
      'https://www.googleapis.com/auth/business.manage',
      'https://www.googleapis.com/auth/plus.business.manage'
    ].join(' '));
    authUrl.searchParams.append('access_type', 'offline');
    authUrl.searchParams.append('prompt', 'consent');
    authUrl.searchParams.append('state', tenantId); // Pass tenant_id in state for callback

    logger.info('Redirecting tenant to Google Analytics OAuth', {
      tenantId,
      authUrl: authUrl.toString()
    });

    res.redirect(authUrl.toString());

  } catch (error) {
    logger.error('Error initiating Google Analytics OAuth:', error);
    res.status(500).json({
      status: 'error',
      error: 'Failed to initiate OAuth flow',
      message: error.message
    });
  }
}));

/**
 * GET /api/google/analytics/callback
 * Handles OAuth callback from Google and exchanges code for tokens
 */
router.get('/callback', asyncHandler(async (req, res) => {
  try {
    const { code, state, error } = req.query;

    // Handle OAuth errors
    if (error) {
      logger.error('Google Analytics OAuth error:', { error, state });
      return res.status(400).json({
        status: 'error',
        error: 'OAuth authorization failed',
        message: `Google OAuth error: ${error}`
      });
    }

    // Validate required parameters
    if (!code || !state) {
      return res.status(400).json({
        status: 'error',
        error: 'Missing required parameters',
        message: 'Authorization code and state are required'
      });
    }

    const tenantId = state;

    // Verify tenant exists
    const tenantResult = await pool.query(
      'SELECT id, slug, business_name FROM tenants.business WHERE id = $1 AND application_status = $2',
      [tenantId, 'approved']
    );

    if (tenantResult.rows.length === 0) {
      return sendError(res, 'Tenant not found or not approved', 'Tenant not found', 404);
    }

    const tenant = tenantResult.rows[0];

    // Exchange authorization code for tokens
    const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        client_id: env.GOOGLE_CLIENT_ID,
        client_secret: env.GOOGLE_CLIENT_SECRET,
        code: code,
        grant_type: 'authorization_code',
        redirect_uri: `${env.GOOGLE_REDIRECT_URI.replace('/oauth/callback', '/analytics/callback')}`,
      }),
    });

    if (!tokenResponse.ok) {
      const errorData = await tokenResponse.text();
      logger.error('Failed to exchange code for tokens:', {
        status: tokenResponse.status,
        error: errorData
      });
      throw new Error(`Token exchange failed: ${tokenResponse.status}`);
    }

    const tokenData = await tokenResponse.json();
    
    // Get user's GA properties to find the default one
    let propertyId = null; // Will be set to actual property ID if found
    
    try {
      const propertiesResponse = await fetch(
        'https://analyticsadmin.googleapis.com/v1beta/accounts',
        {
          headers: {
            'Authorization': `Bearer ${tokenData.access_token}`,
          },
        }
      );

      if (propertiesResponse.ok) {
        const propertiesData = await propertiesResponse.json();
        
        // For now, we'll store the first property found
        // In a real implementation, you might want to let users choose
        if (propertiesData.accounts && propertiesData.accounts.length > 0) {
          const account = propertiesData.accounts[0];
          propertyId = account.name; // This will be in format "accounts/123456789"
        }
      } else {
        logger.warn('Failed to fetch GA properties, using default property ID:', {
          status: propertiesResponse.status
        });
      }
    } catch (propertyError) {
      logger.warn('Error fetching GA properties, using default property ID:', propertyError);
    }

    // Calculate token expiration
    const expiresAt = new Date();
    expiresAt.setSeconds(expiresAt.getSeconds() + tokenData.expires_in);

    // Store tokens in database
    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // Delete existing tokens for this tenant
      await client.query(
        'DELETE FROM analytics.google_analytics_tokens WHERE tenant_id = $1',
        [tenantId]
      );

      // Insert new tokens with service information
      await client.query(
        `INSERT INTO analytics.google_analytics_tokens 
         (tenant_id, access_token, refresh_token, property_id, expires_at, service_type, scopes, created_at, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())`,
        [
          tenantId,
          tokenData.access_token,
          tokenData.refresh_token || null,
          propertyId,
          expiresAt,
          'unified_google_services', // Service type
          [
            'https://www.googleapis.com/auth/analytics.readonly',
            'https://www.googleapis.com/auth/business.manage',
            'https://www.googleapis.com/auth/plus.business.manage'
          ] // Granted scopes
        ]
      );

      await client.query('COMMIT');

      logger.info('Google Analytics tokens stored successfully', {
        tenantId: tenant.id,
        tenantSlug: tenant.slug,
        businessName: tenant.business_name,
        propertyId
      });

      // Redirect back to tenant dashboard with success message
      res.redirect(`${env.FRONTEND_URL}/${tenant.slug}/dashboard?ga_connected=true`);

    } catch (dbError) {
      await client.query('ROLLBACK');
      throw dbError;
    } finally {
      client.release();
    }

  } catch (error) {
    logger.error('Error in Google Analytics OAuth callback:', error);
    res.status(500).json({
      status: 'error',
      error: 'Failed to complete OAuth flow',
      message: error.message
    });
  }
}));

/**
 * GET /api/google/analytics/status
 * Check if tenant has connected Google Analytics
 */
router.get('/status', asyncHandler(async (req, res) => {
  try {
    const tenantId = req.query.tenant_id || req.user?.tenant_id;
    
    if (!tenantId) {
      return res.status(400).json({
        status: 'error',
        error: 'Tenant ID is required'
      });
    }

    const result = await pool.query(
      'SELECT id, property_id, expires_at, created_at FROM analytics.google_analytics_tokens WHERE tenant_id = $1',
      [tenantId]
    );

    const isConnected = result.rows.length > 0;
    const tokenData = result.rows[0] || null;

    sendSuccess(res, 'Analytics connection status retrieved successfully', {
      connected: isConnected,
      data: tokenData ? {
        propertyId: tokenData.property_id,
        expiresAt: tokenData.expires_at,
        connectedAt: tokenData.created_at
      } : null
    });

  } catch (error) {
    logger.error('Error checking Google Analytics status:', error);
    res.status(500).json({
      status: 'error',
      error: 'Failed to check connection status',
      message: error.message
    });
  }
}));

/**
 * GET /api/google/analytics/summary
 * Get analytics summary data for a tenant
 */
router.get('/summary', asyncHandler(async (req, res) => {
  try {
    const tenantId = req.query.tenant_id || req.user?.tenant_id;
    const days = parseInt(req.query.days) || 7;
    
    if (!tenantId) {
      return res.status(400).json({
        status: 'error',
        error: 'Tenant ID is required'
      });
    }

    const summary = await analyticsService.getAnalyticsSummary(tenantId, days);

    sendSuccess(res, 'Analytics summary retrieved successfully', summary);

  } catch (error) {
    logger.error('Error fetching analytics summary:', error);
    res.status(500).json({
      status: 'error',
      error: 'Failed to fetch analytics data',
      message: error.message
    });
  }
}));

/**
 * GET /api/google/analytics/realtime
 * Get real-time analytics data for a tenant
 */
router.get('/realtime', asyncHandler(async (req, res) => {
  try {
    const tenantId = req.query.tenant_id || req.user?.tenant_id;
    
    if (!tenantId) {
      return res.status(400).json({
        status: 'error',
        error: 'Tenant ID is required'
      });
    }

    const realtimeData = await analyticsService.getRealtimeData(tenantId);

    sendSuccess(res, 'Realtime analytics data retrieved successfully', realtimeData);

  } catch (error) {
    logger.error('Error fetching realtime data:', error);
    res.status(500).json({
      status: 'error',
      error: 'Failed to fetch realtime data',
      message: error.message
    });
  }
}));

export default router;


/*──────────────── backend\routes\googleAuth.js ────────────────*/

/**
 * Google OAuth Routes
 * Handles Google Business Profile OAuth flow for reviews integration
 */

import express from 'express';
import { google } from 'googleapis';
import { getPool } from '../database/pool.js';
import { env } from '../config/env.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { createModuleLogger } from '../config/logger.js';
import { sendSuccess, sendError, sendValidationError } from '../utils/responseFormatter.js';

const router = express.Router();
const logger = createModuleLogger('googleAuth');

// Initialize OAuth2 client
const oauth2Client = new google.auth.OAuth2(
  env.GOOGLE_CLIENT_ID,
  env.GOOGLE_CLIENT_SECRET,
  env.GOOGLE_REDIRECT_URI
);

// Scopes for Google Business Profile access
const SCOPES = [
  'https://www.googleapis.com/auth/business.manage',
  'https://www.googleapis.com/auth/plus.business.manage'
];

/**
 * GET /api/google/auth
 * Initiates Google OAuth flow by redirecting to Google's consent screen
 */
router.get('/auth', asyncHandler(async (req, res) => {
  try {
    // Generate the authorization URL
    const authUrl = oauth2Client.generateAuthUrl({
      access_type: 'offline', // Request refresh token
      scope: SCOPES,
      prompt: 'consent', // Force consent screen to get refresh token
      state: req.query.tenantId || 'default' // Optional: pass tenant ID for context
    });

    logger.info('Generated Google OAuth URL', { 
      authUrl: authUrl.substring(0, 100) + '...',
      tenantId: req.query.tenantId 
    });

    // Redirect to Google's consent screen
    res.redirect(authUrl);

  } catch (error) {
    logger.error('Error generating OAuth URL', { error: error.message });
    res.status(500).json({
      status: 'error',
      message: 'Failed to initiate Google OAuth flow',
      error: error.message
    });
  }
}));

/**
 * GET /api/google/oauth/callback
 * Handles the OAuth callback from Google and exchanges code for tokens
 */
router.get('/oauth/callback', asyncHandler(async (req, res) => {
  const { code, state, error } = req.query;

  try {
    // Check for OAuth errors
    if (error) {
      logger.error('Google OAuth error', { error, state });
      return res.status(400).json({
        status: 'error',
        message: 'Google OAuth authorization failed',
        error: error
      });
    }

    // Check for authorization code
    if (!code) {
      logger.error('Missing authorization code', { query: req.query });
      return res.status(400).json({
        status: 'error',
        message: 'Authorization code is required'
      });
    }

    logger.info('Received OAuth callback', { 
      code: code.substring(0, 10) + '...',
      state,
      hasCode: !!code
    });

    // Exchange authorization code for tokens
    const { tokens } = await oauth2Client.getToken(code);
    oauth2Client.setCredentials(tokens);

    logger.info('✅ Tokens received from Google', {
      hasAccessToken: !!tokens.access_token,
      hasRefreshToken: !!tokens.refresh_token,
      tokenType: tokens.token_type,
      expiresIn: tokens.expiry_date ? new Date(tokens.expiry_date) : 'No expiry'
    });

    // Store tokens in database
    const tenantId = state || 'default';
    await storeOAuthTokens(tenantId, tokens);

    // Return success response
    sendSuccess(res, '✅ Google Business Profile connected successfully!', {
      tenantId,
      hasAccessToken: !!tokens.access_token,
      hasRefreshToken: !!tokens.refresh_token,
      expiresAt: tokens.expiry_date ? new Date(tokens.expiry_date) : null
    });

  } catch (error) {
    logger.error('Error exchanging OAuth code for tokens', { 
      error: error.message,
      code: code ? code.substring(0, 10) + '...' : 'none'
    });

    res.status(500).json({
      status: 'error',
      message: 'Failed to exchange authorization code for tokens',
      error: error.message
    });
  }
}));

/**
 * Store OAuth tokens in database
 * @param {string} tenantId - Tenant identifier
 * @param {Object} tokens - OAuth tokens from Google
 */
async function storeOAuthTokens(tenantId, tokens) {
  if (!pool) {
    logger.warn('Database not available, storing tokens in memory only');
    return;
  }

  try {
    // Create oauth_tokens table if it doesn't exist
    await pool.query(`
      CREATE TABLE IF NOT EXISTS oauth_tokens (
        id SERIAL PRIMARY KEY,
        tenant_id VARCHAR(255) NOT NULL,
        access_token TEXT,
        refresh_token TEXT NOT NULL,
        token_type VARCHAR(50),
        expiry_date TIMESTAMP,
        scope TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(tenant_id)
      )
    `);

    // Insert or update tokens
    await pool.query(`
      INSERT INTO oauth_tokens (
        tenant_id, access_token, refresh_token, token_type, 
        expiry_date, scope, updated_at
      )
      VALUES ($1, $2, $3, $4, $5, $6, NOW())
      ON CONFLICT (tenant_id) 
      DO UPDATE SET
        access_token = EXCLUDED.access_token,
        refresh_token = EXCLUDED.refresh_token,
        token_type = EXCLUDED.token_type,
        expiry_date = EXCLUDED.expiry_date,
        scope = EXCLUDED.scope,
        updated_at = NOW()
    `, [
      tenantId,
      tokens.access_token,
      tokens.refresh_token,
      tokens.token_type,
      tokens.expiry_date ? new Date(tokens.expiry_date) : null,
      tokens.scope
    ]);

    logger.info('OAuth tokens stored successfully', { tenantId });

  } catch (error) {
    logger.error('Error storing OAuth tokens', { 
      error: error.message,
      tenantId 
    });
    throw error;
  }
}

/**
 * GET /api/google/tokens/:tenantId
 * Retrieve stored OAuth tokens for a tenant
 */
router.get('/tokens/:tenantId', asyncHandler(async (req, res) => {
  const { tenantId } = req.params;

  try {
    if (!pool) {
      return res.status(500).json({
        status: 'error',
        message: 'Database not available'
      });
    }

    const result = await pool.query(
      'SELECT access_token, refresh_token, token_type, expiry_date, scope, updated_at FROM oauth_tokens WHERE tenant_id = $1',
      [tenantId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'No OAuth tokens found for this tenant'
      });
    }

    const tokens = result.rows[0];
    sendSuccess(res, 'OAuth tokens retrieved successfully', {
      hasAccessToken: !!tokens.access_token,
      hasRefreshToken: !!tokens.refresh_token,
      tokenType: tokens.token_type,
      expiresAt: tokens.expiry_date,
      scope: tokens.scope,
      lastUpdated: tokens.updated_at
    });

  } catch (error) {
    logger.error('Error retrieving OAuth tokens', { 
      error: error.message,
      tenantId 
    });

    res.status(500).json({
      status: 'error',
      message: 'Failed to retrieve OAuth tokens',
      error: error.message
    });
  }
}));

export default router;


/*──────────────── backend\routes\googleReviews.js ────────────────*/

/**
 * Google Reviews API Routes
 * 
 * Fetches reviews from Google Business Profile with mock fallback
 * Supports OAuth integration and graceful degradation
 */

import express from 'express';
import { getGoogleReviews } from '../services/googleApi.js';
import { isDummyTenant } from '../utils/tenantUtils.js';
import logger from '../utils/logger.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { sendSuccess, sendError, sendValidationError } from '../utils/responseFormatter.js';

const router = express.Router();

/**
 * GET /api/google-reviews/:tenantSlug
 * Fetch Google Business Profile reviews for a tenant
 * Falls back to mock reviews if no OAuth or empty profile
 */
router.get('/:tenantSlug', async (req, res) => {
  try {
    const { tenantSlug } = req.params;
    
    // Validate tenant slug
    if (!tenantSlug || tenantSlug.trim() === '') {
      return res.status(400).json({
        status: 'error',
        error: 'Tenant slug is required',
        message: 'Please provide a valid tenant slug'
      });
    }

    logger.info('Fetching Google reviews', { tenantSlug });

    // Attempt to fetch real Google reviews
    const reviews = await getGoogleReviews(tenantSlug);

    // Check if this is the dummy tenant that should show mock reviews
    const isDummy = isDummyTenant(tenantSlug);

    // If no reviews and this is the dummy tenant, use mock data
    if ((!reviews || reviews.length === 0) && isDummy) {
      logger.info('Using mock reviews for dummy tenant', { tenantSlug });
      
      // Import mock data dynamically to avoid startup issues
      const { default: mockReviews } = await import('../mocks/mockReviews.json', {
        assert: { type: 'json' }
      });
      
      return sendSuccess(res, 'Mock reviews returned for dummy tenant', {
        reviews: mockReviews,
        source: 'mock',
        tenantSlug
      });
    }

    // For real tenants with no reviews, return empty array
    if (!reviews || reviews.length === 0) {
      logger.info('No reviews found for tenant', { tenantSlug });
      return sendSuccess(res, 'No reviews found', {
        reviews: [],
        source: 'google',
        tenantSlug
      });
    }

    // Return real Google reviews
    sendSuccess(res, 'Google reviews fetched successfully', {
      reviews: reviews,
      source: 'google',
      tenantSlug
    });

  } catch (error) {
    logger.error('Error fetching Google reviews', { 
      error: error.message, 
      tenantSlug: req.params.tenantSlug 
    });

    try {
      // Only fallback to mock data for dummy tenants
      const isDummy = isDummyTenant(req.params.tenantSlug);
      
      if (isDummy) {
        const { default: mockReviews } = await import('../mocks/mockReviews.json', {
          assert: { type: 'json' }
        });
        
        sendSuccess(res, 'Mock reviews returned (error fetching Google reviews)', {
          reviews: mockReviews,
          source: 'mock',
          tenantSlug: req.params.tenantSlug
        });
      } else {
        // For real tenants, return empty array on error
        sendSuccess(res, 'No reviews available (error fetching Google reviews)', {
          reviews: [],
          source: 'google',
          tenantSlug: req.params.tenantSlug
        });
      }
    } catch (mockError) {
      logger.error('Failed to load mock reviews', { error: mockError.message });
      res.status(500).json({
        status: 'error',
        error: 'Failed to fetch reviews',
        message: 'Unable to fetch reviews from Google'
      });
    }
  }
});

/**
 * GET /api/google-reviews/:tenantSlug/health
 * Health check for Google Reviews service
 */
router.get('/:tenantSlug/health', async (req, res) => {
  try {
    const { tenantSlug } = req.params;
    
    sendSuccess(res, 'Google Reviews service is healthy', {
      service: 'google-reviews',
      tenantSlug,
      status: 'healthy',
      timestamp: new Date().toISOString(),
      features: {
        googleOAuth: process.env.GOOGLE_OAUTH_CLIENT_ID ? 'configured' : 'not_configured',
        mockFallback: 'enabled'
      }
    });
  } catch (error) {
    res.status(500).json({
      status: 'error',
      service: 'google-reviews',
      error: error.message,
      status: 'unhealthy'
    });
  }
});

export default router;


/*──────────────── backend\routes\health.js ────────────────*/

/**
 * System Health Check Routes
 * Provides endpoints for system health monitoring (liveness, readiness, etc.)
 */

import express from 'express';
import { asyncHandler } from '../middleware/errorHandler.js';
const router = express.Router();
import { getPool } from '../database/pool.js';
import logger from '../utils/logger.js';
import { sendSuccess, sendError } from '../utils/responseFormatter.js';

// Track shutdown status for graceful shutdown
let isShuttingDown = false;

/**
 * GET /api/health
 * Comprehensive health check with database status
 */
router.get('/', async (req, res) => {
  try {
    const startTime = Date.now();
    
    // Check database connectivity
    let dbStatus = { connected: false, status: 'Disconnected', queryTime: null, dbTime: null };
    
    try {
      const pool = await getPool();
      const dbStartTime = Date.now();
      const result = await pool.query('SELECT NOW() as current_time');
      const dbEndTime = Date.now();
      
      dbStatus = {
        connected: true,
        status: 'Connected',
        queryTime: `${dbEndTime - dbStartTime}ms`,
        dbTime: result.rows[0].current_time
      };
    } catch (dbError) {
      dbStatus = {
        connected: false,
        status: 'Error',
        queryTime: null,
        dbTime: null,
        error: dbError.message
      };
    }

    const responseTime = Date.now() - startTime;

    sendSuccess(res, 'System health check successful', {
      timestamp: new Date().toISOString(),
      database: dbStatus,
      uptime: process.uptime(),
      memory: {
        rss: process.memoryUsage().rss,
        heapTotal: process.memoryUsage().heapTotal,
        heapUsed: process.memoryUsage().heapUsed,
        external: process.memoryUsage().external
      },
      responseTime: `${responseTime}ms`,
      pid: process.pid,
      nodeVersion: process.version,
      shutdown: isShuttingDown
    });

  } catch (error) {
    logger.error('Health check error:', error);
    sendError(res, 'Health check failed', error.message, 500);
  }
});

/**
 * GET /api/health/live
 * Liveness check - always returns 200 if process is responsive
 */
router.get('/live', (req, res) => {
  sendSuccess(res, 'System is alive', {
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    pid: process.pid,
    memory: {
      rss: process.memoryUsage().rss,
      heapUsed: process.memoryUsage().heapUsed
    }
  });
});

/**
 * GET /api/health/ready
 * Readiness check - returns 200 if ready to receive traffic, 503 if not
 */
router.get('/ready', async (req, res) => {
  try {
    // Check if we're shutting down
    if (isShuttingDown) {
      return res.status(503).json({
        status: 'not_ready',
        reason: 'shutting_down',
        timestamp: new Date().toISOString()
      });
    }

    try {
      // Quick database ping
      const pool = await getPool();
      const startTime = Date.now();
      await pool.query('SELECT 1');
      const responseTime = Date.now() - startTime;

      if (responseTime > 5000) { // 5 second timeout
        return res.status(503).json({
          status: 'not_ready',
          reason: 'database_slow',
          responseTime: `${responseTime}ms`,
          timestamp: new Date().toISOString()
        });
      }

      sendSuccess(res, 'System is ready', {
        timestamp: new Date().toISOString(),
        database: {
          connected: true,
          responseTime: `${responseTime}ms`
        },
        uptime: process.uptime()
      });

    } catch (dbError) {
      return sendError(res, 'Database connection failed', dbError.message, 503);
    }

  } catch (error) {
    logger.error('Readiness check error:', error);
    sendError(res, 'Internal error during readiness check', error.message, 503);
  }
});

/**
 * GET /api/health/db-status
 * Database connection status only
 */
router.get('/db-status', async (req, res) => {
  try {
    const pool = await getPool();
    const startTime = Date.now();
    const result = await pool.query('SELECT NOW() as current_time, version() as db_version');
    const responseTime = Date.now() - startTime;

    sendSuccess(res, 'Database connection successful', {
      responseTime: `${responseTime}ms`,
      currentTime: result.rows[0].current_time,
      dbVersion: result.rows[0].db_version
    });

  } catch (error) {
    sendError(res, 'Database connection failed', error.message, 503);
  }
});

/**
 * GET /api/health/test-db
 * Simple database connection test
 */
router.get('/test-db', async (req, res) => {
  try {
    const pool = await getPool();
    const startTime = Date.now();
    await pool.query('SELECT 1 as test');
    const responseTime = Date.now() - startTime;

    sendSuccess(res, 'Database connection successful', {
      responseTime: `${responseTime}ms`
    });

  } catch (error) {
    sendError(res, 'Database connection failed', error.message, 500);
  }
});

/**
 * Update shutdown status for graceful shutdown
 */
function updateShutdownStatus(shuttingDown) {
  isShuttingDown = shuttingDown;
}

// Export the router and the updateShutdownStatus function
export default router;
export { updateShutdownStatus };

/*──────────────── backend\routes\healthMonitoring.js ────────────────*/

/**
 * Health Monitoring API Routes
 * Provides endpoints for website health analysis and monitoring
 */

import express from 'express';
const router = express.Router();
import { getPool } from '../database/pool.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import logger from '../utils/logger.js';
import healthMonitor from '../services/healthMonitor.js';
import { sendSuccess, sendError } from '../utils/responseFormatter.js';

/**
 * GET /api/health/:tenantSlug
 * Get current health status for a tenant
 */
router.get('/:tenantSlug', asyncHandler(async (req, res) => {
  const { tenantSlug } = req.params;

  try {
    logger.info(`Fetching health status for tenant: ${tenantSlug}`);

    if (!pool) {
      logger.error('Database pool not available');
      return res.status(500).json({ error: 'Database connection not available' });
    }


    // Get latest health status for all check types
    const result = await pool.query(`
      SELECT 
        tenant_slug,
        check_type,
        url,
        overall_score,
        performance_score,
        accessibility_score,
        best_practices_score,
        seo_score,
        strategy,
        lcp_value,
        lcp_score,
        fid_value,
        fid_score,
        cls_value,
        cls_score,
        fcp_value,
        fcp_score,
        ttfb_value,
        ttfb_score,
        speed_index_value,
        speed_index_score,
        interactive_value,
        interactive_score,
        total_blocking_time_value,
        total_blocking_time_score,
        status,
        error_message,
        checked_at,
        raw_data,
        opportunities,
        diagnostics,
        crux_data
      FROM system.health_monitoring
      WHERE tenant_slug = $1
      ORDER BY checked_at DESC, check_type, strategy
    `, [tenantSlug]);

    if (result.rows.length === 0) {
      return sendSuccess(res, 'No health monitoring data available. Run a health scan to get started.', {
        tenantSlug,
        hasData: false
      });
    }

    // Organize data by check type and strategy
    const healthData = {
      tenantSlug,
      hasData: true,
      lastUpdated: result.rows[0].checked_at,
      performance: {},
      overall: null
    };

    result.rows.forEach(row => {
      if (row.check_type === 'performance') {
        healthData.performance[row.strategy] = {
          overallScore: row.overall_score,
          performanceScore: row.performance_score,
          accessibilityScore: row.accessibility_score,
          bestPracticesScore: row.best_practices_score,
          seoScore: row.seo_score,
          coreWebVitals: {
            lcp: { value: row.lcp_value, score: row.lcp_score },
            fid: { value: row.fid_value, score: row.fid_score },
            cls: { value: row.cls_value, score: row.cls_score },
            fcp: { value: row.fcp_value, score: row.fcp_score },
            ttfb: { value: row.ttfb_value, score: row.ttfb_score }
          },
          metrics: {
            speedIndex: { value: row.speed_index_value, score: row.speed_index_score },
            interactive: { value: row.interactive_value, score: row.interactive_score },
            totalBlockingTime: { value: row.total_blocking_time_value, score: row.total_blocking_time_score }
          },
          status: row.status,
          checkedAt: row.checked_at,
          opportunities: row.opportunities || [],
          diagnostics: row.diagnostics || [],
          cruxData: row.crux_data || null
        };
      } else if (row.check_type === 'overall') {
        healthData.overall = {
          score: row.overall_score,
          status: row.status,
          checkedAt: row.checked_at,
          errorMessage: row.error_message
        };
      }
    });

    sendSuccess(res, 'Health status retrieved successfully', healthData);

  } catch (error) {
    logger.error('Error fetching health status:', error);
    sendError(res, 'Failed to fetch health status', error.message, 500);
  }
}));

/**
 * POST /api/health/:tenantSlug/scan
 * Trigger a comprehensive health scan for a tenant
 */
router.post('/:tenantSlug/scan', asyncHandler(async (req, res) => {
  const { tenantSlug } = req.params;

  try {
    logger.info(`Starting health scan for tenant: ${tenantSlug}`);

    if (!pool) {
      logger.error('Database pool not available');
      return res.status(500).json({ error: 'Database connection not available' });
    }

    // Get tenant's website URL from database
    logger.info(`Querying database for tenant: ${tenantSlug}`);
    const tenantResult = await pool.query(`
      SELECT website, gbp_url
      FROM tenants.business
      WHERE slug = $1 AND application_status = 'approved'
    `, [tenantSlug]);
    logger.info(`Database query completed`);

    if (tenantResult.rows.length === 0) {
      return res.status(404).json({ error: 'Tenant not found' });
    }

    // Use actual tenant website URL
    const tenant = tenantResult.rows[0];
    const websiteUrl = tenant.website || 'https://google.com';
    logger.info(`Using tenant URL: ${websiteUrl}`);

    if (!websiteUrl) {
      return res.status(400).json({ error: 'No website URL found for this tenant' });
    }

    logger.info(`Scanning website: ${websiteUrl}`);

    // Run comprehensive health analysis with timeout
    logger.info(`Starting health analysis...`);
    const healthAnalysisPromise = healthMonitor.getWebsiteHealth(websiteUrl);
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Health analysis timeout after 5 minutes')), 300000) // 5 minutes
    );
    
    const healthAnalysis = await Promise.race([healthAnalysisPromise, timeoutPromise]);
    logger.info(`Health analysis completed`);

    if (!healthAnalysis.success) {
      logger.error('Health analysis failed:', healthAnalysis.error);
      return res.status(500).json({ 
        error: 'Health analysis failed',
        details: healthAnalysis.error
      });
    }

    const healthData = healthAnalysis.data;

    // Save health data to database
    logger.info(`Saving health data to database...`);
    
    try {
      // First, delete existing records for this tenant to avoid duplicates
      // Use transaction to ensure atomic database operations
      await pool.query('BEGIN');
      logger.info(`Starting database transaction for tenant: ${tenantSlug}`);

      try {
        await pool.query(
          'DELETE FROM system.health_monitoring WHERE tenant_slug = $1 AND check_type = $2',
          [tenantSlug, 'performance']
        );
        logger.info(`Cleared existing health data for tenant: ${tenantSlug}`);

        // Save mobile performance data
        if (healthData.mobile) {
        await pool.query(`
          INSERT INTO system.health_monitoring (
            tenant_slug, check_type, url, strategy,
            overall_score, performance_score, accessibility_score, best_practices_score, seo_score,
            lcp_value, lcp_score, fid_value, fid_score, cls_value, cls_score, fcp_value, fcp_score,
            raw_data, opportunities, diagnostics, status, checked_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22)
        `, [
          tenantSlug, 'performance', websiteUrl, 'mobile',
          healthData.overallScore,
          healthData.mobile.performance || 0,
          healthData.mobile.accessibility || 0,
          healthData.mobile.bestPractices || 0,
          healthData.mobile.seo || 0,
          healthData.mobile.coreWebVitals?.lcp?.value || 0,
          healthData.mobile.coreWebVitals?.lcp?.score || 0,
          healthData.mobile.coreWebVitals?.fid?.value || 0,
          healthData.mobile.coreWebVitals?.fid?.score || 0,
          healthData.mobile.coreWebVitals?.cls?.value || 0,
          healthData.mobile.coreWebVitals?.cls?.score || 0,
          healthData.mobile.coreWebVitals?.fcp?.value || 0,
          healthData.mobile.coreWebVitals?.fcp?.score || 0,
          JSON.stringify(healthData.mobile),
          JSON.stringify(healthData.mobile.opportunities || []),
          JSON.stringify(healthData.mobile.diagnostics || []),
          healthData.summary.status,
          new Date()
        ]);
        logger.info(`Mobile performance data saved for tenant: ${tenantSlug}`);
      }

      // Save desktop performance data
      if (healthData.desktop) {
        await pool.query(`
          INSERT INTO system.health_monitoring (
            tenant_slug, check_type, url, strategy,
            overall_score, performance_score, accessibility_score, best_practices_score, seo_score,
            lcp_value, lcp_score, fid_value, fid_score, cls_value, cls_score, fcp_value, fcp_score,
            raw_data, opportunities, diagnostics, status, checked_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22)
        `, [
          tenantSlug, 'performance', websiteUrl, 'desktop',
          healthData.overallScore,
          healthData.desktop.performance || 0,
          healthData.desktop.accessibility || 0,
          healthData.desktop.bestPractices || 0,
          healthData.desktop.seo || 0,
          healthData.desktop.coreWebVitals?.lcp?.value || 0,
          healthData.desktop.coreWebVitals?.lcp?.score || 0,
          healthData.desktop.coreWebVitals?.fid?.value || 0,
          healthData.desktop.coreWebVitals?.fid?.score || 0,
          healthData.desktop.coreWebVitals?.cls?.value || 0,
          healthData.desktop.coreWebVitals?.cls?.score || 0,
          healthData.desktop.coreWebVitals?.fcp?.value || 0,
          healthData.desktop.coreWebVitals?.fcp?.score || 0,
          JSON.stringify(healthData.desktop),
          JSON.stringify(healthData.desktop.opportunities || []),
          JSON.stringify(healthData.desktop.diagnostics || []),
          healthData.summary.status,
          new Date()
        ]);
        logger.info(`Desktop performance data saved for tenant: ${tenantSlug}`);
        }

        // Commit the transaction
        await pool.query('COMMIT');
        logger.info(`Database transaction committed successfully for tenant: ${tenantSlug}`);

      } catch (dbError) {
        // Rollback the transaction on error
        await pool.query('ROLLBACK');
        logger.error(`Database transaction rolled back for tenant: ${tenantSlug}`, dbError);
        throw dbError;
      }

      logger.info(`Health data saved successfully to database`);
    } catch (dbError) {
      logger.error('Error saving health data to database:', dbError);
      // Continue with response even if database save fails
    }

    logger.info(`Health scan completed for tenant: ${tenantSlug}`);

    sendSuccess(res, 'Health scan completed successfully', {
      tenantSlug,
      url: websiteUrl,
      overallScore: healthData.overallScore,
      summary: healthData.summary,
      timestamp: healthData.timestamp
    });

  } catch (error) {
    logger.error('Error during health scan:', error);
    sendError(res, 'Health scan failed', error.message, 500);
  }
}));

/**
 * GET /api/health/:tenantSlug/history
 * Get health monitoring history for a tenant
 */
router.get('/:tenantSlug/history', asyncHandler(async (req, res) => {
  const { tenantSlug } = req.params;
  const { days = 30, limit = 100 } = req.query;

  try {
    logger.info(`Fetching health history for tenant: ${tenantSlug}`);

    if (!pool) {
      logger.error('Database pool not available');
      return res.status(500).json({ error: 'Database connection not available' });
    }

    const result = await pool.query(`
      SELECT 
        check_type,
        strategy,
        overall_score,
        performance_score,
        accessibility_score,
        best_practices_score,
        seo_score,
        status,
        checked_at
      FROM system.health_monitoring
      WHERE tenant_slug = $1
        AND checked_at >= CURRENT_TIMESTAMP - INTERVAL '${parseInt(days)} days'
      ORDER BY checked_at DESC
      LIMIT $2
    `, [tenantSlug, parseInt(limit)]);

    sendSuccess(res, 'Health monitoring history retrieved', {
      tenantSlug,
      history: result.rows,
      period: `${days} days`,
      totalRecords: result.rows.length
    });

  } catch (error) {
    logger.error('Error fetching health history:', error);
    sendError(res, 'Failed to fetch health history', error.message, 500);
  }
}));

/**
 * Helper function to save health data to database
 * TODO: Re-enable when health monitoring is fully implemented
 */
async function _saveHealthData(dbPool, tenantSlug, url, checkType, strategy, data, overallScore) {
  const query = `
    INSERT INTO system.health_monitoring (
      tenant_slug, check_type, url, strategy,
      overall_score, performance_score, accessibility_score, best_practices_score, seo_score,
      lcp_value, lcp_score, fid_value, fid_score, cls_value, cls_score,
      fcp_value, fcp_score, ttfb_value, ttfb_score,
      speed_index_value, speed_index_score, interactive_value, interactive_score,
      total_blocking_time_value, total_blocking_time_score,
      raw_data, opportunities, diagnostics, crux_data,
      status
    ) VALUES (
      $1, $2, $3, $4,
      $5, $6, $7, $8, $9,
      $10, $11, $12, $13, $14, $15,
      $16, $17, $18, $19,
      $20, $21, $22, $23,
      $24, $25,
      $26, $27, $28, $29,
      $30
    )
  `;

  const values = [
    tenantSlug, checkType, url, strategy,
    overallScore, data.performance, data.accessibility, data.bestPractices, data.seo,
    data.coreWebVitals.lcp.value, data.coreWebVitals.lcp.score,
    data.coreWebVitals.fid.value, data.coreWebVitals.fid.score,
    data.coreWebVitals.cls.value, data.coreWebVitals.cls.score,
    data.coreWebVitals.fcp.value, data.coreWebVitals.fcp.score,
    data.coreWebVitals.ttfb.value, data.coreWebVitals.ttfb.score,
    data.metrics.speedIndex.value, data.metrics.speedIndex.score,
    data.metrics.interactive.value, data.metrics.interactive.score,
    data.metrics.totalBlockingTime.value, data.metrics.totalBlockingTime.score,
    JSON.stringify(data), JSON.stringify(data.opportunities), JSON.stringify(data.diagnostics),
    JSON.stringify(data.cruxData),
    determineStatus(overallScore)
  ];

  await pool.query(query, values);
}

/**
 * Helper function to save CrUX data
 * TODO: Re-enable when CrUX monitoring is fully implemented
 */
async function _saveCrUXData(dbPool, tenantSlug, url, _cruxData) {
  const query = `
    INSERT INTO system.health_monitoring (
      tenant_slug, check_type, url, crux_data, status, checked_at
    ) VALUES ($1, 'crux', $2, $3, 'healthy', CURRENT_TIMESTAMP)
  `;

  await dbPool.query(query, [tenantSlug, url, JSON.stringify(_cruxData)]);
}

/**
 * Helper function to save overall health summary
 * TODO: Re-enable when overall health tracking is fully implemented
 */
async function _saveOverallHealth(dbPool, tenantSlug, url, overallScore, summary) {
  const query = `
    INSERT INTO system.health_monitoring (
      tenant_slug, check_type, url, overall_score, raw_data, status, checked_at
    ) VALUES ($1, 'overall', $2, $3, $4, $5, CURRENT_TIMESTAMP)
  `;

  await pool.query(query, [
    tenantSlug, url, overallScore, 
    JSON.stringify(summary), 
    determineStatus(overallScore)
  ]);
}

/**
 * Helper function to determine health status based on score
 */
function determineStatus(score) {
  if (score >= 90) {return 'healthy';}
  if (score >= 70) {return 'warning';}
  if (score >= 50) {return 'critical';}
  return 'error';
}

/**
 * GET /api/health-monitoring/test-api
 * Test PageSpeed API connectivity
 */
router.get('/test-api', asyncHandler(async (req, res) => {
  try {
    logger.info('Testing PageSpeed API connectivity...');
    
    if (!healthMonitor.pageSpeedApiKey) {
      return sendError(res, 'PageSpeed API key not configured', null, 500);
    }

    // Test with a simple URL
    const testUrl = 'https://google.com';
    const result = await healthMonitor.fetchPageSpeedInsights(testUrl, 'mobile');
    
    sendSuccess(res, result.success ? 'PageSpeed API is working correctly' : 'PageSpeed API call failed', {
      apiKeyConfigured: true,
      testResult: result
    });

  } catch (error) {
    logger.error('PageSpeed API test error:', error);
    sendError(res, 'PageSpeed API test failed', error.message, 500);
  }
}));

/**
 * GET /api/health-monitoring/test-lighthouse
 * Test Lighthouse CLI connectivity
 */
router.get('/test-lighthouse', asyncHandler(async (req, res) => {
  try {
    logger.info('Testing Lighthouse CLI...');
    const testUrl = 'http://localhost:5175';
    const result = await healthMonitor.runLighthouseLocal(testUrl, 'mobile');
    
    res.json({
      status: 'success',
      testResult: result,
      message: result.success ? 'Lighthouse CLI is working correctly' : 'Lighthouse CLI call failed'
    });

  } catch (error) {
    logger.error('Lighthouse test error:', error);
    res.status(500).json({
      status: 'error',
      error: error.message
    });
  }
}));

export default router;

/*──────────────── backend\routes\locations.js ────────────────*/

/**
 * @fileoverview API routes for locations
 * @version 1.0.0
 * @author That Smart Site
 */

import express from 'express';
import { getPool } from '../database/pool.js';
import { withTenantBySlug } from '../middleware/withTenant.js';
import { validateBody } from '../middleware/zodValidation.js';
import { serviceAreaSchemas } from '../schemas/apiSchemas.js';
import { asyncHandler } from '../middleware/errorHandler.js';
const router = express.Router();

// Get service areas for a tenant
router.get('/service-areas/:slug', withTenantBySlug, asyncHandler((req, res) => {
  const serviceAreas = req.tenant.service_areas || [];
  res.json(serviceAreas);
}));

// Update service areas for a tenant
router.put('/service-areas/:slug', 
  withTenantBySlug, 
  validateBody(serviceAreaSchemas.update),
  asyncHandler(async (req, res) => {
    const { serviceAreas } = req.body;
    
    await pool.query(
      'UPDATE tenants.business SET service_areas = $1, updated_at = NOW() WHERE id = $2',
      [JSON.stringify(serviceAreas), req.tenant.id]
    );
    
    res.json({ success: true, serviceAreas });
  })
);

// Add a new service area
router.post('/service-areas/:slug', 
  withTenantBySlug, 
  validateBody(serviceAreaSchemas.add),
  asyncHandler(async (req, res) => {
    const { city, state, zip, minimum, multiplier } = req.body;
    
    const currentServiceAreas = req.tenant.service_areas || [];
    
    // Add new service area
    const newServiceArea = {
      id: Date.now().toString(), // Simple ID generation
      city,
      state,
      zip: zip || null,
      minimum: minimum || 0,
      multiplier: multiplier || 1
    };
    
    const updatedServiceAreas = [...currentServiceAreas, newServiceArea];
    
    // Update database
    await pool.query(
      'UPDATE tenants.business SET service_areas = $1, updated_at = NOW() WHERE id = $2',
      [JSON.stringify(updatedServiceAreas), req.tenant.id]
    );
    
    res.json({ success: true, serviceArea: newServiceArea });
  })
);

// Delete a service area
router.delete('/service-areas/:slug/:areaId', withTenantBySlug, asyncHandler(async (req, res) => {
  const { areaId } = req.params;
  
  const currentServiceAreas = req.tenant.service_areas || [];
  const updatedServiceAreas = currentServiceAreas.filter(area => area.id !== areaId);
  
  // Update database
  await pool.query(
    'UPDATE tenants.business SET service_areas = $1, updated_at = NOW() WHERE id = $2',
    [JSON.stringify(updatedServiceAreas), req.tenant.id]
  );
  
  res.json({ success: true });
}));

export default router;


/*──────────────── backend\routes\payments.js ────────────────*/

/**
 * @fileoverview API routes for payments
 * @version 1.0.0
 * @author That Smart Site
 */

import express from 'express'
import { getPool } from '../database/pool.js'
import bcrypt from 'bcryptjs'
import { sendWelcomeEmail } from '../services/emailService.js'
import { createModuleLogger } from '../config/logger.js'
import { sendSuccess, sendError, sendValidationError } from '../utils/responseFormatter.js'

const router = express.Router()
const logger = createModuleLogger('payments');


import { asyncHandler } from '../middleware/errorHandler.js';
router.post('/create-intent', async (req, res, next) => {
  try {
    // Debug
    logger.info('=== PAYMENT INTENT DEBUG ===')
    logger.info('Request body:', req.body)

    const { amount, customerEmail, businessName, planType, metadata } = req.body || {}
    if (!amount || !customerEmail || !businessName || !planType) {
      throw new Error('Missing required fields: amount, customerEmail, businessName, planType')
    }

    // Use real Stripe test mode
    const { default: StripeService } = await import('../services/stripeService.js');
const result = await StripeService.createPaymentIntent({
      amount,
      customerEmail,
      metadata: {
        businessName,
        planType,
        ...metadata
      }
    });
    
    if (result.success) {
      sendSuccess(res, 'Payment intent created successfully', {
        clientSecret: result.clientSecret,
        paymentIntentId: result.paymentIntentId,
        received: { amount, customerEmail, businessName, planType, metadata }
      });
    } else {
      throw new Error(result.error || 'Failed to create payment intent');
    }
  } catch (err) {
    next(err)
  }
})

router.post('/confirm', async (req, res, next) => {
  try {
    logger.info('=== PAYMENT CONFIRM DEBUG ===')
    logger.info('Request body:', req.body)
    logger.info('Request headers:', req.headers)
    logger.info('Request method:', req.method)
    logger.info('Request URL:', req.url)

    const { paymentIntentId, tenantData } = req.body || {}
    if (!paymentIntentId || !tenantData) {
      throw new Error('Missing required fields: paymentIntentId, tenantData')
    }

    const pool = await getPool();

                // Verify payment intent with Stripe
                const { default: StripeService } = await import('../services/stripeService.js');
                const paymentResult = await StripeService.retrievePaymentIntent(paymentIntentId);
                
                logger.info('Payment intent status:', paymentResult.paymentIntent?.status);
                logger.info('Payment intent charges:', paymentResult.paymentIntent?.charges?.data?.length);
                
                if (!paymentResult.success || paymentResult.paymentIntent.status !== 'succeeded') {
                  throw new Error(`Payment not confirmed or failed. Status: ${paymentResult.paymentIntent?.status}`);
                }

    // Generate tenant slug
    const baseSlug = tenantData.businessName?.toLowerCase().replace(/[^a-z0-9]/g, '-') || 'business';
    let slug = baseSlug;
    let counter = 1;
    
    // Ensure slug is unique
    while (true) {
      const existingTenant = await pool.query('SELECT id FROM tenants.business WHERE slug = $1', [slug]);
      if (existingTenant.rows.length === 0) {
        break;
      }
      slug = `${baseSlug}-${counter}`;
      counter++;
    }

    // Start transaction
    const client = await pool.connect();
    
    try {
      await client.query('BEGIN');
      
                  // Create user record WITHOUT password (they'll set it via email)
                  const userResult = await client.query(`
                    INSERT INTO auth.users (email, name, phone, password_hash, is_admin, account_status)
                    VALUES ($1, $2, $3, $4, $5, $6)
                    RETURNING id, email, name
                  `, [
                    tenantData.personalEmail,
                    `${tenantData.firstName} ${tenantData.lastName}`,
                    tenantData.personalPhone || null,
                    null, // No password - they'll set it via email
                    false,
                    'active' // Account status active - they can login once they set password
                  ]);
      
      const user = userResult.rows[0];
      
      // Create tenant record
      const tenantResult = await client.query(`
        INSERT INTO tenants.business (
          user_id, business_name, business_email, business_phone,
          first_name, last_name, personal_email, personal_phone,
          industry, application_status, application_date,
          service_areas, notes, slug
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
        RETURNING id, slug, business_name
      `, [
        user.id,
        tenantData.businessName,
        tenantData.businessEmail,
        tenantData.businessPhone,
        tenantData.firstName,
        tenantData.lastName,
        tenantData.personalEmail,
        tenantData.personalPhone || null,
        tenantData.industry,
        'approved', // Auto-approve for now
        new Date(),
        JSON.stringify([{
          zip: tenantData.businessAddress?.zip || '',
          city: tenantData.businessAddress?.city || '',
          state: tenantData.businessAddress?.state || '',
          minimum: 0,
          primary: true,
          multiplier: 1
        }]),
        `Payment: ${paymentIntentId}\nPlan: ${tenantData.selectedPlan}\nAddress: ${JSON.stringify(tenantData.businessAddress)}`,
        slug
      ]);
      
      const tenant = tenantResult.rows[0];
      
      await client.query('COMMIT');
      
      logger.info('✅ Tenant created successfully:', { userId: user.id, tenantId: tenant.id, slug });
      
      // Send welcome email
      try {
        const emailData = {
          firstName: tenantData.firstName,
          businessName: tenantData.businessName,
          personalEmail: tenantData.personalEmail,
          businessEmail: tenantData.businessEmail,
          websiteUrl: `http://${tenant.slug}.thatsmartsite.com`,
          dashboardUrl: `/${tenant.slug}/dashboard`,
          tempPassword: 'Please set your password via email' // Updated message since no temp password
        };
        
        const emailResult = await sendWelcomeEmail(emailData);
        if (emailResult.success) {
          logger.info('✅ Welcome email sent successfully');
        } else {
          console.warn('⚠️ Failed to send welcome email:', emailResult.error);
        }
      } catch (emailError) {
        console.warn('⚠️ Email sending error:', emailError.message);
        // Don't fail the entire transaction if email fails
      }
      
      sendSuccess(res, 'Payment confirmed and tenant created successfully', {
        slug: tenant.slug,
        websiteUrl: `http://${tenant.slug}.thatsmartsite.com`,
        dashboardUrl: `/${tenant.slug}/dashboard`,
        tenantId: tenant.id,
        userId: user.id,
        paymentIntentId
      });
      
    } catch (transactionError) {
      await client.query('ROLLBACK');
      throw transactionError;
    } finally {
      client.release();
    }
    
  } catch (err) {
    logger.error('Payment confirmation error:', err);
    next(err)
  }
})

export default router

/*──────────────── backend\routes\previews.js ────────────────*/

/**
 * Preview Routes
 * 
 * API endpoints for generating and verifying preview tokens.
 * Used by sales team to create demo sites for prospects.
 */

import express from 'express';
import { z } from 'zod';
import { signPreview, verifyPreview } from '../utils/previewToken.js';
import { createModuleLogger } from '../config/logger.js';

const router = express.Router();
const logger = createModuleLogger('previewRoutes');

// Middleware to add noindex headers for preview routes
router.use((req, res, next) => {
  res.setHeader('X-Robots-Tag', 'noindex, nofollow');
  next();
});

// Validation schema for preview payload
const PreviewPayloadSchema = z.object({
  businessName: z.string().min(2, 'Business name must be at least 2 characters').max(100),
  phone: z.string().min(7, 'Phone number must be at least 7 characters').max(20),
  city: z.string().min(2, 'City must be at least 2 characters').max(50),
  state: z.string().length(2, 'State must be 2 characters').regex(/^[A-Z]{2}$/, 'State must be uppercase'),
  industry: z.enum(['mobile-detailing', 'maid-service', 'lawncare', 'pet-grooming'], {
    errorMap: () => ({ message: 'Invalid industry type' }),
  }),
});

/**
 * POST /api/previews
 * Generate a signed preview token
 * 
 * Body: { businessName, phone, industry }
 * Returns: { url, token }
 */
router.post('/', (req, res) => {
  try {
    // Validate request body
    const validation = PreviewPayloadSchema.safeParse(req.body);
    
    if (!validation.success) {
      return res.status(400).json({
        error: 'Validation failed',
        details: validation.error.errors.map(err => ({
          field: err.path.join('.'),
          message: err.message,
        })),
      });
    }

    const payload = validation.data;

    // Sign the token
    const token = signPreview(payload);

    // Build preview URL (frontend will handle the route)
    const previewUrl = `/preview?t=${token}`;

    logger.info('Preview created', {
      industry: payload.industry,
      businessName: payload.businessName.substring(0, 20),
    });

    res.json({
      success: true,
      url: previewUrl,
      token,
      expiresIn: '7 days',
    });
  } catch (error) {
    logger.error('Failed to create preview', { error: error.message });
    res.status(500).json({
      error: 'Failed to create preview',
      message: 'An error occurred while generating the preview link',
    });
  }
});

/**
 * GET /api/preview/verify?t=<token>
 * Verify a preview token and return the payload
 * 
 * Query: { t: token }
 * Returns: { businessName, phone, industry }
 */
router.get('/verify', (req, res) => {
  try {
    const { t: token } = req.query;

    if (!token || typeof token !== 'string') {
      return res.status(400).json({
        error: 'Missing token',
        message: 'Preview token is required',
      });
    }

    // Verify and decode the token
    const payload = verifyPreview(token);

    res.json({
      success: true,
      payload,
    });
  } catch (error) {
    logger.warn('Preview verification failed', { error: error.message });
    
    // Return user-friendly error messages
    const statusCode = error.message.includes('expired') ? 410 : 400;
    
    res.status(statusCode).json({
      error: 'Verification failed',
      message: error.message,
    });
  }
});

export default router;



/*──────────────── backend\routes\reviews.js ────────────────*/

import express from 'express';
import { getPool } from '../database/pool.js';
import { authenticateToken } from '../middleware/auth.js';
import logger from '../utils/logger.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { sendSuccess, sendError, sendValidationError } from '../utils/responseFormatter.js';

const router = express.Router();

/**
 * GET /api/reviews
 * Get reviews with optional filtering
 * Query params: tenant_slug, limit, offset
 */
router.get('/', async (req, res) => {
  logger.info('Reviews GET route hit with query:', req.query);
  try {
    const pool = await getPool();
    const {
      tenant_slug,
      limit = 10,
      offset = 0
    } = req.query;

    let query = `
      SELECT 
        r.id,
        r.tenant_slug,
        r.customer_name,
        r.rating,
        r.comment,
        r.reviewer_url,
        r.vehicle_type,
        r.paint_correction,
        r.ceramic_coating,
        r.paint_protection_film,
        r.source,
        r.avatar_filename,
        r.created_at,
        r.updated_at,
        r.published_at
      FROM reputation.reviews r
    `;

    const queryParams = [];
    let paramCount = 0;

    // Add tenant filter if provided
    if (tenant_slug) {
      query += ` WHERE r.tenant_slug = $${++paramCount}`;
      queryParams.push(tenant_slug);
    }

    // Add ordering and pagination
    query += ` ORDER BY r.rating DESC, r.created_at DESC LIMIT $${++paramCount} OFFSET $${++paramCount}`;
    queryParams.push(parseInt(limit), parseInt(offset));

    const result = await pool.query(query, queryParams);
    
    // Get total count for pagination
    let countQuery = `SELECT COUNT(*) as total FROM reputation.reviews r`;
    const countParams = [];
    let countParamCount = 0;

    if (tenant_slug) {
      countQuery += ` WHERE r.tenant_slug = $${++countParamCount}`;
      countParams.push(tenant_slug);
    }

    const countResult = await pool.query(countQuery, countParams);
    const total = parseInt(countResult.rows[0].total);

    sendSuccess(res, 'Reviews retrieved successfully', {
      reviews: result.rows,
      pagination: {
        total,
        limit: parseInt(limit),
        offset: parseInt(offset),
        hasMore: (parseInt(offset) + parseInt(limit)) < total
      }
    });

  } catch (error) {
    logger.error('Error fetching reviews:', error);
    sendError(res, 'Failed to fetch reviews', error.message, 500);
  }
});

/**
 * GET /api/reviews/:id
 * Get a specific review by ID
 */
router.get('/:id', async (req, res) => {
  try {
    const pool = await getPool();
    const { id } = req.params;

    const query = `
      SELECT 
        r.id,
        r.tenant_slug,
        r.customer_name,
        r.rating,
        r.comment,
        r.reviewer_url,
        r.vehicle_type,
        r.paint_correction,
        r.ceramic_coating,
        r.paint_protection_film,
        r.source,
        r.avatar_filename,
        r.status,
        r.created_at,
        r.updated_at,
        r.published_at
      FROM reputation.reviews r
      WHERE r.id = $1
    `;

    const result = await pool.query(query, [id]);

    if (result.rows.length === 0) {
      return sendError(res, 'Review not found', null, 404);
    }

    sendSuccess(res, 'Review retrieved successfully', result.rows[0]);

  } catch (error) {
    logger.error('Error fetching review:', error);
    sendError(res, 'Failed to fetch review', error.message, 500);
  }
});

/**
 * POST /api/reviews
 * Create a new review
 */
router.post('/', async (req, res) => {
  try {
    const pool = await getPool();
    const {
      tenant_slug,
      customer_name,
      rating,
      comment,
      reviewer_url,
      vehicle_type,
      paint_correction = false,
      ceramic_coating = false,
      paint_protection_film = false,
      source = 'website',
      avatar_filename
    } = req.body;

    // Validate tenant exists
    if (tenant_slug) {
      const tenantCheck = await pool.query(
        'SELECT slug FROM tenants.business WHERE slug = $1',
        [tenant_slug]
      );

      if (tenantCheck.rows.length === 0) {
        return res.status(400).json({
          status: 'error',
          message: 'Tenant not found'
        });
      }
    }

    const query = `
      INSERT INTO reputation.reviews (
        tenant_slug, customer_name, rating, comment, reviewer_url, vehicle_type,
        paint_correction, ceramic_coating, paint_protection_film, source, avatar_filename
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING *
    `;

    const values = [
      tenant_slug,
      customer_name,
      rating,
      comment,
      reviewer_url || null,
      vehicle_type || null,
      paint_correction,
      ceramic_coating,
      paint_protection_film,
      source,
      avatar_filename || null
    ];

    const result = await pool.query(query, values);

    res.status(201).json({
      status: 'success',
      data: result.rows[0],
      message: 'Review submitted successfully'
    });

  } catch (error) {
    logger.error('Error creating review:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to create review',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});

/**
 * PUT /api/reviews/:id
 * Update a review (admin only)
 */
router.put('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;

    // Check if review exists
    const existingReview = await pool.query(
      'SELECT id FROM reputation.reviews WHERE id = $1',
      [id]
    );

    if (existingReview.rows.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Review not found'
      });
    }

    // Build dynamic update query
    const updateFields = [];
    const values = [];
    let paramCount = 0;

    Object.keys(updates).forEach(key => {
      if (updates[key] !== undefined) {
        updateFields.push(`${key} = $${++paramCount}`);
        values.push(updates[key]);
      }
    });

    if (updateFields.length === 0) {
      return res.status(400).json({
        status: 'error',
        message: 'No valid fields to update'
      });
    }

    values.push(id);
    const query = `
      UPDATE reputation.reviews 
      SET ${updateFields.join(', ')}, updated_at = CURRENT_TIMESTAMP
      WHERE id = $${++paramCount}
      RETURNING *
    `;

    const result = await pool.query(query, values);

    sendSuccess(res, 'Review updated successfully', result.rows[0]);

  } catch (error) {
    logger.error('Error updating review:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to update review',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});

/**
 * DELETE /api/reviews/:id
 * Delete a review (admin only)
 */
router.delete('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    const result = await pool.query(
      'DELETE FROM reputation.reviews WHERE id = $1 RETURNING id',
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Review not found'
      });
    }

    sendSuccess(res, 'Review deleted successfully');

  } catch (error) {
    logger.error('Error deleting review:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to delete review',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});


export default router;


/*──────────────── backend\routes\schedule.js ────────────────*/

/**
 * @fileoverview API routes for schedule
 * @version 1.0.0
 * @author That Smart Site
 */

import express from 'express';
import {  pool  } from '../database/pool';import { createModuleLogger } from '../config/logger.js';
;
import {  authenticateToken  } from '../middleware/auth';;
import {  withTenantByUser  } from '../middleware/withTenant';;
import {  validateBody  } from '../middleware/validation';;
import {  apiLimiter  } from '../middleware/rateLimiter';;
// import {  asyncHandler  } from '../middleware/errorHandler';; // Unused import
// TODO: Add request logging middleware when needed
// import {  requestLogger  } from '../middleware/requestLogger';;

const router = express.Router();
const logger = createModuleLogger('routeName');


// Apply middleware
// router.use(requestLogger); // Temporarily disabled due to env validation issues
router.use(apiLimiter);
router.use(authenticateToken);
router.use(withTenantByUser);

// Validation schemas
const appointmentSchema = {
  body: {
    type: 'object',
    required: ['title', 'service_type', 'service_duration', 'start_time', 'end_time', 'customer_name', 'customer_phone'],
    properties: {
      title: { type: 'string', minLength: 1, maxLength: 255 },
      description: { type: 'string', maxLength: 1000 },
      service_type: { type: 'string', minLength: 1, maxLength: 100 },
      service_duration: { type: 'integer', minimum: 1 },
      start_time: { type: 'string', format: 'date-time' },
      end_time: { type: 'string', format: 'date-time' },
      customer_name: { type: 'string', minLength: 1, maxLength: 255 },
      customer_phone: { type: 'string', minLength: 1, maxLength: 20 },
      customer_email: { type: 'string', format: 'email', maxLength: 255 },
      price: { type: 'number', minimum: 0 },
      deposit: { type: 'number', minimum: 0 },
      notes: { type: 'string', maxLength: 1000 },
      internal_notes: { type: 'string', maxLength: 1000 }
    }
  }
};

const timeBlockSchema = {
  body: {
    type: 'object',
    required: ['title', 'block_type', 'start_time', 'end_time'],
    properties: {
      title: { type: 'string', minLength: 1, maxLength: 255 },
      description: { type: 'string', maxLength: 1000 },
      block_type: { type: 'string', enum: ['unavailable', 'break', 'maintenance', 'personal', 'other'] },
      start_time: { type: 'string', format: 'date-time' },
      end_time: { type: 'string', format: 'date-time' },
      is_recurring: { type: 'boolean' },
      recurrence_pattern: { type: 'string', enum: ['daily', 'weekly', 'monthly'] },
      recurrence_end_date: { type: 'string', format: 'date-time' }
    }
  }
};

// APPOINTMENTS ROUTES

// Get appointments for a date range
router.get('/appointments', async (req, res) => {
  try {
    const { startDate, endDate } = req.query;

    if (!startDate || !endDate) {
      return res.status(400).json({ error: 'startDate and endDate are required' });
    }

    const tenantId = req.tenant.id;

    const query = `
      SELECT * FROM schedule.appointments 
      WHERE tenant_id = $1 
        AND start_time >= $2 
        AND end_time <= $3
      ORDER BY start_time ASC
    `;

    const result = await pool.query(query, [tenantId, startDate, endDate]);
    res.json(result.rows);
  } catch (error) {
    logger.error('Error fetching appointments:', error);
    if (error.message === 'No tenant business found for this user') {
      return res.status(404).json({ error: error.message });
    }
    res.status(500).json({ error: 'Failed to fetch appointments' });
  }
});

// Get appointments for a specific date
router.get('/appointments/date/:date', async (req, res) => {
  try {
    const { date } = req.params;
    const tenantId = req.user.tenant_id;

    const query = `
      SELECT * FROM schedule.appointments 
      WHERE tenant_id = $1 
        AND DATE(start_time) = $2
      ORDER BY start_time ASC
    `;

    const result = await pool.query(query, [tenantId, date]);
    res.json(result.rows);
  } catch (error) {
    logger.error('Error fetching appointments for date:', error);
    res.status(500).json({ error: 'Failed to fetch appointments' });
  }
});

// Get single appointment
router.get('/appointments/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const tenantId = req.user.tenant_id;

    const query = `
      SELECT * FROM schedule.appointments 
      WHERE id = $1 AND tenant_id = $2
    `;

    const result = await pool.query(query, [id, tenantId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Appointment not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    logger.error('Error fetching appointment:', error);
    res.status(500).json({ error: 'Failed to fetch appointment' });
  }
});

// Create appointment
router.post('/appointments', validateBody(appointmentSchema.body), async (req, res) => {
  try {
    const tenantId = req.user.tenant_id;
    const userId = req.user.id;
    const {
      title, description, service_type, service_duration,
      start_time, end_time, customer_name, customer_phone,
      customer_email, price, deposit, notes, internal_notes
    } = req.body;

    // Validate time constraints
    const startTime = new Date(start_time);
    const endTime = new Date(end_time);
    
    if (endTime <= startTime) {
      return res.status(400).json({ error: 'End time must be after start time' });
    }

    // Check for conflicts
    const conflictQuery = `
      SELECT id FROM schedule.appointments 
      WHERE tenant_id = $1 
        AND (
          (start_time < $2 AND end_time > $2) OR
          (start_time < $3 AND end_time > $3) OR
          (start_time >= $2 AND end_time <= $3)
        )
    `;

    const conflictResult = await pool.query(conflictQuery, [tenantId, start_time, end_time]);
    
    if (conflictResult.rows.length > 0) {
      return res.status(409).json({ error: 'Time slot conflicts with existing appointment' });
    }

    const query = `
      INSERT INTO schedule.appointments (
        tenant_id, title, description, service_type, service_duration,
        start_time, end_time, customer_name, customer_phone, customer_email,
        price, deposit, notes, internal_notes, created_by
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
      RETURNING *
    `;

    const result = await pool.query(query, [
      tenantId, title, description, service_type, service_duration,
      start_time, end_time, customer_name, customer_phone, customer_email,
      price, deposit, notes, internal_notes, userId
    ]);

    res.status(201).json(result.rows[0]);
  } catch (error) {
    logger.error('Error creating appointment:', error);
    res.status(500).json({ error: 'Failed to create appointment' });
  }
});

// Update appointment
router.put('/appointments/:id', validateBody(appointmentSchema.body), async (req, res) => {
  try {
    const { id } = req.params;
    const tenantId = req.user.tenant_id;
    const userId = req.user.id;
    const updateData = req.body;

    // Check if appointment exists and belongs to tenant
    const checkQuery = `
      SELECT id FROM schedule.appointments 
      WHERE id = $1 AND tenant_id = $2
    `;
    
    const checkResult = await pool.query(checkQuery, [id, tenantId]);
    if (checkResult.rows.length === 0) {
      return res.status(404).json({ error: 'Appointment not found' });
    }

    // Build dynamic update query
    const updateFields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(updateData).forEach(key => {
      if (updateData[key] !== undefined) {
        updateFields.push(`${key} = $${paramCount}`);
        values.push(updateData[key]);
        paramCount++;
      }
    });

    if (updateFields.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }

    updateFields.push(`updated_by = $${paramCount}`);
    values.push(userId);
    paramCount++;

    updateFields.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(id, tenantId);

    const query = `
      UPDATE schedule.appointments 
      SET ${updateFields.join(', ')}
      WHERE id = $${paramCount} AND tenant_id = $${paramCount + 1}
      RETURNING *
    `;

    const result = await pool.query(query, values);
    res.json(result.rows[0]);
  } catch (error) {
    logger.error('Error updating appointment:', error);
    res.status(500).json({ error: 'Failed to update appointment' });
  }
});

// Update appointment status
router.patch('/appointments/:id/status', async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    const tenantId = req.user.tenant_id;
    const userId = req.user.id;

    const validStatuses = ['scheduled', 'confirmed', 'in_progress', 'completed', 'cancelled', 'no_show'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({ error: 'Invalid status' });
    }

    const query = `
      UPDATE schedule.appointments 
      SET status = $1, updated_by = $2, updated_at = CURRENT_TIMESTAMP
      WHERE id = $3 AND tenant_id = $4
      RETURNING *
    `;

    const result = await pool.query(query, [status, userId, id, tenantId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Appointment not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    logger.error('Error updating appointment status:', error);
    res.status(500).json({ error: 'Failed to update appointment status' });
  }
});

// Delete appointment
router.delete('/appointments/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const tenantId = req.user.tenant_id;

    const query = `
      DELETE FROM schedule.appointments 
      WHERE id = $1 AND tenant_id = $2
      RETURNING id
    `;

    const result = await pool.query(query, [id, tenantId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Appointment not found' });
    }

    res.status(204).send();
  } catch (error) {
    logger.error('Error deleting appointment:', error);
    res.status(500).json({ error: 'Failed to delete appointment' });
  }
});

// Get available time slots
router.get('/appointments/available-slots', async (req, res) => {
  try {
    const { date, duration = 60 } = req.query;
    const tenantId = req.user.tenant_id;

    if (!date) {
      return res.status(400).json({ error: 'date is required' });
    }

    // Get schedule settings for this tenant
    const settingsQuery = `
      SELECT * FROM schedule.schedule_settings 
      WHERE tenant_id = $1
    `;
    
    const settingsResult = await pool.query(settingsQuery, [tenantId]);
    const settings = settingsResult.rows[0];

    if (!settings) {
      return res.status(404).json({ error: 'Schedule settings not found' });
    }

    // Get existing appointments and time blocks for the date
    const conflictsQuery = `
      SELECT start_time, end_time FROM schedule.appointments 
      WHERE tenant_id = $1 AND DATE(start_time) = $2
      UNION ALL
      SELECT start_time, end_time FROM schedule.time_blocks 
      WHERE tenant_id = $1 AND DATE(start_time) = $2
      ORDER BY start_time
    `;

    const conflictsResult = await pool.query(conflictsQuery, [tenantId, date]);
    const conflicts = conflictsResult.rows;

    // Generate available time slots based on business hours and settings
    const availableSlots = [];
    const businessHours = settings.business_hours;
    const dayOfWeek = new Date(date).toLocaleDateString('en-US', { weekday: 'lowercase' });
    const dayHours = businessHours[dayOfWeek];

    if (!dayHours || !dayHours.enabled) {
      return res.json([]);
    }

    const startTime = new Date(`${date}T${dayHours.start}:00`);
    const endTime = new Date(`${date}T${dayHours.end}:00`);
    const interval = settings.time_slot_interval * 60 * 1000; // Convert to milliseconds
    const appointmentDuration = duration * 60 * 1000;

    for (let time = startTime.getTime(); time + appointmentDuration <= endTime.getTime(); time += interval) {
      const slotStart = new Date(time);
      const slotEnd = new Date(time + appointmentDuration);
      
      // Check if this slot conflicts with existing appointments/blocks
      const hasConflict = conflicts.some(conflict => {
        const conflictStart = new Date(conflict.start_time);
        const conflictEnd = new Date(conflict.end_time);
        return (slotStart < conflictEnd && slotEnd > conflictStart);
      });

      if (!hasConflict) {
        availableSlots.push(slotStart.toTimeString().slice(0, 5));
      }
    }

    res.json(availableSlots);
  } catch (error) {
    logger.error('Error fetching available time slots:', error);
    res.status(500).json({ error: 'Failed to fetch available time slots' });
  }
});

// TIME BLOCKS ROUTES

// Get time blocks for a date range
router.get('/time-blocks', async (req, res) => {
  try {
    const { startDate, endDate } = req.query;

    if (!startDate || !endDate) {
      return res.status(400).json({ error: 'startDate and endDate are required' });
    }

    const tenantId = req.tenant.id;

    const query = `
      SELECT * FROM schedule.time_blocks 
      WHERE tenant_id = $1 
        AND start_time >= $2 
        AND end_time <= $3
      ORDER BY start_time ASC
    `;

    const result = await pool.query(query, [tenantId, startDate, endDate]);
    res.json(result.rows);
  } catch (error) {
    logger.error('Error fetching time blocks:', error);
    if (error.message === 'No tenant business found for this user') {
      return res.status(404).json({ error: error.message });
    }
    res.status(500).json({ error: 'Failed to fetch time blocks' });
  }
});

// Get time blocks for a specific date
router.get('/time-blocks/date/:date', async (req, res) => {
  try {
    const { date } = req.params;
    const tenantId = req.user.tenant_id;

    const query = `
      SELECT * FROM schedule.time_blocks 
      WHERE tenant_id = $1 
        AND DATE(start_time) = $2
      ORDER BY start_time ASC
    `;

    const result = await pool.query(query, [tenantId, date]);
    res.json(result.rows);
  } catch (error) {
    logger.error('Error fetching time blocks for date:', error);
    res.status(500).json({ error: 'Failed to fetch time blocks' });
  }
});

// Create time block
router.post('/time-blocks', validateBody(timeBlockSchema.body), async (req, res) => {
  try {
    const tenantId = req.user.tenant_id;
    const userId = req.user.id;
    const {
      title, description, block_type, start_time, end_time,
      is_recurring, recurrence_pattern, recurrence_end_date
    } = req.body;

    // Validate time constraints
    const startTime = new Date(start_time);
    const endTime = new Date(end_time);
    
    if (endTime <= startTime) {
      return res.status(400).json({ error: 'End time must be after start time' });
    }

    const query = `
      INSERT INTO schedule.time_blocks (
        tenant_id, title, description, block_type,
        start_time, end_time, is_recurring, recurrence_pattern,
        recurrence_end_date, created_by
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      RETURNING *
    `;

    const result = await pool.query(query, [
      tenantId, title, description, block_type,
      start_time, end_time, is_recurring, recurrence_pattern,
      recurrence_end_date, userId
    ]);

    res.status(201).json(result.rows[0]);
  } catch (error) {
    logger.error('Error creating time block:', error);
    res.status(500).json({ error: 'Failed to create time block' });
  }
});

// Update time block
router.put('/time-blocks/:id', validateBody(timeBlockSchema.body), async (req, res) => {
  try {
    const { id } = req.params;
    const tenantId = req.user.tenant_id;
    const updateData = req.body;

    // Check if time block exists and belongs to tenant
    const checkQuery = `
      SELECT id FROM schedule.time_blocks 
      WHERE id = $1 AND tenant_id = $2
    `;
    
    const checkResult = await pool.query(checkQuery, [id, tenantId]);
    if (checkResult.rows.length === 0) {
      return res.status(404).json({ error: 'Time block not found' });
    }

    // Build dynamic update query
    const updateFields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(updateData).forEach(key => {
      if (updateData[key] !== undefined) {
        updateFields.push(`${key} = $${paramCount}`);
        values.push(updateData[key]);
        paramCount++;
      }
    });

    if (updateFields.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }

    updateFields.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(id, tenantId);

    const query = `
      UPDATE schedule.time_blocks 
      SET ${updateFields.join(', ')}
      WHERE id = $${paramCount} AND tenant_id = $${paramCount + 1}
      RETURNING *
    `;

    const result = await pool.query(query, values);
    res.json(result.rows[0]);
  } catch (error) {
    logger.error('Error updating time block:', error);
    res.status(500).json({ error: 'Failed to update time block' });
  }
});

// Delete time block
router.delete('/time-blocks/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const tenantId = req.user.tenant_id;

    const query = `
      DELETE FROM schedule.time_blocks 
      WHERE id = $1 AND tenant_id = $2
      RETURNING id
    `;

    const result = await pool.query(query, [id, tenantId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Time block not found' });
    }

    res.status(204).send();
  } catch (error) {
    logger.error('Error deleting time block:', error);
    res.status(500).json({ error: 'Failed to delete time block' });
  }
});

// BLOCKED DAYS ROUTES

// Get blocked days for a date range
router.get('/blocked-days', async (req, res) => {
  try {
    const { startDate, endDate } = req.query;

    if (!startDate || !endDate) {
      return res.status(400).json({ error: 'startDate and endDate are required' });
    }

    const tenantId = req.tenant.id;

    const query = `
      SELECT blocked_date, reason, is_recurring, recurrence_pattern, recurrence_end_date
      FROM schedule.blocked_days 
      WHERE tenant_id = $1 
        AND blocked_date >= $2 
        AND blocked_date <= $3
      ORDER BY blocked_date ASC
    `;

    const result = await pool.query(query, [tenantId, startDate, endDate]);
    res.json(result.rows);
  } catch (error) {
    logger.error('Error fetching blocked days:', error);
    if (error.message === 'No tenant business found for this user') {
      return res.status(404).json({ error: error.message });
    }
    res.status(500).json({ error: 'Failed to fetch blocked days' });
  }
});

// Toggle blocked day (add if not exists, remove if exists)
router.post('/blocked-days/toggle', async (req, res) => {
  try {
    const { date, reason } = req.body;

    if (!date) {
      return res.status(400).json({ error: 'date is required' });
    }

    const tenantId = req.tenant.id;
    const userId = req.user.id;

    // Check if date is already blocked
    const checkQuery = `
      SELECT id FROM schedule.blocked_days 
      WHERE tenant_id = $1 AND blocked_date = $2
    `;
    
    const checkResult = await pool.query(checkQuery, [tenantId, date]);
    
    if (checkResult.rows.length > 0) {
      // Remove blocked day
      const deleteQuery = `
        DELETE FROM schedule.blocked_days 
        WHERE tenant_id = $1 AND blocked_date = $2
        RETURNING blocked_date
      `;
      
      const deleteResult = await pool.query(deleteQuery, [tenantId, date]);
      res.json({ 
        action: 'removed', 
        date: deleteResult.rows[0].blocked_date,
        message: 'Day unblocked successfully'
      });
    } else {
      // Add blocked day
      const insertQuery = `
        INSERT INTO schedule.blocked_days (tenant_id, blocked_date, reason, created_by)
        VALUES ($1, $2, $3, $4)
        RETURNING blocked_date, reason
      `;
      
      const insertResult = await pool.query(insertQuery, [tenantId, date, reason || 'Blocked', userId]);
      res.json({ 
        action: 'added', 
        date: insertResult.rows[0].blocked_date,
        reason: insertResult.rows[0].reason,
        message: 'Day blocked successfully'
      });
    }
  } catch (error) {
    logger.error('Error toggling blocked day:', error);
    if (error.message === 'No tenant business found for this user') {
      return res.status(404).json({ error: error.message });
    }
    res.status(500).json({ error: 'Failed to toggle blocked day' });
  }
});

// Add blocked day
router.post('/blocked-days', async (req, res) => {
  try {
    const { date, reason, is_recurring, recurrence_pattern, recurrence_end_date } = req.body;
    const tenantId = req.user.tenant_id;
    const userId = req.user.id;

    if (!date) {
      return res.status(400).json({ error: 'date is required' });
    }

    // Check if date is already blocked
    const checkQuery = `
      SELECT id FROM schedule.blocked_days 
      WHERE tenant_id = $1 AND blocked_date = $2
    `;
    
    const checkResult = await pool.query(checkQuery, [tenantId, date]);
    if (checkResult.rows.length > 0) {
      return res.status(409).json({ error: 'Date is already blocked' });
    }

    const query = `
      INSERT INTO schedule.blocked_days (
        tenant_id, blocked_date, reason, is_recurring, 
        recurrence_pattern, recurrence_end_date, created_by
      ) VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING *
    `;

    const result = await pool.query(query, [
      tenantId, date, reason || 'Blocked', is_recurring || false,
      recurrence_pattern, recurrence_end_date, userId
    ]);

    res.status(201).json(result.rows[0]);
  } catch (error) {
    logger.error('Error adding blocked day:', error);
    res.status(500).json({ error: 'Failed to add blocked day' });
  }
});

// Remove blocked day
router.delete('/blocked-days/:date', async (req, res) => {
  try {
    const { date } = req.params;
    const tenantId = req.user.tenant_id;

    const query = `
      DELETE FROM schedule.blocked_days 
      WHERE tenant_id = $1 AND blocked_date = $2
      RETURNING blocked_date
    `;

    const result = await pool.query(query, [tenantId, date]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Blocked day not found' });
    }

    res.json({ 
      message: 'Blocked day removed successfully',
      date: result.rows[0].blocked_date
    });
  } catch (error) {
    logger.error('Error removing blocked day:', error);
    res.status(500).json({ error: 'Failed to remove blocked day' });
  }
});

// SCHEDULE SETTINGS ROUTES

// Get schedule settings
router.get('/settings', async (req, res) => {
  try {
    const tenantId = req.user.tenant_id;

    const query = `
      SELECT * FROM schedule.schedule_settings 
      WHERE tenant_id = $1
    `;

    const result = await pool.query(query, [tenantId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Schedule settings not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    logger.error('Error fetching schedule settings:', error);
    res.status(500).json({ error: 'Failed to fetch schedule settings' });
  }
});

// Update schedule settings
router.put('/settings', async (req, res) => {
  try {
    const tenantId = req.user.tenant_id;
    const userId = req.user.id;
    const updateData = req.body;

    // Build dynamic update query
    const updateFields = [];
    const values = [];
    let paramCount = 1;

    Object.keys(updateData).forEach(key => {
      if (updateData[key] !== undefined) {
        updateFields.push(`${key} = $${paramCount}`);
        values.push(updateData[key]);
        paramCount++;
      }
    });

    if (updateFields.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }

    updateFields.push(`updated_by = $${paramCount}`);
    values.push(userId);
    paramCount++;

    updateFields.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(tenantId);

    const query = `
      UPDATE schedule.schedule_settings 
      SET ${updateFields.join(', ')}
      WHERE tenant_id = $${paramCount}
      RETURNING *
    `;

    const result = await pool.query(query, values);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Schedule settings not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    logger.error('Error updating schedule settings:', error);
    res.status(500).json({ error: 'Failed to update schedule settings' });
  }
});

// Reset schedule settings to defaults
router.post('/settings/reset', async (req, res) => {
  try {
    const tenantId = req.user.tenant_id;
    const userId = req.user.id;

    const query = `
      UPDATE schedule.schedule_settings 
      SET 
        business_hours = '{
          "monday": {"start": "09:00", "end": "17:00", "enabled": true},
          "tuesday": {"start": "09:00", "end": "17:00", "enabled": true},
          "wednesday": {"start": "09:00", "end": "17:00", "enabled": true},
          "thursday": {"start": "09:00", "end": "17:00", "enabled": true},
          "friday": {"start": "09:00", "end": "17:00", "enabled": true},
          "saturday": {"start": "10:00", "end": "15:00", "enabled": true},
          "sunday": {"start": "10:00", "end": "15:00", "enabled": false}
        }',
        default_appointment_duration = 60,
        buffer_time = 15,
        max_appointments_per_day = 20,
        advance_booking_days = 30,
        same_day_booking_allowed = true,
        time_slot_interval = 15,
        earliest_appointment_time = '08:00',
        latest_appointment_time = '18:00',
        send_reminders = true,
        reminder_hours_before = 24,
        send_confirmation_emails = true,
        updated_by = $1,
        updated_at = CURRENT_TIMESTAMP
      WHERE tenant_id = $2
      RETURNING *
    `;

    const result = await pool.query(query, [userId, tenantId]);
    res.json(result.rows[0]);
  } catch (error) {
    logger.error('Error resetting schedule settings:', error);
    res.status(500).json({ error: 'Failed to reset schedule settings' });
  }
});

module.exports = router;


/*──────────────── backend\routes\seo.js ────────────────*/

import express from 'express';
import logger from '../utils/logger';
import { asyncHandler } from '../middleware/errorHandler';
import { getPool } from '../database/pool.js';
import { robotsRoute, sitemapRoute, seoConfigRoute, previewRoute } from './seo';

/**
 * SEO Routes - Centralized SEO endpoint management
 * 
 * This module anchors Cursor's understanding of SEO backend functionality.
 * All SEO-related API endpoints should be defined here.
 */
const router = express.Router();

// Simple in-memory cache for sitemap responses
// Keyed by host; stores { xml: string, expiresAt: number }
const sitemapCache = new Map();
const ONE_HOUR_MS = 60 * 60 * 1000;
const TWENTY_FOUR_HOURS_MS = 24 * ONE_HOUR_MS;

// Import the modular SEO routes
// TODO: Fix TypeScript
imports - these are .ts files in ./seo/ directory
//

// Use the modular routes
// router.use('/', robotsRoute);
// router.use('/', sitemapRoute);
// router.use('/api/seo', seoConfigRoute);
// router.use('/', previewRoute);

/**
 * GET /robots.txt
 * Generate tenant-specific robots.txt
 */
router.get('/robots.txt', asyncHandler((req, res) => {
  try {
    // Get tenant domain from request
    const host = req.get('host');
    const protocol = req.get('x-forwarded-proto') || req.protocol;
    const domain = `${protocol}://${host}`;
    
    // Check if this is a preview domain
    const isPreview = host.includes('preview') || host.includes('localhost');
    
    // Generate robots.txt content
    let robotsContent;
    
    if (isPreview) {
      // Block all crawlers for preview domains
      robotsContent = `User-agent: *
Disallow: /
`;
    } else {
      // Allow indexing for live tenants, block preview routes
      robotsContent = `User-agent: *
Disallow: /preview
Disallow: /admin
Disallow: /api
Sitemap: ${domain}/sitemap.xml
`;
    }
    
    // Set appropriate headers
    res.set({
      'Content-Type': 'text/plain',
      'Cache-Control': 'public, max-age=86400', // Cache for 24 hours
    });
    
    res.send(robotsContent);
    
    logger.info(`Robots.txt served for ${host}`, {
      isPreview,
      domain
    });
    
  } catch (error) {
    logger.error('Error generating robots.txt:', error);
    
    // Fallback robots.txt (block everything)
    res.set('Content-Type', 'text/plain');
    res.send(`User-agent: *
Disallow: /
`);
  }
}));

/**
 * GET /sitemap.xml
 * Generate tenant-specific sitemap
 */
router.get('/sitemap.xml', asyncHandler(async (req, res) => {
  try {
    const host = req.get('host');
    const protocol = req.get('x-forwarded-proto') || req.protocol;
    const domain = `${protocol}://${host}`;
    
    // Check if this is a preview domain
    const isPreview = host.includes('preview') || host.includes('localhost');

    // Check cache first (separate TTLs for preview vs live)
    const cacheEntry = sitemapCache.get(host);
    const now = Date.now();
    if (cacheEntry && cacheEntry.expiresAt > now) {
      res.set({
        'Content-Type': 'application/xml',
        'Cache-Control': 'public, max-age=3600', // Client cache 1 hour
        'X-Sitemap-Cache': 'HIT'
      });
      return res.send(cacheEntry.xml);
    }
    
    if (isPreview) {
      // Return empty sitemap for preview domains
      const emptySitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
</urlset>`;
      
      // Populate cache for preview domains with shorter TTL
      sitemapCache.set(host, {
        xml: emptySitemap,
        expiresAt: now + ONE_HOUR_MS
      });
      res.set({
        'Content-Type': 'application/xml',
        'Cache-Control': 'public, max-age=3600', // Cache for 1 hour
        'X-Sitemap-Cache': 'MISS'
      });
      return res.send(emptySitemap);
    }
    
    // Get tenant information from database
    let tenantData = null;
    if (pool) {
      try {
        // Try to find tenant by domain or slug
        const result = await pool.query(`
          SELECT 
            b.id,
            b.slug,
            b.business_name,
            b.industry,
            b.service_areas,
            b.website_domain,
            b.approved_date,
            wc.services,
            wc.faqs
          FROM tenants.business b
          LEFT JOIN website.content wc ON b.id = wc.business_id
          WHERE b.website_domain = $1 
             OR $1 LIKE '%' || b.slug || '%'
             OR b.slug = $2
          ORDER BY b.approved_date DESC
          LIMIT 1
        `, [host, host.split('.')[0]]);
        
        if (result.rows.length > 0) {
          tenantData = result.rows[0];
        }
      } catch (dbError) {
        logger.warn('Database error while generating sitemap:', dbError.message);
      }
    }
    
    // Generate sitemap XML
    const urls = [];
    const currentDate = new Date().toISOString().split('T')[0];
    
    // Add homepage
    urls.push({
      loc: domain,
      lastmod: currentDate,
      changefreq: 'weekly',
      priority: '1.0'
    });
    
    // Add services page
    urls.push({
      loc: `${domain}/services`,
      lastmod: currentDate,
      changefreq: 'monthly',
      priority: '0.8'
    });
    
    // Add reviews page
    urls.push({
      loc: `${domain}/reviews`,
      lastmod: currentDate,
      changefreq: 'weekly',
      priority: '0.7'
    });
    
    // Add FAQ page
    urls.push({
      loc: `${domain}/faq`,
      lastmod: currentDate,
      changefreq: 'monthly',
      priority: '0.6'
    });
    
    // Add contact page
    urls.push({
      loc: `${domain}/contact`,
      lastmod: currentDate,
      changefreq: 'monthly',
      priority: '0.5'
    });
    
    // Add location pages if tenant has service areas
    if (tenantData && tenantData.service_areas) {
      try {
        const serviceAreas = typeof tenantData.service_areas === 'string' 
          ? JSON.parse(tenantData.service_areas) 
          : tenantData.service_areas;
        
        if (Array.isArray(serviceAreas)) {
          serviceAreas.forEach(area => {
            if (area.city && area.state) {
              const citySlug = area.city.toLowerCase().replace(/\s+/g, '-');
              const stateSlug = area.state.toLowerCase().replace(/\s+/g, '-');
              urls.push({
                loc: `${domain}/${citySlug}-${stateSlug}`,
                lastmod: currentDate,
                changefreq: 'monthly',
                priority: '0.7'
              });
            }
          });
        }
      } catch (parseError) {
        logger.warn('Error parsing service areas for sitemap:', parseError.message);
      }
    }
    
    // Generate XML
    const sitemapXml = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${urls.map(url => `  <url>
    <loc>${url.loc}</loc>
    <lastmod>${url.lastmod}</lastmod>
    <changefreq>${url.changefreq}</changefreq>
    <priority>${url.priority}</priority>
  </url>`).join('\n')}
</urlset>`;
    
    // Cache live sitemaps for 24 hours by host
    sitemapCache.set(host, {
      xml: sitemapXml,
      expiresAt: now + TWENTY_FOUR_HOURS_MS
    });
    res.set({
      'Content-Type': 'application/xml',
      'Cache-Control': 'public, max-age=3600', // Client cache 1 hour
      'X-Sitemap-Cache': 'MISS'
    });
    res.send(sitemapXml);
    
    logger.info(`Sitemap served for ${host}`, {
      urlCount: urls.length,
      hasTenantData: !!tenantData
    });
    
  } catch (error) {
    logger.error('Error generating sitemap:', error);
    
    // Fallback empty sitemap
    const fallbackSitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
</urlset>`;
    
    res.set('Content-Type', 'application/xml');
    res.send(fallbackSitemap);
  }
}));

export default router;


/*──────────────── backend\routes\serviceAreas.js ────────────────*/

import express from 'express';
import logger from '../utils/logger';
import { asyncHandler } from '../middleware/errorHandler';
import { getPlatformServiceAreas, getTenantsForCity } from '../utils/serviceAreaProcessor';
import { getPool } from '../database/pool.js';
import { serviceAreaSchemas } from '../utils/validationSchemas';
import { validateParams } from '../middleware/validation';

/**
 * @fileoverview API routes for serviceAreas
 * @version 1.0.0
 * @author That Smart Site
 */
const router = express.Router();

// Get all service areas organized by state -> city -> slug for footer
router.get('/footer', asyncHandler(async (req, res) => {
  try {
    logger.info('Footer service areas endpoint called');

    if (!pool) {
      logger.error('Database connection not available');
      const error = new Error('Database connection not available');
      error.statusCode = 500;
      throw error;
    }
    
    // First, check if we have any approved tenants
    const countResult = await pool.query(`
      SELECT COUNT(*) as count
      FROM tenants.business 
      WHERE approved_date IS NOT NULL
    `);
    
    const approvedCount = parseInt(countResult.rows[0].count);
    logger.info(`Found ${approvedCount} approved tenants`);
    
    if (approvedCount === 0) {
      logger.info('No approved tenants found, returning empty service areas');
      return res.json({
        success: true,
        service_areas: {},
        count: 0,
        message: 'No approved tenants found'
      });
    }
    
    // Get all approved tenants with their service areas
    const result = await pool.query(`
      SELECT id, slug, service_areas
      FROM tenants.business 
      WHERE approved_date IS NOT NULL 
        AND service_areas IS NOT NULL
    `);
    
    logger.info(`Found ${result.rows.length} tenants with service areas data`);
    
    // Process the data to create state -> city -> slug structure
    const serviceAreasMap = {};
    
    result.rows.forEach(tenant => {
      try {
        if (tenant.service_areas && Array.isArray(tenant.service_areas)) {
          tenant.service_areas.forEach(area => {
            const state = area.state?.toUpperCase();
            const city = area.city;
            const slug = tenant.slug;
            
            if (state && city && slug) {
              if (!serviceAreasMap[state]) {
                serviceAreasMap[state] = {};
              }
              if (!serviceAreasMap[state][city]) {
                serviceAreasMap[state][city] = [];
              }
              // Add slug if not already present
              if (!serviceAreasMap[state][city].includes(slug)) {
                serviceAreasMap[state][city].push(slug);
              }
            }
          });
        }
      } catch (areaError) {
        logger.warn(`Error processing service areas for tenant ${tenant.slug}:`, areaError);
      }
    });
    
    logger.info(`Processed service areas for ${Object.keys(serviceAreasMap).length} states`);
    
    res.json({
      success: true,
      service_areas: serviceAreasMap,
      count: Object.keys(serviceAreasMap).length
    });
    
  } catch (error) {
    logger.error('Error in footer service areas endpoint:', error);
    throw error;
  }
}));

// Get all service areas (states that have coverage)
router.get('/', asyncHandler(async (req, res) => {
  try {
    logger.info('Service areas endpoint called');
    

    if (!pool) {
      logger.error('Database connection not available');
      const error = new Error('Database connection not available');
      error.statusCode = 500;
      throw error;
    }
    
    logger.info('Database pool obtained, executing query');
    
    const result = await pool.query(`
      SELECT DISTINCT 
        JSONB_ARRAY_ELEMENTS(a.service_areas)->>'state' as state_code,
        JSONB_ARRAY_ELEMENTS(a.service_areas)->>'state' as name
      FROM tenants.business a
      WHERE a.approved_date IS NOT NULL 
        AND a.service_areas IS NOT NULL
        AND JSONB_ARRAY_LENGTH(a.service_areas) > 0
      ORDER BY name
    `);
    
    logger.info(`Query executed successfully, found ${result.rows.length} states`);
    
    res.json(result.rows);
  } catch (error) {
    logger.error('Error in service areas endpoint:', error);
    throw error;
  }
}));

// Get cities for a specific state
router.get('/:state_code', 
  validateParams(serviceAreaSchemas.getCities),
  asyncHandler(async (req, res) => {

    const pool = await getPool();
    
    const { state_code } = req.params;

    const result = await pool.query(`
      SELECT DISTINCT 
        JSONB_ARRAY_ELEMENTS(a.service_areas)->>'city' as city,
        JSONB_ARRAY_ELEMENTS(a.service_areas)->>'state' as state_code,
        JSONB_ARRAY_ELEMENTS(a.service_areas)->>'zip' as zip
      FROM tenants.business a
      WHERE a.approved_date IS NOT NULL 
        AND a.service_areas IS NOT NULL
        AND JSONB_ARRAY_LENGTH(a.service_areas) > 0
        AND JSONB_ARRAY_ELEMENTS(a.service_areas)->>'state' = $1
      ORDER BY city
    `, [state_code]);
    
    res.json(result.rows);
  })
);

// Get all platform service areas (cities and states where approved tenants serve)
router.get('/platform/coverage', asyncHandler(async (req, res) => {
  try {
    logger.info('Platform coverage endpoint called');
    
    if (!pool) {
      logger.error('Database connection not available');
      const error = new Error('Database connection not available');
      error.statusCode = 500;
      throw error;
    }
    
    const serviceAreas = await getPlatformServiceAreas();
    
    res.json({
      success: true,
      service_areas: serviceAreas,
      count: serviceAreas.length
    });
  } catch (error) {
    logger.error('Error fetching platform coverage:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch coverage data'
    });
  }
}));

// Get tenants serving a specific city (for directory pages)
router.get('/city/:slug', asyncHandler(async (req, res) => {
  try {
    logger.info('City tenants endpoint called');
    
    if (!pool) {
      logger.error('Database connection not available');
      const error = new Error('Database connection not available');
      error.statusCode = 500;
      throw error;
    }
    
    const { slug } = req.params;
    const tenants = await getTenantsForCity(slug);
    
    res.json({
      success: true,
      slug,
      tenants,
      count: tenants.length
    });
  } catch (error) {
    logger.error('Error fetching city tenants:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch tenant data'
    });
  }
}));

export default router;


/*──────────────── backend\routes\services.js ────────────────*/

/**
 * @fileoverview API routes for services
 * @version 1.0.0
 * @author That Smart Site
 */

import express from 'express';
import { pool } from '../database/pool';
import { createModuleLogger } from '../config/logger.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { getDatabaseId } from '../utils/vehicleMapping';
import { sendSuccess, sendError, sendValidationError } from '../utils/responseFormatter.js';

const router = express.Router();
const logger = createModuleLogger('services');


// POST /api/services - Create a new service
router.post('/', async (req, res) => {
  try {
    const { tenant_id, vehicle_id, service_category_id, base_price_cents, name, description, tiers } = req.body;
    
    
    // Validate required fields
    if (!tenant_id || !name || !vehicle_id || !service_category_id) {
      return res.status(400).json({
        status: 'error',
        error: 'Missing required fields',
        message: 'tenant_id, vehicle_id, service_category_id, and name are required'
      });
    }
    
    // Map the category based on the service_category_id
    let category = 'service-packages'; // default
    let originalCategory = 'service-packages'; // default
    
    if (service_category_id) {
      // Convert to number in case it's a string
      const categoryId = parseInt(service_category_id);
      
      const categoryMap = {
        1: { db: 'interior', original: 'interior' },
        2: { db: 'exterior', original: 'exterior' },
        3: { db: 'service-packages', original: 'service-packages' },
        4: { db: 'ceramic-coating', original: 'ceramic-coating' },
        5: { db: 'paint-correction', original: 'paint-correction' },
        6: { db: 'paint-protection-film', original: 'paint-protection-film' },
        7: { db: 'addons', original: 'addons' }
      };
      
      const mapping = categoryMap[categoryId] || { db: 'service-packages', original: 'service-packages' };
      category = mapping.db;
      originalCategory = mapping.original;
    }
    
    // Create the service using the correct table and column names
    const insertQuery = `
      INSERT INTO tenants.services (business_id, service_name, service_description, service_category, vehicle_types, metadata, is_active, is_featured, sort_order)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING *
    `;
    
    // Handle both string vehicle IDs (from old frontend) and numeric vehicle IDs (from new frontend)
    const dbVehicleId = typeof vehicle_id === 'string' ? getDatabaseId(vehicle_id) : vehicle_id;
    const vehicleTypes = JSON.stringify([dbVehicleId]);
    const metadata = JSON.stringify({
      base_price_cents: base_price_cents || 0,
      pricing_unit: 'flat',
      min_duration_min: 60,
      original_category: originalCategory
    });
    
    const result = await pool.query(insertQuery, [
      tenant_id,  // business_id
      name,          // service_name
      description || 'Offered by tenant', // service_description
      category,      // service_category
      vehicleTypes,  // vehicle_types
      metadata,      // metadata
      true,          // is_active
      false,         // is_featured
      0              // sort_order
    ]);
    
    const newService = result.rows[0];
    
    // Create service tiers - use custom tiers if provided, otherwise create default tiers
    if (tiers && Array.isArray(tiers) && tiers.length > 0) {
      logger.info('Backend - Received tiers data:', JSON.stringify(tiers, null, 2));
      // Use custom tiers provided by the frontend
      for (const tier of tiers) {
        if (tier.name && tier.name.trim() !== '') {
          logger.info('Backend - Processing tier:', tier.name, 'tierCopies:', tier.tierCopies);
          await pool.query(`
            INSERT INTO tenants.service_tiers (service_id, tier_name, price_cents, included_services, duration_minutes, metadata, is_active, is_featured, sort_order)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
          `, [
            newService.id,
            tier.name,
            Math.round((tier.price || 0) * 100), // Price in cents
            JSON.stringify(tier.features || []), // Features as JSON array
            tier.duration || 60, // Duration in minutes
            JSON.stringify({}), // Empty metadata
            true, // is_active
            tier.popular || false, // is_featured
            0 // sort_order
          ]);
        }
      }
      
      res.status(201).json({
        status: 'success',
        data: newService,
        message: 'Service created successfully with custom tiers'
      });
    } else {
      // Create default service tiers if no custom tiers provided
      const tierNames = ['Basic', 'Premium', 'Luxury'];
      const tierPrices = [50, 100, 150]; // Default prices in dollars
      
      for (let i = 0; i < tierNames.length; i++) {
        await pool.query(`
          INSERT INTO tenants.service_tiers (service_id, tier_name, price_cents, included_services, duration_minutes, is_active, is_featured, sort_order)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `, [
          newService.id,
          tierNames[i],
          Math.round(tierPrices[i] * 100), // Convert to cents
          JSON.stringify([`${tierNames[i]} tier features`]), // Features as JSON array
          60, // Duration in minutes
          true, // is_active
          i === 1, // Mark Premium as featured
          i // sort_order
        ]);
      }
      
      res.status(201).json({
        status: 'success',
        data: newService,
        message: 'Service created successfully with default tiers'
      });
    }
    
  } catch (error) {
    logger.error('Error creating service:', error);
    res.status(500).json({
      status: 'error',
      error: 'Failed to create service',
      message: error.message
    });
  }
});

// PUT /api/services/:serviceId - Update a service and its tiers
router.put('/:serviceId', async (req, res) => {
  try {
    const { serviceId } = req.params;
    const { tenant_id, vehicle_id, service_category_id, base_price_cents, name, description, tiers } = req.body;
    
    if (!serviceId) {
      return res.status(400).json({
        status: 'error',
        error: 'Missing service ID',
        message: 'Service ID is required'
      });
    }
    
    // Validate required fields
    if (!tenant_id || !name || !vehicle_id || !service_category_id) {
      return res.status(400).json({
        status: 'error',
        error: 'Missing required fields',
        message: 'tenant_id, vehicle_id, service_category_id, and name are required'
      });
    }
    
    // Map the category based on the service_category_id
    let category = 'service-packages'; // default
    let originalCategory = 'service-packages'; // default
    
    if (service_category_id) {
      // Convert to number in case it's a string
      const categoryId = parseInt(service_category_id);
      
      const categoryMap = {
        1: { db: 'interior', original: 'interior' },
        2: { db: 'exterior', original: 'exterior' },
        3: { db: 'service-packages', original: 'service-packages' },
        4: { db: 'ceramic-coating', original: 'ceramic-coating' },
        5: { db: 'paint-correction', original: 'paint-correction' },
        6: { db: 'paint-protection-film', original: 'paint-protection-film' },
        7: { db: 'addons', original: 'addons' }
      };
      
      const mapping = categoryMap[categoryId] || { db: 'service-packages', original: 'service-packages' };
      category = mapping.db;
      originalCategory = mapping.original;
    }
    
    const dbVehicleId = getDatabaseId(vehicle_id);
    const vehicleTypes = JSON.stringify([dbVehicleId]);
    const metadata = JSON.stringify({
      base_price_cents: base_price_cents || 0,
      pricing_unit: 'flat',
      min_duration_min: 60,
      original_category: originalCategory
    });
    
    // Start a transaction to ensure both updates succeed or both fail
    const client = await pool.connect();
    
    try {
      await client.query('BEGIN');
      
      // Update the service
      const updateServiceQuery = `
        UPDATE tenants.services 
        SET service_name = $1, 
            service_description = $2, 
            service_category = $3, 
            vehicle_types = $4, 
            metadata = $5,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = $6 AND business_id = $7
        RETURNING *
      `;
      
      const serviceResult = await client.query(updateServiceQuery, [
        name,
        description || 'Offered by tenant',
        category,
        vehicleTypes,
        metadata,
        serviceId,
        tenant_id
      ]);
      
      if (serviceResult.rowCount === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({
          status: 'error',
          error: 'Service not found',
          message: 'No service found with the provided ID or you do not have permission to update it'
        });
      }
      
      // Delete existing tiers
      await client.query('DELETE FROM tenants.service_tiers WHERE service_id = $1', [serviceId]);
      
      // Create new service tiers
      if (tiers && Array.isArray(tiers) && tiers.length > 0) {
        logger.info('Backend PUT - Received tiers data:', JSON.stringify(tiers, null, 2));
        // Use custom tiers provided by the frontend
        for (const tier of tiers) {
          if (tier.name && tier.name.trim() !== '') {
            logger.info('Backend PUT - Processing tier:', tier.name, 'tierCopies:', tier.tierCopies);
            await client.query(`
              INSERT INTO tenants.service_tiers (service_id, tier_name, price_cents, included_services, duration_minutes, metadata, is_active, is_featured, sort_order)
              VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            `, [
              serviceId,
              tier.name,
              Math.round((tier.price || 0) * 100), // Price in cents
              JSON.stringify(tier.features || []), // Features as JSON array
              tier.duration || 60, // Duration in minutes
              JSON.stringify({}), // Empty metadata
              true, // is_active
              tier.popular || false, // is_featured
              0 // sort_order
            ]);
          }
        }
      } else {
        // Create default service tiers if no custom tiers provided
        const tierNames = ['Basic', 'Premium', 'Luxury'];
        const tierPrices = [50, 100, 150]; // Default prices in dollars
        
        for (let i = 0; i < tierNames.length; i++) {
          await client.query(`
            INSERT INTO tenants.service_tiers (service_id, tier_name, price_cents, included_services, duration_minutes, is_active, is_featured, sort_order)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
          `, [
            serviceId,
            tierNames[i],
            Math.round(tierPrices[i] * 100), // Convert to cents
            JSON.stringify([`${tierNames[i]} tier features`]), // Features as JSON array
            60, // Duration in minutes
            true, // is_active
            i === 1, // Mark Premium as featured
            i // sort_order
          ]);
        }
      }
      
      // Commit the transaction
      await client.query('COMMIT');
      
      sendSuccess(res, 'Service updated successfully', serviceResult.rows[0]);
      
    } catch (error) {
      // Rollback the transaction on error
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
    
  } catch (error) {
    logger.error('Error updating service:', error);
    res.status(500).json({
      status: 'error',
      error: 'Failed to update service',
      message: error.message
    });
  }
});

// DELETE /api/services/:serviceId - Delete a service and its tiers
router.delete('/:serviceId', async (req, res) => {
  try {
    const { serviceId } = req.params;
    
    if (!serviceId) {
      return res.status(400).json({
        status: 'error',
        error: 'Missing service ID',
        message: 'Service ID is required'
      });
    }
    
    // Start a transaction to ensure both deletions succeed or both fail
    const client = await pool.connect();
    
    try {
      await client.query('BEGIN');
      
      // First, delete all service tiers for this service
      const deleteTiersQuery = 'DELETE FROM tenants.service_tiers WHERE service_id = $1';
      const tiersResult = await client.query(deleteTiersQuery, [serviceId]);
      
      // Then, delete the service itself
      const deleteServiceQuery = 'DELETE FROM tenants.services WHERE id = $1';
      const serviceResult = await client.query(deleteServiceQuery, [serviceId]);
      
      if (serviceResult.rowCount === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({
          status: 'error',
          error: 'Service not found',
          message: 'No service found with the provided ID'
        });
      }
      
      // Commit the transaction
      await client.query('COMMIT');
      
      sendSuccess(res, 'Service and all associated tiers deleted successfully', {
        deletedServiceId: serviceId,
        deletedTiersCount: tiersResult.rowCount
      });
      
    } catch (error) {
      // Rollback the transaction on error
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
    
  } catch (error) {
    logger.error('Error deleting service:', error);
    res.status(500).json({
      status: 'error',
      error: 'Failed to delete service',
      message: error.message
    });
  }
});

// GET /api/services/tenant/:tenantId/vehicle/:vehicleId/category/:categoryId - Get services with tiers
router.get('/tenant/:tenantId/vehicle/:vehicleId/category/:categoryId', async (req, res) => {
  try {
    const { tenantId, vehicleId, categoryId } = req.params;
    
    // Map the category ID to the actual category name
    const categoryMap = {
      1: 'interior',
      2: 'exterior', 
      3: 'service-packages',
      4: 'ceramic-coating',
      5: 'paint-correction',
      6: 'paint-protection-film',
      7: 'addons'
    };
    
    const dbCategory = categoryMap[parseInt(categoryId)] || 'service-packages';
    
    // Get database ID for the vehicle type
    const dbVehicleType = getDatabaseId(vehicleId);
    
    // Check for the specific vehicle type requested
    // Only return services that specifically support this vehicle type
    const vehicleTypesFilter = 's.vehicle_types @> $3::jsonb';
    
    // Clean query using the correct table structure with proper category filtering
    const query = `
      SELECT 
        s.id as service_id,
        s.service_name as name,
        s.service_category as category,
        s.service_description as description,
        s.metadata->>'base_price_cents' as base_price_cents,
        s.metadata->>'pricing_unit' as pricing_unit,
        s.metadata->>'min_duration_min' as min_duration_min,
        s.is_active as active
      FROM tenants.services s
      WHERE s.business_id = $1 
        AND s.service_category = $2
        AND ${vehicleTypesFilter}
      ORDER BY s.created_at DESC, s.service_name ASC
    `;
    
    const queryParams = [tenantId, dbCategory, JSON.stringify([dbVehicleType])];
    
    const result = await pool.query(query, queryParams);
    
    if (result.rows.length === 0) {
      return sendSuccess(res, 'No services found', []);
    }
    
    // For each service, get its tiers
    const servicesWithTiers = [];
    
    for (const service of result.rows) {
      const tiersQuery = `
        SELECT 
          st.id as tier_id,
          st.tier_name,
          st.price_cents,
          st.included_services,
          st.duration_minutes,
          st.metadata,
          st.is_active,
          st.is_featured
        FROM tenants.service_tiers st
        WHERE st.service_id = $1
        ORDER BY st.price_cents ASC
      `;
      
      const tiersResult = await pool.query(tiersQuery, [service.service_id]);
      
      const serviceData = {
        id: service.service_id,
        name: service.name,
        basePrice: service.base_price_cents ? parseFloat(service.base_price_cents) / 100 : 0,
        category: service.category,
        description: service.description,
        tiers: tiersResult.rows.map(row => ({
          id: row.tier_id,
          name: row.tier_name,
          price: row.price_cents / 100,
          duration: row.duration_minutes || 60,
          features: row.included_services || [],
          enabled: row.is_active,
          popular: row.is_featured
        }))
      };
      
      servicesWithTiers.push(serviceData);
    }
    
    sendSuccess(res, 'Services with tiers retrieved successfully', servicesWithTiers);
    
  } catch (error) {
    logger.error('Error fetching service with tiers:', error);
    res.status(500).json({
      status: 'error',
      error: 'Failed to fetch service with tiers',
      message: error.message
    });
  }
});

module.exports = router;

/*──────────────── backend\routes\stockImages.js ────────────────*/

/**
 * @fileoverview API routes for stockImages
 * @version 1.0.0
 * @author That Smart Site
 */

const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();

// Get list of stock images
router.get('/images', (req, res) => {
  try {
    // Read from the frontend public stock folder
    const stockPath = path.join(__dirname, '../../frontend/public/images/stock');
    
    // Check if stock directory exists
    if (!fs.existsSync(stockPath)) {
      return res.json([]);
    }
    
    // Read directory contents
    const files = fs.readdirSync(stockPath);
    
    // Filter for image files
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.PNG', '.JPG', '.JPEG', '.gif', '.GIF', '.webp', '.WEBP'];
    const imageFiles = files.filter(file => {
      const ext = path.extname(file);
      return imageExtensions.includes(ext);
    });
    
    // Convert to URLs (frontend will serve these from public folder)
    const imageUrls = imageFiles.map(file => `/images/stock/${file}`);
    
    res.json(imageUrls);
  } catch (error) {
    logger.error('Error reading stock images directory:', error);
    res.status(500).json({ error: 'Failed to read stock images' });
  }
});

module.exports = router;


/*──────────────── backend\routes\subdomainTest.js ────────────────*/

/**
 * Subdomain Test Routes
 * For testing subdomain middleware functionality
 */

import express from 'express';
import { createModuleLogger } from '../config/logger.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { sendSuccess, sendError } from '../utils/responseFormatter.js';

const logger = createModuleLogger('subdomainTest');
const router = express.Router();

/**
 * GET /api/subdomain/info
 * Returns subdomain information for debugging
 */
router.get('/info', (req, res) => {
  const info = {
    hostname: req.hostname,
    tenant: req.tenant ? {
      id: req.tenant.id,
      slug: req.tenant.slug,
      businessName: req.tenant.business_name,
      industry: req.tenant.industry,
      isActive: req.tenant.is_active
    } : null,
    tenantSlug: req.tenantSlug,
    isMainSite: req.isMainSite,
    isTenantSite: req.isTenantSite,
    isAdminSite: req.isAdminSite,
    routing: res.locals.routing,
    tenantContext: res.locals.tenant,
    timestamp: new Date().toISOString()
  };

  logger.info({
    event: 'subdomain_info_request',
    info
  }, 'Subdomain info requested');

  sendSuccess(res, 'Subdomain information retrieved successfully', info);
});

/**
 * GET /api/subdomain/test
 * Test route that responds differently based on subdomain
 */
router.get('/test', (req, res) => {
  let response = {
    status: 'success',
    message: '',
    data: {
      hostname: req.hostname,
      path: req.path,
      timestamp: new Date().toISOString()
    }
  };

  if (req.isAdminSite) {
    response.message = 'Admin subdomain detected - admin.thatsmartsite.com';
    response.data.type = 'admin';
    response.data.accessLevel = 'admin';
  } else if (req.isTenantSite && req.tenant) {
    response.message = `Tenant subdomain detected - ${req.tenantSlug}.thatsmartsite.com`;
    response.data.type = 'tenant';
    response.data.tenant = {
      id: req.tenant.id,
      slug: req.tenant.slug,
      businessName: req.tenant.business_name,
      industry: req.tenant.industry
    };
    response.data.accessLevel = 'tenant';
  } else if (req.isMainSite) {
    response.message = 'Main site detected - thatsmartsite.com';
    response.data.type = 'main';
    response.data.accessLevel = 'public';
  } else {
    response.message = 'Unknown subdomain type';
    response.data.type = 'unknown';
    response.data.accessLevel = 'unknown';
  }

  logger.info({
    event: 'subdomain_test_request',
    response: response.data
  }, 'Subdomain test requested');

  sendSuccess(res, response.message, response.data);
});

/**
 * GET /api/subdomain/tenant-content/:slug
 * Get tenant content for a specific slug
 */
router.get('/tenant-content/:slug', async (req, res) => {
  try {
    const { slug } = req.params;
    
    // Import tenant service
    const { getTenantBySlug, getTenantWebsiteContent } = await import('../services/tenantService.js');
    
    const tenant = await getTenantBySlug(slug);
    
    if (!tenant) {
      return res.status(404).json({
        status: 'error',
        message: 'Tenant not found',
        slug
      });
    }
    
    const content = await getTenantWebsiteContent(slug);
    
    sendSuccess(res, 'Tenant content retrieved successfully', {
      tenant: {
        id: tenant.id,
        slug: tenant.slug,
        businessName: tenant.business_name,
        industry: tenant.industry,
        isActive: tenant.is_active,
        subscriptionStatus: tenant.subscription_status,
        planName: tenant.plan_name
      },
      content: content || {},
      contentTypes: content ? Object.keys(content) : []
    });
    
  } catch (error) {
    logger.error({
      event: 'tenant_content_error',
      error: error.message,
      stack: error.stack,
      slug: req.params.slug
    }, 'Error retrieving tenant content');
    
    res.status(500).json({
      status: 'error',
      message: 'Internal server error',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong'
    });
  }
});

export default router;


/*──────────────── backend\routes\tenantDashboard.js ────────────────*/

/**
 * Tenant Dashboard Routes
 * 
 * API routes for tenant dashboard analytics and aggregated data.
 */

import express from 'express';
import { authenticateToken } from '../middleware/auth.js';
import { withTenant, validateTenantExists, validateTenantApproved } from '../middleware/withTenant.js';
import { validateTenantAccess, addTenantHeaders, logTenantContext } from '../middleware/tenantValidation.js';
import {
  getTenantDashboard,
  getTenantOverview,
  getTenantReviews,
  getTenantPerformance,
  getTenantActivity
} from '../controllers/tenantDashboardController.js';
import { asyncHandler } from '../middleware/errorHandler.js';

const router = express.Router();

/**
 * Dashboard routes require authentication and tenant context
 */
router.use(authenticateToken);
router.use(withTenant);
router.use(validateTenantExists);
router.use(validateTenantApproved);
router.use(validateTenantAccess);
router.use(addTenantHeaders);
router.use(logTenantContext);

/**
 * GET /api/tenants/:tenantSlug/dashboard
 * Get comprehensive dashboard analytics
 * 
 * Query parameters:
 * - dateRange: 7d, 30d, 90d, 1y (default: 30d)
 * - includeDetails: true/false (default: false)
 * 
 * Response includes:
 * - overview: Basic tenant stats
 * - reviews: Review analytics and trends
 * - performance: Website performance metrics
 * - activity: Recent activity summary
 * - services: Service analytics
 * - summary: Health score and recommendations
 */
router.get('/:tenantSlug/dashboard', asyncHandler(getTenantDashboard));

/**
 * GET /api/tenants/:tenantSlug/dashboard/overview
 * Get basic tenant overview statistics
 * 
 * Query parameters:
 * - dateRange: 7d, 30d, 90d, 1y (default: 30d)
 * 
 * Response includes:
 * - Basic tenant info
 * - Review counts and ratings
 * - Activity metrics
 * - Trend indicators
 */
router.get('/:tenantSlug/dashboard/overview', asyncHandler(getTenantOverview));

/**
 * GET /api/tenants/:tenantSlug/dashboard/reviews
 * Get detailed review analytics
 * 
 * Query parameters:
 * - dateRange: 7d, 30d, 90d, 1y (default: 30d)
 * - limit: Number of recent reviews to return (default: 10)
 * - offset: Pagination offset (default: 0)
 * 
 * Response includes:
 * - Review distribution by rating
 * - Recent reviews with pagination
 * - Review trends over time
 * - Source breakdown
 */
router.get('/:tenantSlug/dashboard/reviews', asyncHandler(getTenantReviews));

/**
 * GET /api/tenants/:tenantSlug/dashboard/performance
 * Get performance analytics
 * 
 * Query parameters:
 * - dateRange: 7d, 30d, 90d, 1y (default: 30d)
 * 
 * Response includes:
 * - Website performance metrics
 * - SEO scores
 * - Social media engagement
 * - Core Web Vitals
 */
router.get('/:tenantSlug/dashboard/performance', asyncHandler(getTenantPerformance));

/**
 * GET /api/tenants/:tenantSlug/dashboard/activity
 * Get recent activity summary
 * 
 * Query parameters:
 * - dateRange: 7d, 30d, 90d, 1y (default: 30d)
 * - limit: Number of activities to return (default: 20)
 * 
 * Response includes:
 * - Recent activities timeline
 * - Activity counts by type
 * - Engagement metrics
 */
router.get('/:tenantSlug/dashboard/activity', asyncHandler(getTenantActivity));

export default router;


/*──────────────── backend\routes\tenantImages.js ────────────────*/

import express from 'express';
import fs from 'fs';
import path from 'path';
import { asyncHandler } from '../middleware/errorHandler.js';
import { getPool } from '../database/pool.js';import { createModuleLogger } from '../config/logger.js';

/**
 * @fileoverview API routes for tenantImages
 * @version 1.0.0
 * @author That Smart Site
 */
// TODO: Add file system operations when implementing image management
//
//
;
const router = express.Router();
const logger = createModuleLogger('routeName');


// Get list of tenant-specific images
router.get('/images', async (req, res) => {
  try {
    const { tenant } = req.query;
    
    if (!tenant) {
      return res.status(400).json({ error: 'Tenant parameter is required' });
    }
    
    // Query database for tenant images
    const result = await pool.query(
      'SELECT file_path, filename, image_category FROM tenants.tenant_images WHERE tenant_slug = $1 AND is_active = true ORDER BY uploaded_at DESC',
      [tenant]
    );
    
    // Convert database paths to URLs
    const imageUrls = result.rows.map(row => ({
      url: row.file_path,
      filename: row.filename,
      category: row.image_category
    }));
    
    res.json(imageUrls);
  } catch (error) {
    logger.error('Error reading tenant images:', error);
    res.status(500).json({ error: 'Failed to read tenant images' });
  }
});

// Upload new tenant image
router.post('/upload', (req, res) => {
  try {
    const { tenant, category: _category = 'gallery' } = req.body;
    
    if (!tenant) {
      return res.status(400).json({ error: 'Tenant parameter is required' });
    }
    
    // TODO: Add file upload handling with multer
    // TODO: Add billing/plan checks
    // TODO: Save file to tenant-specific directory
    // TODO: Insert record into database
    
    res.json({ message: 'Upload endpoint ready - implementation pending' });
  } catch (error) {
    logger.error('Error uploading tenant image:', error);
    res.status(500).json({ error: 'Failed to upload image' });
  }
});

export default router;


/*──────────────── backend\routes\tenantManifest.js ────────────────*/

import express from 'express';
import logger from '../utils/logger';
import { pool } from '../database/pool';import { asyncHandler } from '../middleware/errorHandler.js';

/**
 * Tenant PWA Manifest Generator
 * Generates tenant-specific manifest.json for "Add to Home Screen"
 */
const router = express.Router();
;

/**
 * GET /:slug/manifest.json
 * Generate tenant-specific PWA manifest
 */
router.get('/:slug/manifest.json', async (req, res) => {
  try {
    const { slug } = req.params;

    // Fetch tenant business info
    const query = `
      SELECT 
        business_name,
        slug,
        industry
      FROM tenants.business
      WHERE slug = $1 AND application_status = 'approved'
    `;

    const result = await pool.query(query, [slug]);

    if (result.rows.length === 0) {
      return res.status(404).json({
        error: 'Tenant not found'
      });
    }

    const tenant = result.rows[0];
    
    // Use default theme colors (could be customizable in future)
    const themeColor = '#ea580c'; // Orange-600 default
    const backgroundColor = '#1c1917'; // Stone-900
    
    // Generate tenant-specific manifest
    const manifest = {
      name: `${tenant.business_name} - Dashboard`,
      short_name: tenant.business_name,
      description: `Manage your ${tenant.business_name} website and business`,
      start_url: `/${slug}/dashboard`,
      display: 'standalone',
      background_color: backgroundColor,
      theme_color: themeColor,
      orientation: 'portrait-primary',
      scope: `/${slug}/`,
      lang: 'en',
      categories: ['business', 'productivity'],
      icons: [
        {
          src: `${process.env.FRONTEND_URL || 'http://localhost:5173'}/${tenant.industry}/icons/favicon.svg`,
          sizes: 'any',
          type: 'image/svg+xml',
          purpose: 'any'
        },
        {
          src: `${process.env.FRONTEND_URL || 'http://localhost:5173'}/${tenant.industry}/icons/favicon-192.webp`,
          sizes: '192x192',
          type: 'image/webp',
          purpose: 'any'
        },
        {
          src: `${process.env.FRONTEND_URL || 'http://localhost:5173'}/${tenant.industry}/icons/favicon-512.webp`,
          sizes: '512x512',
          type: 'image/webp',
          purpose: 'any'
        }
      ],
      shortcuts: [
        {
          name: 'Dashboard',
          short_name: 'Dashboard',
          description: 'Open your dashboard',
          url: `/${slug}/dashboard`,
          icons: [{ src: `${process.env.FRONTEND_URL || 'http://localhost:5173'}/${tenant.industry}/icons/favicon.svg`, sizes: '96x96' }]
        },
        {
          name: 'View Website',
          short_name: 'Website',
          description: 'View your live website',
          url: `/${slug}`,
          icons: [{ src: `${process.env.FRONTEND_URL || 'http://localhost:5173'}/${tenant.industry}/icons/favicon.svg`, sizes: '96x96' }]
        }
      ]
    };

    // Set correct content type
    res.setHeader('Content-Type', 'application/manifest+json');
    res.json(manifest);

  } catch (error) {
    logger.error('Error generating tenant manifest:', error);
    res.status(500).json({
      error: 'Failed to generate manifest',
      message: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});

export default router;





/*──────────────── backend\routes\tenantReviews.js ────────────────*/

import express from 'express';
import fs from 'fs';
import googleBusinessScraper from '../services/googleBusinessScraper';
import logger from '../utils/logger';
import multer from 'multer';
import path from 'path';
import { authenticateToken } from '../middleware/auth';
import { generateAvatarFilename, ensureUploadsDir } from '../utils/avatarUtils';
import { pool } from '../database/pool';
import { asyncHandler } from '../middleware/errorHandler.js';
import { validateFileMagic } from '../utils/uploadValidator';
import { sendSuccess, sendError, sendValidationError } from '../utils/responseFormatter.js';


const router = express.Router();
;
// TODO: Add authentication to protected routes
//

// Configure multer for avatar uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    ensureUploadsDir();
    cb(null, 'uploads/avatars/');
  },
  filename: (req, file, cb) => {
    // Generate a temporary filename since we'll rename it later
    const extension = path.extname(file.originalname || '').toLowerCase() || '.jpg';
    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').split('.')[0];
    const filename = `temp_avatar_${timestamp}${extension}`;
    cb(null, filename);
  }
});

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit
  },
  fileFilter: (req, file, cb) => {
    // Only allow image files
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed'), false);
    }
  }
});

/**
 * POST /api/tenant-reviews/upload-avatar
 * Upload avatar for a review (public endpoint)
 */
router.post('/upload-avatar', upload.single('avatar'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        status: 'error',
        message: 'No file uploaded'
      });
    }

    const { customerName, reviewId } = req.body;
    
    if (!customerName || !reviewId) {
      // Delete the uploaded file if validation fails
      fs.unlinkSync(req.file.path);
      return res.status(400).json({
        status: 'error',
        message: 'customerName and reviewId are required'
      });
    }

    // Magic number validation for avatar uploads
    const allowedImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
    const magicValidation = await validateFileMagic(req.file, allowedImageTypes);
    if (!magicValidation.success) {
      // Delete the uploaded file if validation fails
      fs.unlinkSync(req.file.path);
      return res.status(magicValidation.statusCode).json({
        status: 'error',
        message: magicValidation.errors[0]?.message || 'File validation failed'
      });
    }

    // Generate proper filename and rename the file
    const extension = path.extname(req.file.originalname || '').toLowerCase() || '.jpg';
    const properFilename = generateAvatarFilename(customerName, parseInt(reviewId), extension);
    const properPath = path.join('uploads/avatars', properFilename);
    
    try {
      // Rename the file to the proper name
      fs.renameSync(req.file.path, properPath);
      
      const avatarUrl = `/uploads/avatars/${properFilename}`;

      // Update the review record with the avatar filename
      logger.debug('Updating review with avatar filename', {
        reviewId: parseInt(reviewId),
        filename: properFilename
      });
      
      const updateResult = await pool.query(
        'UPDATE reputation.reviews SET avatar_filename = $1 WHERE id = $2',
        [properFilename, parseInt(reviewId)]
      );
      
      logger.debug('Avatar filename update result', {
        reviewId: parseInt(reviewId),
        rowsAffected: updateResult.rowCount,
        filename: properFilename
      });

      sendSuccess(res, 'Avatar uploaded successfully', {
        avatarUrl: avatarUrl,
        filename: properFilename
      });
    } catch (renameError) {
      // If rename fails, delete the original file and return error
      fs.unlinkSync(req.file.path);
      res.status(500).json({
        status: 'error',
        message: 'Error renaming uploaded file',
        error: renameError.message
      });
    }

  } catch (error) {
    logger.error('Error uploading avatar:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to upload avatar',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});

/**
 * POST /api/tenant-reviews
 * Create a new review from tenant dashboard
 * Note: No authentication required - reviews are public submissions
 */
router.post('/', async (req, res) => {
  try {
    const {
      tenant_slug,
      customer_name,
      rating,
      comment,
      reviewer_url,
      vehicle_type,
      paint_correction,
      ceramic_coating,
      paint_protection_film,
      source,
      avatar_filename
    } = req.body;

    // Validate required fields
    if (!tenant_slug || !customer_name || !rating || !comment) {
      return res.status(400).json({
        status: 'error',
        message: 'Missing required fields: tenant_slug, customer_name, rating, comment'
      });
    }

    // Validate rating
    if (rating < 1 || rating > 5) {
      return res.status(400).json({
        status: 'error',
        message: 'Rating must be between 1 and 5'
      });
    }

    // Validate vehicle type if provided
    const validVehicleTypes = ['car', 'truck', 'suv', 'boat', 'rv', 'motorcycle'];
    if (vehicle_type && !validVehicleTypes.includes(vehicle_type)) {
      return res.status(400).json({
        status: 'error',
        message: `Invalid vehicle type. Must be one of: ${validVehicleTypes.join(', ')}`
      });
    }

    // Validate source
    const validSources = ['website', 'google', 'yelp', 'facebook'];
    if (source && !validSources.includes(source)) {
      return res.status(400).json({
        status: 'error',
        message: `Invalid source. Must be one of: ${validSources.join(', ')}`
      });
    }

    // Verify tenant exists (optional - adjust based on your tenant table structure)
    // const tenantCheck = await pool.query(
    //   'SELECT slug FROM tenants.business WHERE slug = $1',
    //   [tenant_slug]
    // );
    // if (tenantCheck.rows.length === 0) {
    //   return res.status(400).json({
    //     status: 'error',
    //     message: 'Tenant not found'
    //   });
    // }

    const query = `
      INSERT INTO reputation.reviews (
        tenant_slug, customer_name, rating, comment, reviewer_url,
        vehicle_type, paint_correction, ceramic_coating, paint_protection_film,
        source, avatar_filename
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING *
    `;

    const values = [
      tenant_slug,
      customer_name,
      rating,
      comment,
      reviewer_url || null,
      vehicle_type || null,
      paint_correction || false,
      ceramic_coating || false,
      paint_protection_film || false,
      source || 'website',
      avatar_filename || null
    ];

    const result = await pool.query(query, values);

    res.status(201).json({
      status: 'success',
      data: result.rows[0],
      message: 'Review published successfully'
    });

  } catch (error) {
    logger.error('Error creating tenant review:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to create review',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});

/**
 * GET /api/tenant-reviews/check-gbp-url/:tenantSlug
 * Check what Google Business Profile URL is stored in database
 */
router.get('/check-gbp-url/:tenantSlug', async (req, res) => {
  try {
    const { tenantSlug } = req.params;
    
    const result = await pool.query(
      'SELECT gbp_url, business_name FROM tenants.business WHERE slug = $1',
      [tenantSlug]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Tenant not found'
      });
    }
    
    const business = result.rows[0];
    
    sendSuccess(res, 'Business information retrieved successfully', {
      tenantSlug,
      businessName: business.business_name,
      gbpUrl: business.gbp_url,
      urlType: business.gbp_url ? 
        (business.gbp_url.includes('business.google.com') ? 'Direct Business Profile' :
         business.gbp_url.includes('maps.google.com') ? 'Google Maps' :
         business.gbp_url.includes('google.com/search') ? 'Google Search Results' :
         business.gbp_url.includes('share.google') ? 'Google Share Link' :
         'Unknown Format') : 'No URL Set'
    });
    
  } catch (error) {
    logger.error('Error checking GBP URL:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to check GBP URL',
      error: error.message
    });
  }
});

/**
 * GET /api/tenant-reviews/test-scraping
 * Test endpoint to debug scraping issues
 */
router.get('/test-scraping', async (req, res) => {
  try {
    const { url } = req.query;
    
    if (!url) {
      return res.status(400).json({
        status: 'error',
        message: 'URL parameter is required'
      });
    }

    logger.info(`Test scraping URL: ${url}`);

    // Test basic page access
    const testResult = await googleBusinessScraper.scrapeBusinessProfile(url);

    sendSuccess(res, 'Test scraping completed', testResult);

  } catch (error) {
    logger.error('Test scraping error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Test scraping failed',
      error: error.message
    });
  }
});

/**
 * GET /api/tenant-reviews/:tenant_slug
 * Get reviews for a specific tenant (all reviews are published immediately)
 */
router.get('/:tenant_slug', async (req, res) => {
  try {
    const { tenant_slug } = req.params;
    const { limit = 10, offset = 0 } = req.query;

    const query = `
      SELECT 
        id, customer_name, rating, comment, reviewer_url,
        vehicle_type, paint_correction, ceramic_coating, paint_protection_film,
        source, avatar_filename, created_at
      FROM reputation.reviews
      WHERE tenant_slug = $1
      ORDER BY rating DESC, created_at DESC
      LIMIT $2 OFFSET $3
    `;

    const result = await pool.query(query, [tenant_slug, parseInt(limit), parseInt(offset)]);

    // Get total count
    const countResult = await pool.query(
      'SELECT COUNT(*) as total FROM reputation.reviews WHERE tenant_slug = $1',
      [tenant_slug]
    );

    const total = parseInt(countResult.rows[0].total);

    sendSuccess(res, 'Reviews retrieved successfully', {
      reviews: result.rows,
      pagination: {
        total,
        limit: parseInt(limit),
        offset: parseInt(offset),
        hasMore: (parseInt(offset) + parseInt(limit)) < total
      }
    });

  } catch (error) {
    logger.error('Error fetching tenant reviews:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to fetch reviews',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});

/**
 * DELETE /api/tenant-reviews/:id
 * Delete a review (tenant can remove reviews at will)
 */
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const query = `
      DELETE FROM reputation.reviews 
      WHERE id = $1
      RETURNING *
    `;

    const result = await pool.query(query, [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Review not found'
      });
    }

    sendSuccess(res, 'Review deleted successfully');

  } catch (error) {
    logger.error('Error deleting review:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to delete review',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});

/**
 * POST /api/tenant-reviews/scrape-google-business
 * Scrape Google Business Profile for rating and review count
 */
router.post('/scrape-google-business', async (req, res) => {
  try {
    const { gbpUrl, tenantSlug } = req.body;

    if (!gbpUrl) {
      return res.status(400).json({
        status: 'error',
        message: 'Google Business Profile URL is required'
      });
    }

    // Validate URL format
    try {
      new URL(gbpUrl);
    } catch {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid URL format'
      });
    }

    logger.info(`Starting Google Business Profile scraping for: ${gbpUrl}`);

    // Scrape the Google Business Profile
    const scrapeResult = await googleBusinessScraper.scrapeBusinessProfile(gbpUrl);

    logger.info('Scrape result:', JSON.stringify(scrapeResult, null, 2));

    if (!scrapeResult.success) {
      logger.error('Scraping failed:', scrapeResult.error);
      return res.status(500).json({
        status: 'error',
        message: 'Failed to scrape Google Business Profile',
        error: scrapeResult.error,
        debug: process.env.NODE_ENV === 'development' ? scrapeResult : undefined
      });
    }

    const { averageRating, totalReviews, businessName } = scrapeResult.data;

    // If we have both rating and review count, optionally update the business record
    if (tenantSlug && (averageRating || totalReviews)) {
      try {
        const updateFields = [];
        const updateValues = [];
        let paramCount = 0;

        if (averageRating) {
          updateFields.push(`average_rating = $${++paramCount}`);
          updateValues.push(averageRating);
        }

        if (totalReviews) {
          updateFields.push(`total_review_count = $${++paramCount}`);
          updateValues.push(totalReviews);
        }

        if (updateFields.length > 0) {
          updateValues.push(tenantSlug); // Add tenant_slug as last parameter
          
          const updateQuery = `
            UPDATE tenants.business 
            SET ${updateFields.join(', ')}, updated_at = CURRENT_TIMESTAMP
            WHERE slug = $${++paramCount}
          `;

          await pool.query(updateQuery, updateValues);
          logger.info(`Updated business record for tenant: ${tenantSlug}`);
        }
      } catch (dbError) {
        logger.warn('Failed to update business record:', dbError);
        // Don't fail the entire request if DB update fails
      }
    }

    sendSuccess(res, 'Successfully scraped Google Business Profile', {
      averageRating,
      totalReviews,
      businessName,
      gbpUrl
    });

  } catch (error) {
    logger.error('Error in scrape-google-business endpoint:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to scrape Google Business Profile',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
});

export default router;


/*──────────────── backend\routes\tenants.js ────────────────*/

import express from 'express';
const router = express.Router();
import { asyncHandler } from '../middleware/errorHandler.js';
import { validateBody, validateParams, validateQuery } from '../middleware/zodValidation.js';
import { tenantSchemas } from '../schemas/apiSchemas.js';
// TODO: Add authentication to protected routes
// import { authenticateToken } from '../middleware/auth.js';
import { apiLimiter, sensitiveAuthLimiter } from '../middleware/rateLimiter.js';
import * as tenantController from '../controllers/tenantController.js';

/**
 * POST /api/tenants/signup
 * Create new tenant account with user and business record
 */
router.post('/signup', 
  sensitiveAuthLimiter, 
  validateBody(tenantSchemas.signup),
  asyncHandler(tenantController.createTenant)
);

/**
 * GET /api/tenants/:slug
 * Fetch tenant data by slug with industry information
 */
router.get('/:slug', 
  apiLimiter, 
  validateParams(tenantSchemas.getBySlug),
  asyncHandler(tenantController.getTenantBySlug)
);

/**
 * PUT /api/tenants/:slug
 * Update tenant business data by slug
 */
router.put('/:slug', 
  apiLimiter, 
  validateParams(tenantSchemas.getBySlug),
  asyncHandler(tenantController.updateTenantBySlug)
);

/**
 * GET /api/tenants
 * Fetch tenants by industry (optional filter)
 */
router.get('/', 
  apiLimiter, 
  validateQuery(tenantSchemas.list),
  asyncHandler(tenantController.getTenantsByIndustry)
);

/**
 * GET /api/tenants/industries/list
 * Get list of available industries
 */
router.get('/industries/list', apiLimiter, asyncHandler(tenantController.getIndustries));

export default router;

/*──────────────── backend\routes\upload.js ────────────────*/

import express from 'express';
import logger from '../utils/logger';
import { UPLOAD_CONFIG } from '../utils/uploadValidator';
import { asyncHandler } from '../middleware/errorHandler';
import { singleFileUpload, multipleFilesUpload, memoryUpload } from '../middleware/upload';


const router = express.Router();

/**
 * Single file upload endpoint
 * POST /api/upload/single
 */
router.post('/single', 
  singleFileUpload('file', {
    maxFileSize: 2 * 1024 * 1024, // 2MB for this endpoint
    allowedMimeTypes: {
      images: ['image/jpeg', 'image/png', 'image/gif']
    }
  }),
  asyncHandler((req, res) => {
    if (!req.file) {
      return res.status(400).json({
        error: 'No file uploaded',
        message: 'Please select a file to upload'
      });
    }

    logger.info('File uploaded successfully', {
      filename: req.file.originalname,
      size: req.file.size,
      mimetype: req.file.mimetype
    });

    res.status(200).json({
      message: 'File uploaded successfully',
      file: {
        filename: req.file.filename,
        originalName: req.file.originalname,
        size: req.file.size,
        mimetype: req.file.mimetype,
        url: `/uploads/${req.file.filename}`
      }
    });
  })
);

/**
 * Multiple files upload endpoint
 * POST /api/upload/multiple
 */
router.post('/multiple',
  multipleFilesUpload('files', {
    maxFiles: 3,
    maxFileSize: 1 * 1024 * 1024, // 1MB per file
    allowedMimeTypes: {
      images: ['image/jpeg', 'image/png'],
      documents: ['application/pdf', 'text/plain']
    }
  }),
  asyncHandler((req, res) => {
    if (!req.files || req.files.length === 0) {
      return res.status(400).json({
        error: 'No files uploaded',
        message: 'Please select files to upload'
      });
    }

    const uploadedFiles = req.files.map(file => ({
      filename: file.filename,
      originalName: file.originalname,
      size: file.size,
      mimetype: file.mimetype,
      url: `/uploads/${file.filename}`
    }));

    logger.info('Multiple files uploaded successfully', {
      fileCount: req.files.length,
      totalSize: req.files.reduce((sum, f) => sum + f.size, 0)
    });

    res.status(200).json({
      message: `${req.files.length} files uploaded successfully`,
      files: uploadedFiles
    });
  })
);

/**
 * Memory upload endpoint (for processing without saving)
 * POST /api/upload/memory
 */
router.post('/memory',
  memoryUpload('file', {
    maxFileSize: 512 * 1024, // 512KB for memory processing
    allowedMimeTypes: {
      images: ['image/jpeg', 'image/png']
    }
  }),
  asyncHandler((req, res) => {
    if (!req.file) {
      return res.status(400).json({
        error: 'No file uploaded',
        message: 'Please select a file to upload'
      });
    }

    // File is in memory (req.file.buffer)
    // Process it without saving to disk
    logger.info('File processed in memory', {
      filename: req.file.originalname,
      size: req.file.size,
      mimetype: req.file.mimetype
    });

    res.status(200).json({
      message: 'File processed successfully',
      file: {
        originalName: req.file.originalname,
        size: req.file.size,
        mimetype: req.file.mimetype,
        inMemory: true
      }
    });
  })
);

/**
 * Get upload configuration info
 * GET /api/upload/config
 */
router.get('/config', (req, res) => {
  
  res.status(200).json({
    message: 'Upload configuration',
    config: {
      maxFileSize: `${Math.round(UPLOAD_CONFIG.maxFileSize / 1024 / 1024)}MB`,
      maxTotalSize: `${Math.round(UPLOAD_CONFIG.maxTotalSize / 1024 / 1024)}MB`,
      maxFiles: UPLOAD_CONFIG.maxFiles,
      allowedMimeTypes: UPLOAD_CONFIG.allowedMimeTypes,
      allowedExtensions: UPLOAD_CONFIG.allowedExtensions
    }
  });
});

export default router;


/*──────────────── backend\routes\websiteContent.js ────────────────*/

/**
 * @fileoverview API routes for websiteContent
 * @version 1.0.0
 * @author That Smart Site
 */

import express from 'express';
import { getPool } from '../database/pool.js';
import { withTenantBySlug, getTenantBySlug } from '../middleware/withTenant.js';
import { env } from '../config/env.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { createModuleLogger } from '../config/logger.js';
const router = express.Router();
const logger = createModuleLogger('routeName');


// Save website content for a tenant
router.put('/:slug', withTenantBySlug, asyncHandler(async (req, res) => {
  const contentData = req.body;

  logger.info('💾 Saving website content for tenant:', req.tenant.slug);

  // Update or insert website content using the correct table: website.content
  const upsertQuery = `
    INSERT INTO website.content (
      business_id,
      hero_title, 
      hero_subtitle,
      services_title,
      services_subtitle,
      services_auto_description,
      services_marine_description,
      services_rv_description,
      services_ceramic_description,
      services_correction_description,
      services_ppf_description,
      reviews_title,
      reviews_subtitle,
      reviews_avg_rating,
      reviews_total_count,
      faq_title,
      faq_subtitle,
      faq_items,
      updated_at
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, NOW()
    )
    ON CONFLICT (business_id) 
    DO UPDATE SET
      hero_title = EXCLUDED.hero_title,
      hero_subtitle = EXCLUDED.hero_subtitle,
      services_title = EXCLUDED.services_title,
      services_subtitle = EXCLUDED.services_subtitle,
      services_auto_description = EXCLUDED.services_auto_description,
      services_marine_description = EXCLUDED.services_marine_description,
      services_rv_description = EXCLUDED.services_rv_description,
      services_ceramic_description = EXCLUDED.services_ceramic_description,
      services_correction_description = EXCLUDED.services_correction_description,
      services_ppf_description = EXCLUDED.services_ppf_description,
      reviews_title = EXCLUDED.reviews_title,
      reviews_subtitle = EXCLUDED.reviews_subtitle,
      reviews_avg_rating = EXCLUDED.reviews_avg_rating,
      reviews_total_count = EXCLUDED.reviews_total_count,
      faq_title = EXCLUDED.faq_title,
      faq_subtitle = EXCLUDED.faq_subtitle,
      faq_items = EXCLUDED.faq_items,
      updated_at = NOW()
    RETURNING *
  `;

  const values = [
    req.tenant.id,
    contentData.hero_title || '',
    contentData.hero_subtitle || '',
    contentData.services_title || '',
    contentData.services_subtitle || '',
    contentData.services_auto_description || '',
    contentData.services_marine_description || '',
    contentData.services_rv_description || '',
    contentData.services_ceramic_description || '',
    contentData.services_correction_description || '',
    contentData.services_ppf_description || '',
    contentData.reviews_title || '',
    contentData.reviews_subtitle || '',
    contentData.reviews_avg_rating || 0,
    contentData.reviews_total_count || 0,
    contentData.faq_title || '',
    contentData.faq_subtitle || '',
    JSON.stringify(contentData.faq_items || [])
  ];

  const result = await pool.query(upsertQuery, values);
  
  logger.info('✅ Website content saved successfully');

  res.json({ 
    success: true, 
    message: 'Website content saved successfully',
    content: result.rows[0]
  });
}));

// Get website content for a tenant
router.get('/:slug', asyncHandler(async (req, res) => {
  const { slug } = req.params;
  let tenant;
  try {
    tenant = await getTenantBySlug(slug);
  } catch (e) {
    // In development, gracefully return default content if tenant missing
    if (env.NODE_ENV !== 'production') {
      return res.json({
        success: true,
        content: {
          hero_title: '',
          hero_subtitle: '',
          services_title: '',
          services_subtitle: '',
          services_auto_description: '',
          services_marine_description: '',
          services_rv_description: '',
          services_ceramic_description: '',
          services_correction_description: '',
          services_ppf_description: '',
          reviews_title: '',
          reviews_subtitle: '',
          reviews_avg_rating: 0,
          reviews_total_count: 0,
          faq_title: '',
          faq_subtitle: '',
          faq_items: []
        }
      });
    }
    throw e;
  }

  req.tenant = tenant;
  logger.info('🔍 Fetching website content for tenant:', req.tenant.slug);

  // Query from the correct table: website.content
  const contentResult = await pool.query(
    `SELECT * FROM website.content WHERE business_id = $1`, 
    [req.tenant.id]
  );
  
  logger.info('🔍 Query result:', {
    rowCount: contentResult.rows.length,
    tenant: req.tenant.slug
  });

  if (contentResult.rows.length === 0) {
    logger.info('🔍 No data found for tenant, returning defaults');
    // Return default content structure
    return res.json({
      success: true,
      content: {
        hero_title: '',
        hero_subtitle: '',
        services_title: '',
        services_subtitle: '',
        services_auto_description: '',
        services_marine_description: '',
        services_rv_description: '',
        services_ceramic_description: '',
        services_correction_description: '',
        services_ppf_description: '',
        reviews_title: '',
        reviews_subtitle: '',
        reviews_avg_rating: 0,
        reviews_total_count: 0,
        faq_title: '',
        faq_subtitle: '',
        faq_items: []
      }
    });
  }

  const content = contentResult.rows[0];

  const result = {
    success: true,
    content: {
      hero_title: content.hero_title || '',
      hero_subtitle: content.hero_subtitle || '',
      services_title: content.services_title || '',
      services_subtitle: content.services_subtitle || '',
      services_auto_description: content.services_auto_description || '',
      services_marine_description: content.services_marine_description || '',
      services_rv_description: content.services_rv_description || '',
      services_ceramic_description: content.services_ceramic_description || '',
      services_correction_description: content.services_correction_description || '',
      services_ppf_description: content.services_ppf_description || '',
      reviews_title: content.reviews_title || '',
      reviews_subtitle: content.reviews_subtitle || '',
      reviews_avg_rating: content.reviews_avg_rating || 0,
      reviews_total_count: content.reviews_total_count || 0,
      faq_title: content.faq_title || '',
      faq_subtitle: content.faq_subtitle || '',
      faq_items: content.faq_items || []
    }
  };

  res.json(result);
}));

// Get website content for main site (no tenant)
router.get('/main', (req, res) => {
  try {
    // For main site, we could use a special tenant ID or return default content
    // For now, let's return default content
    const result = {
      success: true,
      content: {
        hero_title: 'Professional Mobile Detailing Services',
        hero_subtitle: 'Bringing the shine to your doorstep',
        reviews_title: 'Customer Reviews',
        reviews_description: 'What our customers say about our services',
        reviews_avg_rating: 0,
        reviews_total_ratings: 0,
        faq_title: 'Frequently Asked Questions',
        faq_description: 'Common questions about our services',
        gallery_title: 'Our Gallery',
        gallery_description: 'See our work in action'
      }
    };

    res.json(result);
  } catch (error) {
    logger.error('Error fetching main site content:', error);
    res.status(500).json({ error: 'Failed to fetch main site content' });
  }
});

export default router;


/*──────────────── backend\controllers\authController.js ────────────────*/

import * as authService from '../services/authService.js'
import { AUTH_CONFIG } from '../config/auth.js'
import { createModuleLogger } from '../config/logger.js'

const logger = createModuleLogger('authController')

/**
 * Auth Controller
 * Handles HTTP requests and responses for authentication operations
 */

/**
 * Check if email exists
 */
async function checkEmail(req, res) {
  const { email } = req.query;
  
  const exists = await authService.checkEmailExists(email);
  
  res.json({
    success: true,
    exists
  });
}

/**
 * Register new user
 */
async function register(req, res) {
  const userData = req.body;
  const userAgent = req.get('User-Agent');
  const ipAddress = req.ip;
  
  const result = await authService.registerUser(userData, userAgent, ipAddress);
  
  // Set HttpOnly cookies for enhanced security
  res.cookie('access_token', result.tokens.accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    path: '/',
    maxAge: 15 * 60 * 1000 // 15 minutes (matches access token expiry)
  });
  
  res.cookie(AUTH_CONFIG.REFRESH_COOKIE_NAME, result.tokens.refreshToken, AUTH_CONFIG.getRefreshCookieOptions())
  
  res.status(201).json({
    success: true,
    user: result.user,
    accessToken: result.tokens.accessToken,
    refreshToken: result.tokens.refreshToken,
    expiresIn: result.tokens.expiresIn,
    refreshExpiresIn: result.tokens.refreshExpiresIn
  });
}

/**
 * Login user
 */
async function login(req, res) {
  logger.info({
    event: 'login_attempt',
    email: req.body.email,
    userAgent: req.get('User-Agent'),
    ip: req.ip
  }, 'Login attempt initiated');
  
  const credentials = req.body;
  const userAgent = req.get('User-Agent');
  const ipAddress = req.ip;
  
  try {
    const result = await authService.loginUser(credentials, userAgent, ipAddress);
    logger.info({
      event: 'login_success',
      email: credentials.email,
      userId: result.user.id
    }, 'Login successful');
    
    // Set HttpOnly cookies for enhanced security
    res.cookie('access_token', result.tokens.accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      path: '/',
      maxAge: 15 * 60 * 1000 // 15 minutes (matches access token expiry)
    });
    
    res.cookie(AUTH_CONFIG.REFRESH_COOKIE_NAME, result.tokens.refreshToken, AUTH_CONFIG.getRefreshCookieOptions())
    
    res.json({
      success: true,
      user: result.user,
      accessToken: result.tokens.accessToken,
      refreshToken: result.tokens.refreshToken,
      expiresIn: result.tokens.expiresIn,
      refreshExpiresIn: result.tokens.refreshExpiresIn
    });
  } catch (error) {
    logger.error({
      event: 'login_error',
      email: credentials.email,
      error: error.message,
      stack: error.stack
    }, 'Login failed');
    throw error;
  }
}

/**
 * Refresh access token
 */
async function refreshToken(req, res) {
  const { refreshToken: token } = req.body;
  const userAgent = req.get('User-Agent');
  const ipAddress = req.ip;
  
  const result = await authService.refreshAccessToken(token, userAgent, ipAddress);
  
  res.json({
    success: true,
    message: 'Token refreshed successfully',
    data: result
  });
}

/**
 * Logout user
 */
async function logout(req, res) {
  const { refreshToken: token } = req.body;
  const userAgent = req.get('User-Agent');
  const ipAddress = req.ip;
  
  await authService.logoutUser(token, userAgent, ipAddress);
  
  res.json({
    success: true,
    message: 'Logout successful'
  });
}

/**
 * Logout all devices
 */
async function logoutAll(req, res) {
  const userId = req.user.userId;
  
  await authService.logoutAllDevices(userId);
  
  res.json({
    success: true,
    message: 'All devices logged out successfully'
  });
}

/**
 * Get user tokens
 */
async function getUserTokens(req, res) {
  const userId = req.user.userId;
  
  const tokens = await authService.getUserTokenList(userId);
  
  res.json({
    success: true,
    data: tokens
  });
}

/**
 * Revoke device token
 */
async function revokeDevice(req, res) {
  const userId = req.user.userId;
  const { deviceId } = req.params;
  
  await authService.revokeDeviceTokenById(userId, deviceId);
  
  res.json({
    success: true,
    message: 'Device logged out successfully'
  });
}

/**
 * Get user profile
 */
async function getProfile(req, res) {
  const userId = req.user.userId;
  
  const user = await authService.getUserProfile(userId);
  
  res.json({
    success: true,
    data: user
  });
}

/**
 * Update user profile
 */
async function updateProfile(req, res) {
  const userId = req.user.userId;
  const updateData = req.body;
  
  const user = await authService.updateUserProfile(userId, updateData);
  
  res.json({
    success: true,
    message: 'Profile updated successfully',
    data: user
  });
}

/**
 * Change password
 */
async function changePassword(req, res) {
  const userId = req.user.userId;
  const { currentPassword, newPassword } = req.body;
  
  await authService.changePassword(userId, currentPassword, newPassword);
  
  res.json({
    success: true,
    message: 'Password changed successfully'
  });
}

export {
  checkEmail,
  register,
  login,
  refreshToken,
  logout,
  logoutAll,
  getUserTokens,
  revokeDevice,
  getProfile,
  updateProfile,
  changePassword
};


/*──────────────── backend\controllers\domainController.js ────────────────*/

/**
 * Domain Controller
 * Handles HTTP requests for custom domain management
 * 
 * Endpoints:
 * - GET /api/domains/:domain - Lookup tenant by domain
 * - PUT /api/domains/:tenantId - Set custom domain
 * - DELETE /api/domains/:tenantId - Remove domain
 * - GET /api/domains/:tenantId/status - Get domain status
 * - POST /api/domains/:tenantId/verify - Verify domain
 */

import * as domainService from '../services/domainService.js';
import { createModuleLogger } from '../config/logger.js';

const logger = createModuleLogger('domainController');

/**
 * GET /api/domains/:domain
 * Look up a tenant by its custom domain
 */
export async function getDomainTenant(req, res) {
  try {
    const { domain } = req.params;
    
    if (!domain) {
      return res.status(400).json({ 
        success: false,
        error: 'Domain parameter is required' 
      });
    }

    const tenant = await domainService.getTenantByDomain(domain);
    
    if (!tenant) {
      return res.status(404).json({ 
        success: false,
        error: 'Domain not found' 
      });
    }

    // Return only safe tenant data (exclude sensitive fields)
    const safeTenant = {
      id: tenant.id,
      slug: tenant.slug,
      business_name: tenant.business_name,
      custom_domain: tenant.custom_domain,
      domain_verified: tenant.domain_verified,
      ssl_enabled: tenant.ssl_enabled,
      domain_added_at: tenant.domain_added_at
    };

    logger.info({
      event: 'domain_tenant_lookup',
      domain,
      tenantId: tenant.id
    }, 'Tenant found by domain');

    res.json({
      success: true,
      data: safeTenant
    });
  } catch (error) {
    logger.error({
      event: 'domain_tenant_lookup_error',
      domain: req.params.domain,
      error: error.message
    }, 'Failed to lookup tenant by domain');
    
    res.status(500).json({ 
      success: false,
      error: 'Failed to lookup tenant by domain' 
    });
  }
}

/**
 * PUT /api/domains/:tenantId
 * Assign or update a custom domain for tenant
 */
export async function setCustomDomain(req, res) {
  try {
    const { tenantId } = req.params;
    const { customDomain } = req.body;

    if (!customDomain) {
      return res.status(400).json({ 
        success: false,
        error: 'customDomain is required' 
      });
    }

    // Check if domain is already in use
    const isAvailable = await domainService.isDomainAvailable(customDomain, tenantId);
    if (!isAvailable) {
      return res.status(409).json({ 
        success: false,
        error: 'Domain is already in use by another tenant' 
      });
    }

    const tenant = await domainService.setTenantDomain(tenantId, customDomain);

    logger.info({
      event: 'custom_domain_set',
      tenantId,
      customDomain
    }, 'Custom domain set for tenant');

    res.json({
      success: true,
      data: {
        id: tenant.id,
        slug: tenant.slug,
        business_name: tenant.business_name,
        custom_domain: tenant.custom_domain,
        domain_verified: tenant.domain_verified,
        ssl_enabled: tenant.ssl_enabled,
        domain_added_at: tenant.domain_added_at
      }
    });
  } catch (error) {
    logger.error({
      event: 'custom_domain_set_error',
      tenantId: req.params.tenantId,
      customDomain: req.body.customDomain,
      error: error.message
    }, 'Failed to set custom domain');
    
    res.status(500).json({ 
      success: false,
      error: 'Failed to set custom domain' 
    });
  }
}

/**
 * DELETE /api/domains/:tenantId
 * Remove a custom domain from a tenant
 */
export async function removeCustomDomain(req, res) {
  try {
    const { tenantId } = req.params;
    
    const tenant = await domainService.removeTenantDomain(tenantId);

    logger.info({
      event: 'custom_domain_removed',
      tenantId
    }, 'Custom domain removed from tenant');

    res.json({
      success: true,
      data: {
        id: tenant.id,
        slug: tenant.slug,
        business_name: tenant.business_name,
        custom_domain: tenant.custom_domain,
        domain_verified: tenant.domain_verified,
        ssl_enabled: tenant.ssl_enabled
      }
    });
  } catch (error) {
    logger.error({
      event: 'custom_domain_removal_error',
      tenantId: req.params.tenantId,
      error: error.message
    }, 'Failed to remove custom domain');
    
    res.status(500).json({ 
      success: false,
      error: 'Failed to remove custom domain' 
    });
  }
}

/**
 * GET /api/domains/:tenantId/status
 * Get verification/SSL status for a tenant domain
 */
export async function getDomainStatus(req, res) {
  try {
    const { tenantId } = req.params;
    
    const status = await domainService.getDomainStatus(tenantId);
    
    if (!status) {
      return res.status(404).json({ 
        success: false,
        error: 'Tenant not found' 
      });
    }

    logger.info({
      event: 'domain_status_requested',
      tenantId,
      hasCustomDomain: !!status.custom_domain
    }, 'Domain status requested');

    res.json({
      success: true,
      data: status
    });
  } catch (error) {
    logger.error({
      event: 'domain_status_error',
      tenantId: req.params.tenantId,
      error: error.message
    }, 'Failed to get domain status');
    
    res.status(500).json({ 
      success: false,
      error: 'Failed to get domain status' 
    });
  }
}

/**
 * POST /api/domains/:tenantId/verify
 * Verify domain ownership (placeholder for future DNS verification)
 */
export async function verifyDomain(req, res) {
  try {
    const { tenantId } = req.params;
    
    // For now, just mark as verified (in production, you'd verify DNS records)
    const tenant = await domainService.updateDomainVerification(tenantId, true);

    logger.info({
      event: 'domain_verification_requested',
      tenantId
    }, 'Domain verification requested');

    res.json({
      success: true,
      data: {
        id: tenant.id,
        custom_domain: tenant.custom_domain,
        domain_verified: tenant.domain_verified,
        message: 'Domain verification completed (placeholder)'
      }
    });
  } catch (error) {
    logger.error({
      event: 'domain_verification_error',
      tenantId: req.params.tenantId,
      error: error.message
    }, 'Failed to verify domain');
    
    res.status(500).json({ 
      success: false,
      error: 'Failed to verify domain' 
    });
  }
}

/**
 * GET /api/domains/:domain/available
 * Check if a domain is available for use
 */
export async function checkDomainAvailability(req, res) {
  try {
    const { domain } = req.params;
    const { excludeTenantId } = req.query;
    
    if (!domain) {
      return res.status(400).json({ 
        success: false,
        error: 'Domain parameter is required' 
      });
    }

    const isAvailable = await domainService.isDomainAvailable(domain, excludeTenantId);

    logger.info({
      event: 'domain_availability_checked',
      domain,
      isAvailable,
      excludeTenantId
    }, 'Domain availability checked');

    res.json({
      success: true,
      data: {
        domain,
        available: isAvailable
      }
    });
  } catch (error) {
    logger.error({
      event: 'domain_availability_error',
      domain: req.params.domain,
      error: error.message
    }, 'Failed to check domain availability');
    
    res.status(500).json({ 
      success: false,
      error: 'Failed to check domain availability' 
    });
  }
}


/*──────────────── backend\controllers\passwordResetController.js ────────────────*/

/**
 * Password Reset Controller
 * Handles password reset request and reset endpoints
 */

import * as passwordResetService from '../services/passwordResetService.js';
import { asyncHandler } from '../middleware/errorHandler.js';

/**
 * Request password reset
 * POST /api/auth/request-password-reset
 */
const requestPasswordReset = asyncHandler(async (req, res) => {
  const { email } = req.body;
  const ipAddress = req.ip;
  const userAgent = req.get('User-Agent');

  try {
    await passwordResetService.requestPasswordReset(email, ipAddress, userAgent);

    res.json({
      success: true,
      message: 'If an account with that email exists, a password reset link has been sent.'
    });
  } catch (err) {
    // Don't reveal specific error details for security
    if (err.message.includes('rate limit') || err.message.includes('Too many')) {
      res.status(429).json({
        success: false,
        message: 'Too many reset attempts. Please try again later.'
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'An error occurred while processing your request. Please try again.'
      });
    }
  }
});

/**
 * Reset password with token
 * POST /api/auth/reset-password
 */
const resetPassword = asyncHandler(async (req, res) => {
  const { token, newPassword } = req.body;
  const ipAddress = req.ip;

  try {
    await passwordResetService.resetPassword(token, newPassword, ipAddress);

    res.json({
      success: true,
      message: 'Password has been reset successfully. Please log in with your new password.'
    });
  } catch (err) {
    if (err.message.includes('Invalid or expired')) {
      res.status(400).json({
        success: false,
        message: 'Invalid or expired reset token. Please request a new password reset.'
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'An error occurred while resetting your password. Please try again.'
      });
    }
  }
});

/**
 * Validate reset token
 * GET /api/auth/validate-reset-token?token=...
 */
const validateResetToken = asyncHandler(async (req, res) => {
  const { token } = req.query;

  if (!token) {
    return res.status(400).json({
      success: false,
      message: 'Reset token is required'
    });
  }

  try {
    const tokenInfo = await passwordResetService.validateResetToken(token);

    if (!tokenInfo) {
      return res.status(400).json({
        success: false,
        message: 'Invalid or expired reset token'
      });
    }

    res.json({
      success: true,
      valid: true,
      email: tokenInfo.email,
      name: tokenInfo.name,
      expiresAt: tokenInfo.expiresAt
    });
  } catch {
    res.status(500).json({
      success: false,
      message: 'An error occurred while validating the reset token'
    });
  }
});

/**
 * Get password reset statistics (admin only)
 * GET /api/auth/reset-stats
 */
const getResetStats = asyncHandler(async (req, res) => {
  // This should be protected by admin middleware
  if (!req.user || !req.user.isAdmin) {
    return res.status(403).json({
      success: false,
      message: 'Admin access required'
    });
  }

  try {
    const stats = await passwordResetService.getResetTokenStats();

    res.json({
      success: true,
      data: stats
    });
  } catch {
    res.status(500).json({
      success: false,
      message: 'An error occurred while fetching reset statistics'
    });
  }
});

export {
  requestPasswordReset,
  resetPassword,
  validateResetToken,
  getResetStats
};


/*──────────────── backend\controllers\passwordSetupController.js ────────────────*/

/**
 * Password Setup Controller
 * Handles password setup for new users with token validation
 */

import * as passwordSetupService from '../services/passwordSetupService.js';
import { asyncHandler } from '../middleware/errorHandler.js';

/**
 * Create password setup token for new user
 * POST /api/auth/create-password-setup
 */
const createPasswordSetup = asyncHandler(async (req, res) => {
  const { userId, email } = req.body;
  const ipAddress = req.ip;
  const userAgent = req.get('User-Agent');

  if (!userId || !email) {
    return res.status(400).json({
      success: false,
      message: 'User ID and email are required'
    });
  }

  try {
    const result = await passwordSetupService.createPasswordSetupToken(
      userId, 
      email, 
      ipAddress, 
      userAgent
    );

    res.json({
      success: true,
      message: 'Password setup token created successfully',
      data: {
        setupUrl: result.setupUrl,
        expiresAt: result.expiresAt,
        email: result.email,
        name: result.name
      }
    });
  } catch (err) {
    if (err.message.includes('rate limit') || err.message.includes('Too many')) {
      res.status(429).json({
        success: false,
        message: 'Too many setup attempts. Please contact support.'
      });
    } else if (err.message.includes('already has a password')) {
      res.status(400).json({
        success: false,
        message: 'User already has a password set'
      });
    } else if (err.message.includes('not found')) {
      res.status(404).json({
        success: false,
        message: 'User not found'
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'An error occurred while creating the setup token. Please try again.'
      });
    }
  }
});

/**
 * Set password using setup token
 * POST /api/auth/setup-password
 */
const setupPassword = asyncHandler(async (req, res) => {
  const { token, newPassword } = req.body;
  const ipAddress = req.ip;

  if (!token || !newPassword) {
    return res.status(400).json({
      success: false,
      message: 'Token and new password are required'
    });
  }

  // Basic password validation
  if (newPassword.length < 8) {
    return res.status(400).json({
      success: false,
      message: 'Password must be at least 8 characters long'
    });
  }

  try {
    await passwordSetupService.setPasswordWithToken(token, newPassword, ipAddress);

    res.json({
      success: true,
      message: 'Password has been set successfully. You can now log in with your new password.'
    });
  } catch (err) {
    if (err.message.includes('Invalid or expired')) {
      res.status(400).json({
        success: false,
        message: 'Invalid or expired setup token. Please request a new password setup.'
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'An error occurred while setting your password. Please try again.'
      });
    }
  }
});

/**
 * Validate setup token
 * GET /api/auth/validate-setup-token?token=...
 */
const validateSetupToken = asyncHandler(async (req, res) => {
  const { token } = req.query;

  if (!token) {
    return res.status(400).json({
      success: false,
      message: 'Setup token is required'
    });
  }

  try {
    const tokenInfo = await passwordSetupService.validateSetupToken(token);

    if (!tokenInfo) {
      return res.status(400).json({
        success: false,
        message: 'Invalid or expired setup token'
      });
    }

    res.json({
      success: true,
      valid: true,
      email: tokenInfo.email,
      name: tokenInfo.name,
      expiresAt: tokenInfo.expiresAt
    });
  } catch {
    res.status(500).json({
      success: false,
      message: 'An error occurred while validating the setup token'
    });
  }
});

/**
 * Get setup token statistics (admin only)
 * GET /api/auth/setup-stats
 */
const getSetupStats = asyncHandler(async (req, res) => {
  // This should be protected by admin middleware
  if (!req.user || !req.user.isAdmin) {
    return res.status(403).json({
      success: false,
      message: 'Admin access required'
    });
  }

  try {
    const stats = await passwordSetupService.getSetupTokenStats();

    res.json({
      success: true,
      data: stats
    });
  } catch {
    res.status(500).json({
      success: false,
      message: 'An error occurred while fetching setup statistics'
    });
  }
});

export {
  createPasswordSetup,
  setupPassword,
  validateSetupToken,
  getSetupStats
};


/*──────────────── backend\controllers\tenantController.js ────────────────*/

import * as tenantService from '../services/tenantService.js';
import { createModuleLogger } from '../config/logger.js';
const logger = createModuleLogger('tenantController');



/**
 * Tenant Controller
 * Handles HTTP requests and responses for tenant operations
 */

/**
 * Create new tenant account
 */
async function createTenant(req, res) {
  const tenantData = req.body;
  
  const result = await tenantService.createTenant(tenantData);
  
  // Log tenant creation for now (TODO: Send welcome email)
  logger.info('\n=== NEW TENANT SIGNUP ===');
  logger.info(`Business: ${tenantData.businessName}`);
  logger.info(`Owner: ${tenantData.firstName} ${tenantData.lastName}`);
  logger.info(`Email: ${tenantData.personalEmail}`);
  logger.info(`Slug: ${result.slug}`);
  logger.info(`Website URL: ${process.env.FRONTEND_URL || 'http://localhost:5173'}${result.websiteUrl}`);
  logger.info(`Dashboard URL: ${process.env.FRONTEND_URL || 'http://localhost:5173'}${result.dashboardUrl}`);
  logger.info(`Plan: ${tenantData.selectedPlan} ($${tenantData.planPrice}/month)`);
  logger.info('========================\n');

  res.status(201).json({
    success: true,
    message: 'Account created successfully',
    data: result
  });
}

/**
 * Get tenant by slug
 */
async function getTenantBySlug(req, res) {
  const { slug } = req.params;
  
  const tenant = await tenantService.getTenantBySlug(slug);
  
  if (!tenant) {
    return res.status(404).json({
      success: false,
      error: 'Tenant not found or not approved'
    });
  }
  
  res.json({
    success: true,
    data: tenant
  });
}

/**
 * Get tenants by industry
 */
async function getTenantsByIndustry(req, res) {
  const { industry, status = 'approved' } = req.query;
  
  const tenants = await tenantService.getTenantsByIndustry(industry, status);
  
  res.json({
    success: true,
    data: tenants
  });
}

/**
 * Update tenant business data by slug
 */
async function updateTenantBySlug(req, res) {
  const { slug } = req.params;
  const updateData = req.body;
  
  try {
    const updatedTenant = await tenantService.updateTenantBySlug(slug, updateData);
    
    res.json({
      success: true,
      data: updatedTenant,
      message: 'Business profile updated successfully'
    });
  } catch (error) {
    logger.error('Error updating tenant:', error);
    
    if (error.message === 'Tenant not found or not approved') {
      return res.status(404).json({
        success: false,
        error: 'Tenant not found or not approved'
      });
    }
    
    if (error.message === 'No valid fields to update') {
      return res.status(400).json({
        success: false,
        error: 'No valid fields to update'
      });
    }
    
    res.status(500).json({
      success: false,
      error: 'Failed to update business profile',
      message: error.message
    });
  }
}

/**
 * Get list of available industries
 */
async function getIndustries(req, res) {
  const industries = await tenantService.getIndustries();
  
  res.json({
    success: true,
    data: industries
  });
}

export {
  createTenant,
  getTenantBySlug,
  getTenantsByIndustry,
  getIndustries,
  updateTenantBySlug
};


/*──────────────── backend\controllers\tenantDashboardController.js ────────────────*/

/**
 * Tenant Dashboard Controller
 * 
 * Handles HTTP requests for tenant dashboard analytics and aggregated data.
 */

import * as tenantAnalyticsService from '../services/tenantAnalyticsService.js';
import { generateTenantApiResponse, generateTenantErrorResponse } from '../utils/tenantContextContract.js';
import { createModuleLogger } from '../config/logger.js';

const logger = createModuleLogger('tenantDashboardController');

/**
 * GET /api/tenants/:tenantSlug/dashboard
 * Get comprehensive dashboard analytics for a tenant
 */
async function getTenantDashboard(req, res) {
  try {
    const { tenantSlug } = req.params;
    const { dateRange = '30d', includeDetails = false } = req.query;

    logger.info('Fetching tenant dashboard', { 
      tenantSlug, 
      dateRange, 
      requestId: req.id 
    });

    // Validate date range
    const validDateRanges = ['7d', '30d', '90d', '1y'];
    if (!validDateRanges.includes(dateRange)) {
      return res.status(400).json(generateTenantErrorResponse({
        code: 'INVALID_DATE_RANGE',
        message: 'Invalid date range. Must be one of: 7d, 30d, 90d, 1y'
      }, { requestId: req.id }));
    }

    // Get tenant ID from context (set by withTenant middleware)
    if (!req.tenant || !req.tenant.id) {
      return res.status(400).json(generateTenantErrorResponse({
        code: 'NO_TENANT_CONTEXT',
        message: 'Tenant context not available'
      }, { requestId: req.id }));
    }

    const tenantId = req.tenant.id;
    const options = {
      dateRange,
      includeDetails: includeDetails === 'true'
    };

    // Get dashboard analytics
    const dashboardData = await tenantAnalyticsService.getTenantDashboardAnalytics(
      tenantId, 
      options
    );

    // Add request metadata
    dashboardData.meta = {
      requestId: req.id,
      generatedAt: new Date().toISOString(),
      tenantSlug,
      dateRange,
      includeDetails: options.includeDetails
    };

    logger.info('Tenant dashboard generated successfully', { 
      tenantSlug, 
      tenantId,
      requestId: req.id,
      dataPoints: Object.keys(dashboardData).length 
    });

    res.json(generateTenantApiResponse(dashboardData, {
      requestId: req.id,
      tenantSlug,
      dateRange
    }));

  } catch (error) {
    logger.error('Error fetching tenant dashboard', { 
      tenantSlug: req.params.tenantSlug,
      error: error.message,
      requestId: req.id 
    });

    const statusCode = error.statusCode || 500;
    const errorCode = error.code || 'DASHBOARD_ERROR';

    res.status(statusCode).json(generateTenantErrorResponse({
      code: errorCode,
      message: error.message || 'Failed to fetch tenant dashboard'
    }, { requestId: req.id }));
  }
}

/**
 * GET /api/tenants/:tenantSlug/dashboard/overview
 * Get basic tenant overview stats
 */
async function getTenantOverview(req, res) {
  try {
    const { tenantSlug } = req.params;
    const { dateRange = '30d' } = req.query;

    if (!req.tenant || !req.tenant.id) {
      return res.status(400).json(generateTenantErrorResponse({
        code: 'NO_TENANT_CONTEXT',
        message: 'Tenant context not available'
      }, { requestId: req.id }));
    }

    const tenantId = req.tenant.id;
    const dateFilter = getDateFilter(dateRange);

    const basicStats = await tenantAnalyticsService.getBasicTenantStats(
      tenantId, 
      dateFilter
    );

    res.json(generateTenantApiResponse(basicStats, {
      requestId: req.id,
      tenantSlug,
      dateRange
    }));

  } catch (error) {
    logger.error('Error fetching tenant overview', { 
      tenantSlug: req.params.tenantSlug,
      error: error.message,
      requestId: req.id 
    });

    res.status(error.statusCode || 500).json(generateTenantErrorResponse({
      code: error.code || 'OVERVIEW_ERROR',
      message: error.message || 'Failed to fetch tenant overview'
    }, { requestId: req.id }));
  }
}

/**
 * GET /api/tenants/:tenantSlug/dashboard/reviews
 * Get detailed review analytics
 */
async function getTenantReviews(req, res) {
  try {
    const { tenantSlug } = req.params;
    const { dateRange = '30d', limit = 10, offset = 0 } = req.query;

    if (!req.tenant || !req.tenant.id) {
      return res.status(400).json(generateTenantErrorResponse({
        code: 'NO_TENANT_CONTEXT',
        message: 'Tenant context not available'
      }, { requestId: req.id }));
    }

    const tenantId = req.tenant.id;
    const dateFilter = getDateFilter(dateRange);

    const reviewStats = await tenantAnalyticsService.getReviewAnalytics(
      tenantId, 
      dateFilter
    );

    // Apply pagination to recent reviews
    const paginatedReviews = reviewStats.recentReviews.slice(
      parseInt(offset), 
      parseInt(offset) + parseInt(limit)
    );

    const responseData = {
      ...reviewStats,
      recentReviews: paginatedReviews,
      pagination: {
        total: reviewStats.recentReviews.length,
        limit: parseInt(limit),
        offset: parseInt(offset),
        hasMore: (parseInt(offset) + parseInt(limit)) < reviewStats.recentReviews.length
      }
    };

    res.json(generateTenantApiResponse(responseData, {
      requestId: req.id,
      tenantSlug,
      dateRange
    }));

  } catch (error) {
    logger.error('Error fetching tenant reviews', { 
      tenantSlug: req.params.tenantSlug,
      error: error.message,
      requestId: req.id 
    });

    res.status(error.statusCode || 500).json(generateTenantErrorResponse({
      code: error.code || 'REVIEWS_ERROR',
      message: error.message || 'Failed to fetch tenant reviews'
    }, { requestId: req.id }));
  }
}

/**
 * GET /api/tenants/:tenantSlug/dashboard/performance
 * Get performance analytics
 */
async function getTenantPerformance(req, res) {
  try {
    const { tenantSlug } = req.params;
    const { dateRange = '30d' } = req.query;

    if (!req.tenant || !req.tenant.id) {
      return res.status(400).json(generateTenantErrorResponse({
        code: 'NO_TENANT_CONTEXT',
        message: 'Tenant context not available'
      }, { requestId: req.id }));
    }

    const tenantId = req.tenant.id;
    const dateFilter = getDateFilter(dateRange);

    const performanceStats = await tenantAnalyticsService.getPerformanceAnalytics(
      tenantId, 
      dateFilter
    );

    res.json(generateTenantApiResponse(performanceStats, {
      requestId: req.id,
      tenantSlug,
      dateRange
    }));

  } catch (error) {
    logger.error('Error fetching tenant performance', { 
      tenantSlug: req.params.tenantSlug,
      error: error.message,
      requestId: req.id 
    });

    res.status(error.statusCode || 500).json(generateTenantErrorResponse({
      code: error.code || 'PERFORMANCE_ERROR',
      message: error.message || 'Failed to fetch tenant performance'
    }, { requestId: req.id }));
  }
}

/**
 * GET /api/tenants/:tenantSlug/dashboard/activity
 * Get recent activity summary
 */
async function getTenantActivity(req, res) {
  try {
    const { tenantSlug } = req.params;
    const { dateRange = '30d', limit = 20 } = req.query;

    if (!req.tenant || !req.tenant.id) {
      return res.status(400).json(generateTenantErrorResponse({
        code: 'NO_TENANT_CONTEXT',
        message: 'Tenant context not available'
      }, { requestId: req.id }));
    }

    const tenantId = req.tenant.id;
    const dateFilter = getDateFilter(dateRange);

    const activityStats = await tenantAnalyticsService.getRecentActivity(
      tenantId, 
      dateFilter
    );

    // Limit activities
    const limitedActivities = activityStats.activities.slice(0, parseInt(limit));

    const responseData = {
      ...activityStats,
      activities: limitedActivities
    };

    res.json(generateTenantApiResponse(responseData, {
      requestId: req.id,
      tenantSlug,
      dateRange
    }));

  } catch (error) {
    logger.error('Error fetching tenant activity', { 
      tenantSlug: req.params.tenantSlug,
      error: error.message,
      requestId: req.id 
    });

    res.status(error.statusCode || 500).json(generateTenantErrorResponse({
      code: error.code || 'ACTIVITY_ERROR',
      message: error.message || 'Failed to fetch tenant activity'
    }, { requestId: req.id }));
  }
}

/**
 * Helper function to get date filter
 */
function getDateFilter(dateRange) {
  const now = new Date();
  let startDate;

  switch (dateRange) {
    case '7d':
      startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      break;
    case '30d':
      startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      break;
    case '90d':
      startDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
      break;
    case '1y':
      startDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
      break;
    default:
      startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
  }

  return {
    startDate: startDate.toISOString(),
    endDate: now.toISOString(),
    range: dateRange
  };
}

export {
  getTenantDashboard,
  getTenantOverview,
  getTenantReviews,
  getTenantPerformance,
  getTenantActivity
};


/*──────────────── scripts\audits\audit-seo.js ────────────────*/

#!/usr/bin/env node
/**
 * audit-seo.js — Full Unified SEO Audit
 * --------------------------------------------------------------
 * ✅ Combines:
 *  - Auto-build if missing or outdated
 *  - Enhanced Schema Detection (static, JS, and source)
 *  - Lighthouse Runtime SEO
 *  - HTML Meta Checks
 *  - robots.txt / sitemap.xml verification
 *  - Static SEO & Analytics Code Scan (Helmet, GA, OG, etc.)
 * --------------------------------------------------------------
 * 🧾 Outputs:
 *  - Markdown Report → docs/audits/SEO_AUDIT.md
 *  - CLI Summary → color-coded instant feedback
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { execSync, spawn } from "child_process";
import net from "net";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const root = process.cwd();
const frontendDir = path.join(root, "frontend/src");
const distDir = path.join(root, "frontend/dist");
const publicDir = path.join(root, "frontend/public");

/*──────────────────────────────────────────────────────────────
 🧠 Auto-Build if Missing or Outdated
──────────────────────────────────────────────────────────────*/
function isBuildFresh() {
  if (!fs.existsSync(distDir)) return false;
  const distMtime = fs.statSync(distDir).mtimeMs;

  function getNewestSrcTime(dir) {
    let newest = 0;
    if (!fs.existsSync(dir)) return newest;
    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
      const full = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        newest = Math.max(newest, getNewestSrcTime(full));
      } else if (/\.(t|j)sx?$|\.html$/i.test(entry.name)) {
        const mtime = fs.statSync(full).mtimeMs;
        newest = Math.max(newest, mtime);
      }
    }
    return newest;
  }

  // Check both src/ and public/ directories for changes
  const srcNewest = getNewestSrcTime(frontendDir);
  const publicNewest = getNewestSrcTime(publicDir);
  const newestSourceTime = Math.max(srcNewest, publicNewest);
  
  return newestSourceTime < distMtime;
}

function ensureFreshBuild() {
  console.log("🧠 Checking build status...");
  const fresh = isBuildFresh();

  if (!fresh) {
    console.log("⚙️  Building frontend (auto-detected change)...");
    try {
      execSync("npm run build", { cwd: path.join(root, "frontend"), stdio: "inherit" });

      console.log("✅ Build completed successfully.");
    } catch (err) {
      console.error("❌ Build failed:", err.message);
      process.exit(1);
    }
  } else {
    console.log("✅ Existing build is up to date.");
  }
}

/*──────────────────────────────────────────────────────────────
 🧩 Enhanced Schema Detection
──────────────────────────────────────────────────────────────*/
async function runEnhancedSchemaDetection() {
  console.log("\n🧩 Running Enhanced Schema Detection...\n");
  const res = { score: 0 };

  // Static JSON-LD
  const htmlFiles = fs.existsSync(distDir)
    ? fs.readdirSync(distDir).filter(f => f.endsWith(".html"))
    : [];
  let schemaCount = 0;
  for (const f of htmlFiles) {
    const content = fs.readFileSync(path.join(distDir, f), "utf8");
    const scripts = content.match(/application\/ld\+json[^>]*>[\s\S]*?<\/script>/gi) || [];
    schemaCount += scripts.length;
  }
  if (schemaCount > 0) res.score += 30;

  // Source @type definitions
  let srcSchemaCount = 0;
  function scanSrc(dir) {
    if (!fs.existsSync(dir)) return;
    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
      const full = path.join(dir, entry.name);
      if (entry.isDirectory()) scanSrc(full);
      else if (/\.(t|j)sx?$/.test(entry.name)) {
        const c = fs.readFileSync(full, "utf8");
        if (c.includes("@type") || c.includes("schema.org")) srcSchemaCount++;
      }
    }
  }
  scanSrc(frontendDir);
  if (srcSchemaCount > 0) res.score += 30;

  res.score = Math.min(100, res.score + Math.min(40, schemaCount + srcSchemaCount * 2));
  console.log(`✅ Schema quality score: ${res.score}/100\n`);
  return res;
}

/*──────────────────────────────────────────────────────────────
 🌍 Static SEO & Analytics Scan
──────────────────────────────────────────────────────────────*/
function staticSeoAnalysis() {
  console.log("🧠 Scanning static SEO & analytics code...\n");
  const walk = dir =>
    fs.existsSync(dir)
      ? fs.readdirSync(dir, { withFileTypes: true }).flatMap(e =>
          e.isDirectory() ? walk(path.join(dir, e.name)) : [path.join(dir, e.name)]
        )
      : [];

  const files = walk(frontendDir);
  const backendFiles = walk(path.join(root, "backend"));
  const has = pattern => files.some(f => fs.readFileSync(f, "utf8").match(pattern));

  return {
    helmet: has(/Helmet|Meta|Head/i)
      ? "✅ Helmet components detected"
      : "⚠️ Missing Helmet/meta components",
    analytics: has(/UA-|G-|gtag|googletagmanager/i)
      ? "✅ Google Analytics / GTM found"
      : "⚠️ No analytics code found",
    opengraph: has(/og:|twitter:card|application\/ld/i)
      ? "✅ OpenGraph / JSON-LD present"
      : "⚠️ Missing structured data",
    sitemap: backendFiles.some(f => /sitemap|generate-sitemap/i.test(fs.readFileSync(f, "utf8")))
      ? "✅ Sitemap generation found"
      : "⚠️ No sitemap scripts detected",
    robots: fs.existsSync(path.join(publicDir, "robots.txt"))
      ? "✅ robots.txt found"
      : "⚠️ Missing robots.txt",
  };
}

/*──────────────────────────────────────────────────────────────
 🔗 Endpoint + HTML Meta Checks
──────────────────────────────────────────────────────────────*/
function analyzeHTMLStructure() {
  if (!fs.existsSync(distDir)) return [];
  const htmls = fs
    .readdirSync(distDir)
    .filter(f => f.endsWith(".html"))
    .map(f => {
      const c = fs.readFileSync(path.join(distDir, f), "utf8");
      return {
        file: f,
        hasTitle: /<title/i.test(c),
        hasDescription: /<meta[^>]+description/i.test(c),
      };
    });
  return htmls;
}

function testSEOEndpoints() {
  const endpoints = [];
  const issues = [];
  const add = (label, file) => {
    const exists = fs.existsSync(path.join(root, file));
    (exists ? endpoints : issues).push(
      (exists ? "✅ " : "❌ Missing ") + label
    );
  };
  add("robots.txt route", "backend/routes/seo/robotsRoute.ts");
  add("sitemap.xml route", "backend/routes/seo/sitemapRoute.ts");
  return { endpoints, issues };
}

/*──────────────────────────────────────────────────────────────
 🔌 Port helpers
──────────────────────────────────────────────────────────────*/
function isPortOpen(port, host = "127.0.0.1") {
  return new Promise(resolve => {
    const s = new net.Socket();
    s.setTimeout(800);
    s.once("connect", () => { s.destroy(); resolve(true); });
    s.once("timeout", () => { s.destroy(); resolve(false); });
    s.once("error", () => { resolve(false); });
    s.connect(port, host);
  });
}

async function waitForPort(port, retries = 20, delayMs = 500) {
  for (let i = 0; i < retries; i++) {
    if (await isPortOpen(port)) return true;
    await new Promise(r => setTimeout(r, delayMs));
  }
  return false;
}


/*──────────────────────────────────────────────────────────────
 📈 Lighthouse SEO (auto preview, Windows-safe)
──────────────────────────────────────────────────────────────*/
import util from "util";
import { exec } from "child_process";
const execAsync = util.promisify(exec);

async function runLighthouseSEO() {
  const port = 4173;
  const url = `http://localhost:${port}`;
  const previewDir = path.join(root, "frontend");
  const reportPath = path.join(root, "docs/audits/lighthouse-seo.json");
  let processRef = null;
  let score = null;

  try {
    console.log("🧠 Checking for running preview server...");
    let running = await isPortOpen(port);

    if (!running) {
      if (!fs.existsSync(path.join(previewDir, "dist"))) {
        console.error("❌ No build found in frontend/dist. Run `npm run build` first.");
        process.exit(1);
      }

      console.log("⚙️  Starting temporary Vite preview server...");
      processRef = exec(`npx vite preview --port ${port}`, {
        cwd: previewDir,
        env: process.env,
      });

      const started = await waitForPort(port);
      if (!started) throw new Error("Preview server failed to start.");
      console.log("✅ Preview server started on port", port);
    }

    //────────────────────────────────────────────
    // 🧠 Try Lighthouse (with fallback)
    //────────────────────────────────────────────
    console.log("⚡ Running Lighthouse SEO scan...");
    const lhCmd = `npx lighthouse ${url} --only-categories=seo --output=json --output-path=${reportPath} --quiet --disable-storage-reset --chrome-flags="--headless --no-sandbox --disable-dev-shm-usage --user-data-dir=.tmp_lh/chrome"`;

    try {
      await execAsync(lhCmd, { cwd: root, env: process.env, timeout: 90000 });
      console.log("✅ Lighthouse finished normally.");
    } catch (err) {
      // Handle EPERM or cleanup issues gracefully
      if (/EPERM|Permission denied/i.test(err.message)) {
        console.warn("⚠️  Lighthouse cleanup failed (EPERM). Attempting to use existing JSON report...");
      } else {
        console.warn("⚠️  Lighthouse run failed:", err.message);
      }
    }

    //────────────────────────────────────────────
    // ✅ Parse report (if it exists)
    //────────────────────────────────────────────
    if (fs.existsSync(reportPath)) {
      const json = JSON.parse(fs.readFileSync(reportPath, "utf8"));
      score = Math.round((json.categories?.seo?.score || 0) * 100);
      console.log(`✅ Lighthouse score: ${score}/100`);
    } else {
      console.warn("⚠️  Lighthouse JSON not found — skipping score.");
    }
  } catch (err) {
    console.log("⚠️  Lighthouse skipped:", err.message);
  } finally {
    if (processRef && processRef.kill) {
      console.log("💤 Shutting down preview server...");
      try {
        processRef.kill();
      } catch {
        console.log("⚠️  Could not kill preview server.");
      }
    }
  }

  return score;
}





/*──────────────────────────────────────────────────────────────
 🧾 Reporting
──────────────────────────────────────────────────────────────*/
function printSummary(final, lh, schema, staticSeo, endpoints, html) {
  console.log("\n─────────────────────────────");
  console.log("📊 SEO AUDIT SUMMARY");
  console.log("─────────────────────────────");
  console.log(`Total Score: ${final}/100`);
  console.log(`Lighthouse: ${lh ?? "N/A"}/100`);
  console.log(`Schema Quality: ${schema.score}/100`);
  console.log(
    `HTML Meta: ${
      html.every(h => h.hasTitle && h.hasDescription)
        ? "✅ OK"
        : "⚠️ Missing meta tags"
    }`
  );
  console.log("\n🔎 Static SEO/Analytics:");
  Object.values(staticSeo).forEach(v => console.log("  " + v));
  console.log("\n🔗 Endpoints:");
  endpoints.endpoints.forEach(e => console.log("  " + e));
  endpoints.issues.forEach(e => console.log("  " + e));
  console.log("─────────────────────────────\n");
}

/*──────────────────────────────────────────────────────────────
 🚀 Main Execution
──────────────────────────────────────────────────────────────*/
(async function runSEOAudit() {
  console.log("\n🚀 Running Full SEO Audit...\n");
  ensureFreshBuild();

  const schema = await runEnhancedSchemaDetection();
  const lighthouse = await runLighthouseSEO();
  const staticSeo = staticSeoAnalysis();
  const endpoints = testSEOEndpoints();
  const html = analyzeHTMLStructure();

  let score = 100;
  if (!lighthouse || lighthouse < 80) score -= 10;
  if (schema.score < 80) score -= 10;
  if (html.some(f => !f.hasTitle || !f.hasDescription)) score -= 10;
  if (endpoints.issues.length) score -= endpoints.issues.length * 5;
  const finalScore = Math.max(0, score);

  printSummary(finalScore, lighthouse, schema, staticSeo, endpoints, html);

  const reportPath = path.join(root, "docs/audits/SEO_AUDIT.md");
  fs.mkdirSync(path.dirname(reportPath), { recursive: true });
  const report = `# SEO Audit Report
Generated: ${new Date().toISOString()}

## Score: ${finalScore}/100
- Lighthouse: ${lighthouse ?? "N/A"}/100
- Schema: ${schema.score}/100
- Meta: ${
    html.every(f => f.hasTitle && f.hasDescription) ? "Complete" : "Incomplete"
  }

### Static SEO/Analytics
${Object.values(staticSeo)
  .map(v => "- " + v)
  .join("\n")}

### Endpoints
${endpoints.endpoints.concat(endpoints.issues).map(v => "- " + v).join("\n")}
`;
  fs.writeFileSync(reportPath, report);
  console.log(`✅ SEO audit complete → ${reportPath}\n`);
})();


/*──────────────── backend\middleware\tenantResolver.js ────────────────*/

/**
 * Tenant Resolver Middleware
 * 
 * Detects tenant slug from subdomain and attaches it to the request object.
 * Handles both main domain and subdomain routing for multi-tenant architecture.
 */

export function tenantResolver(req, res, next) {
  const host = req.hostname.toLowerCase();
  
  // Parse the hostname to extract subdomain
  // thatsmartsite.com → main-site
  // testing-mobile-detail.thatsmartsite.com → testing-mobile-detail
  const parts = host.split('.');
  const domain = parts.slice(-2).join('.'); // thatsmartsite.com
  const subdomain = parts.length > 2 ? parts[0] : null;

  // Reserved subdomains that should not be treated as tenant slugs
  const RESERVED_SUBDOMAINS = [
    'www', 'api', 'admin', 'main-site', 'staging', 'dev', 
    'cdn', 'assets', 'static', 'img', 'images', 'media',
    'mail', 'email', 'ftp', 'blog', 'support', 'help',
    'docs', 'status', 'monitoring', 'metrics', 'logs'
  ];
  
  // Determine tenant slug
  if (subdomain && !RESERVED_SUBDOMAINS.includes(subdomain)) {
    req.tenantSlug = subdomain;
  } else {
    req.tenantSlug = 'main-site'; // Default to main site for admin dashboard
  }

  // Add tenant info to request for logging/debugging
  req.tenantInfo = {
    hostname: host,
    subdomain,
    domain,
    tenantSlug: req.tenantSlug,
    isMainSite: req.tenantSlug === 'main-site'
  };

  next();
}


/*──────────────── backend\middleware\withTenant.js ────────────────*/

import { getPool } from '../database/pool.js';
import { asyncHandler } from './errorHandler.js';
import { createModuleLogger } from '../config/logger.js';
import { 
  transformBusinessToTenantInfo, 
  validateTenantContext, 
  attachTenantContext 
} from '../utils/tenantContextContract.js';

const logger = createModuleLogger('withTenant');

/**
 * Switch database schema for tenant-specific operations
 * @param {Object} tenant - The tenant object with id and slug
 */
async function switchToTenantSchema(tenant) {
  try {
    const pool = await getPool();
    await pool.query('SET search_path TO tenants, public');
    
    logger.info({
      event: 'schema_switched',
      tenantId: tenant.id,
      tenantSlug: tenant.slug,
      schema: 'tenants'
    }, 'Switched to tenant schema');
  } catch (error) {
    logger.error({
      event: 'schema_switch_error',
      tenantId: tenant.id,
      tenantSlug: tenant.slug,
      error: error.message
    }, 'Failed to switch to tenant schema');
    throw error;
  }
}

/**
 * withTenant Middleware
 * 
 * Provides tenant context to routes by:
 * 1. Looking up tenant by slug from URL params
 * 2. Looking up tenant by user_id for authenticated users
 * 3. Validating tenant exists and is approved
 * 4. Attaching tenant data to req.tenant
 * 5. Switching database schema to tenants schema
 * 
 * Usage:
 * - router.get('/:slug', withTenant, (req, res) => { ... })
 * - router.get('/user-data', authenticateToken, withTenant, (req, res) => { ... })
 */

/**
 * Get tenant by slug from URL parameters
 */
async function getTenantBySlug(slug) {
  const pool = await getPool();

  const query = `
    SELECT 
      b.id, b.slug, b.business_name, b.owner, b.first_name, b.last_name, b.user_id,
      b.application_status, b.business_start_date, b.business_phone, b.personal_phone,
      b.business_email, b.personal_email, b.twilio_phone, b.sms_phone, b.website,
      b.gbp_url, b.facebook_url, b.facebook_enabled, b.instagram_url, b.instagram_enabled, 
      b.tiktok_url, b.tiktok_enabled, b.youtube_url, b.youtube_enabled,
      b.source, b.notes, b.service_areas, b.application_date, b.approved_date,
      b.last_activity, b.created_at, b.updated_at, b.industry,
      c.hero_title, c.hero_subtitle, c.reviews_title, c.reviews_subtitle,
      c.faq_title, c.faq_subtitle, c.faq_items,
      c.seo_title, c.seo_description, c.seo_keywords, c.seo_og_image,
      c.seo_twitter_image, c.seo_canonical_path, c.seo_robots
    FROM tenants.business b
    LEFT JOIN website.content c ON b.id = c.business_id
    WHERE b.slug = $1 AND b.application_status = 'approved'
  `;

  const result = await pool.query(query, [slug]);

  if (result.rows.length === 0) {
    const error = new Error('Tenant not found or not approved');
    error.statusCode = 404;
    error.code = 'TENANT_NOT_FOUND';
    throw error;
  }

  const tenant = result.rows[0];

  // Parse service_areas JSON if it's a string
  if (typeof tenant.service_areas === 'string') {
    try {
      tenant.service_areas = JSON.parse(tenant.service_areas);
    } catch (parseError) {
      logger.error('Error parsing service_areas:', parseError);
      tenant.service_areas = [];
    }
  }

  return tenant;
}

/**
 * Get tenant by user_id for authenticated users
 */
async function getTenantByUserId(userId, isAdmin = false) {
  const pool = await getPool();

  let query;
  let params;

  if (isAdmin) {
    // For admin users, get the first available business or allow them to work without tenant context
    query = `
      SELECT 
        b.id, b.slug, b.business_name, b.owner, b.first_name, b.last_name, b.user_id,
        b.application_status, b.business_start_date, b.business_phone, b.personal_phone,
        b.business_email, b.personal_email, b.twilio_phone, b.sms_phone, b.website,
        b.gbp_url, b.facebook_url, b.facebook_enabled, b.instagram_url, b.instagram_enabled, 
      b.tiktok_url, b.tiktok_enabled, b.youtube_url, b.youtube_enabled,
        b.source, b.notes, b.service_areas, b.application_date, b.approved_date,
        b.last_activity, b.created_at, b.updated_at, b.industry,
        c.hero_title, c.hero_subtitle, c.reviews_title, c.reviews_subtitle,
        c.faq_title, c.faq_subtitle, c.faq_items,
        c.seo_title, c.seo_description, c.seo_keywords, c.seo_og_image,
        c.seo_twitter_image, c.seo_canonical_path, c.seo_robots
      FROM tenants.business b
      LEFT JOIN website.content c ON b.id = c.business_id
      WHERE b.application_status = 'approved'
      ORDER BY b.id LIMIT 1
    `;
    params = [];
  } else {
    // For regular users, get their specific business
    query = `
      SELECT 
        b.id, b.slug, b.business_name, b.owner, b.first_name, b.last_name, b.user_id,
        b.application_status, b.business_start_date, b.business_phone, b.personal_phone,
        b.business_email, b.personal_email, b.twilio_phone, b.sms_phone, b.website,
        b.gbp_url, b.facebook_url, b.facebook_enabled, b.instagram_url, b.instagram_enabled, 
      b.tiktok_url, b.tiktok_enabled, b.youtube_url, b.youtube_enabled,
        b.source, b.notes, b.service_areas, b.application_date, b.approved_date,
        b.last_activity, b.created_at, b.updated_at, b.industry,
        c.hero_title, c.hero_subtitle, c.reviews_title, c.reviews_subtitle,
        c.faq_title, c.faq_subtitle, c.faq_items,
        c.seo_title, c.seo_description, c.seo_keywords, c.seo_og_image,
        c.seo_twitter_image, c.seo_canonical_path, c.seo_robots
      FROM tenants.business b
      LEFT JOIN website.content c ON b.id = c.business_id
      WHERE b.user_id = $1 AND b.application_status = 'approved'
    `;
    params = [userId];
  }

  const result = await pool.query(query, params);

  if (result.rows.length === 0) {
    if (isAdmin) {
      const error = new Error('No approved tenants found in the system');
      error.statusCode = 404;
      error.code = 'NO_TENANTS_FOUND';
      throw error;
    } else {
      const error = new Error('No tenant business found for this user');
      error.statusCode = 404;
      error.code = 'USER_TENANT_NOT_FOUND';
      throw error;
    }
  }

  const tenant = result.rows[0];

  // Parse service_areas JSON if it's a string
  if (typeof tenant.service_areas === 'string') {
    try {
      tenant.service_areas = JSON.parse(tenant.service_areas);
    } catch (parseError) {
      logger.error('Error parsing service_areas:', parseError);
      tenant.service_areas = [];
    }
  }

  return tenant;
}

/**
 * Middleware to get tenant by slug from URL parameters
 */
const withTenantBySlug = asyncHandler(async (req, res, next) => {
  const { slug } = req.params;

  if (!slug) {
    const error = new Error('Tenant slug is required');
    error.statusCode = 400;
    error.code = 'MISSING_SLUG';
    throw error;
  }

  const businessRow = await getTenantBySlug(slug);
  
  // Use shared contract to attach tenant context
  attachTenantContext(req, businessRow, req.user);
  
  // Validate tenant context
  const validation = validateTenantContext(req.tenant);
  if (!validation.isValid) {
    return res.status(validation.error.statusCode).json({
      success: false,
      error: validation.error
    });
  }
  
  // Switch to tenant schema for subsequent operations
  await switchToTenantSchema(businessRow);
  
  next();
});

/**
 * Middleware to get tenant by user_id (requires authentication)
 */
const withTenantByUser = asyncHandler(async (req, res, next) => {
  if (!req.user || !req.user.userId) {
    const error = new Error('Authentication required');
    error.statusCode = 401;
    error.code = 'AUTHENTICATION_REQUIRED';
    throw error;
  }

  const isAdmin = req.user.isAdmin || false;
  const businessRow = await getTenantByUserId(req.user.userId, isAdmin);
  
  // Use shared contract to attach tenant context
  attachTenantContext(req, businessRow, req.user);
  
  // Validate tenant context
  const validation = validateTenantContext(req.tenant);
  if (!validation.isValid) {
    return res.status(validation.error.statusCode).json({
      success: false,
      error: validation.error
    });
  }
  
  // Switch to tenant schema for subsequent operations
  await switchToTenantSchema(businessRow);
  
  next();
});

/**
 * Flexible middleware that tries slug first, then user_id
 * Useful for routes that might be called with either approach
 */
const withTenant = asyncHandler(async (req, res, next) => {
  let businessRow = null;
  
  // Try slug first if available
  if (req.params.slug) {
    try {
      businessRow = await getTenantBySlug(req.params.slug);
    } catch (error) {
      // If slug lookup fails and we have a user, try user lookup
      if (req.user && req.user.userId) {
        const isAdmin = req.user.isAdmin || false;
        businessRow = await getTenantByUserId(req.user.userId, isAdmin);
      } else {
        // Otherwise, re-throw the slug error
        throw error;
      }
    }
  } else if (req.user && req.user.userId) {
    // Try user_id if no slug
    const isAdmin = req.user.isAdmin || false;
    businessRow = await getTenantByUserId(req.user.userId, isAdmin);
  } else {
    // No slug or user available
    const error = new Error('Tenant slug or authentication required');
    error.statusCode = 400;
    error.code = 'MISSING_TENANT_CONTEXT';
    throw error;
  }

  // Use shared contract to attach tenant context
  attachTenantContext(req, businessRow, req.user);
  
  // Validate tenant context
  const validation = validateTenantContext(req.tenant);
  if (!validation.isValid) {
    return res.status(validation.error.statusCode).json({
      success: false,
      error: validation.error
    });
  }
  
  // Switch to tenant schema for subsequent operations
  await switchToTenantSchema(businessRow);
  
  next();
});

/**
 * Middleware to validate tenant exists (lightweight check)
 * Only checks existence, doesn't load full tenant data
 */
const validateTenantExists = asyncHandler(async (req, res, next) => {
  const { slug } = req.params;

  if (!slug) {
    const error = new Error('Tenant slug is required');
    error.statusCode = 400;
    error.code = 'MISSING_SLUG';
    throw error;
  }

  const pool = await getPool();
  const result = await pool.query(
    'SELECT id, slug, business_name FROM tenants.business WHERE slug = $1 AND application_status = $2',
    [slug, 'approved']
  );

  if (result.rows.length === 0) {
    const error = new Error('Tenant not found or not approved');
    error.statusCode = 404;
    error.code = 'TENANT_NOT_FOUND';
    throw error;
  }

  req.tenant = {
    id: result.rows[0].id,
    slug: result.rows[0].slug,
    business_name: result.rows[0].business_name
  };

  next();
});

export {
  withTenantBySlug,
  withTenantByUser,
  withTenant,
  validateTenantExists,
  getTenantBySlug,
  getTenantByUserId
};


/*──────────────── backend\controllers\tenantController.js ────────────────*/

import * as tenantService from '../services/tenantService.js';
import { createModuleLogger } from '../config/logger.js';
const logger = createModuleLogger('tenantController');



/**
 * Tenant Controller
 * Handles HTTP requests and responses for tenant operations
 */

/**
 * Create new tenant account
 */
async function createTenant(req, res) {
  const tenantData = req.body;
  
  const result = await tenantService.createTenant(tenantData);
  
  // Log tenant creation for now (TODO: Send welcome email)
  logger.info('\n=== NEW TENANT SIGNUP ===');
  logger.info(`Business: ${tenantData.businessName}`);
  logger.info(`Owner: ${tenantData.firstName} ${tenantData.lastName}`);
  logger.info(`Email: ${tenantData.personalEmail}`);
  logger.info(`Slug: ${result.slug}`);
  logger.info(`Website URL: ${process.env.FRONTEND_URL || 'http://localhost:5173'}${result.websiteUrl}`);
  logger.info(`Dashboard URL: ${process.env.FRONTEND_URL || 'http://localhost:5173'}${result.dashboardUrl}`);
  logger.info(`Plan: ${tenantData.selectedPlan} ($${tenantData.planPrice}/month)`);
  logger.info('========================\n');

  res.status(201).json({
    success: true,
    message: 'Account created successfully',
    data: result
  });
}

/**
 * Get tenant by slug
 */
async function getTenantBySlug(req, res) {
  const { slug } = req.params;
  
  const tenant = await tenantService.getTenantBySlug(slug);
  
  if (!tenant) {
    return res.status(404).json({
      success: false,
      error: 'Tenant not found or not approved'
    });
  }
  
  res.json({
    success: true,
    data: tenant
  });
}

/**
 * Get tenants by industry
 */
async function getTenantsByIndustry(req, res) {
  const { industry, status = 'approved' } = req.query;
  
  const tenants = await tenantService.getTenantsByIndustry(industry, status);
  
  res.json({
    success: true,
    data: tenants
  });
}

/**
 * Update tenant business data by slug
 */
async function updateTenantBySlug(req, res) {
  const { slug } = req.params;
  const updateData = req.body;
  
  try {
    const updatedTenant = await tenantService.updateTenantBySlug(slug, updateData);
    
    res.json({
      success: true,
      data: updatedTenant,
      message: 'Business profile updated successfully'
    });
  } catch (error) {
    logger.error('Error updating tenant:', error);
    
    if (error.message === 'Tenant not found or not approved') {
      return res.status(404).json({
        success: false,
        error: 'Tenant not found or not approved'
      });
    }
    
    if (error.message === 'No valid fields to update') {
      return res.status(400).json({
        success: false,
        error: 'No valid fields to update'
      });
    }
    
    res.status(500).json({
      success: false,
      error: 'Failed to update business profile',
      message: error.message
    });
  }
}

/**
 * Get list of available industries
 */
async function getIndustries(req, res) {
  const industries = await tenantService.getIndustries();
  
  res.json({
    success: true,
    data: industries
  });
}

export {
  createTenant,
  getTenantBySlug,
  getTenantsByIndustry,
  getIndustries,
  updateTenantBySlug
};


/*──────────────── frontend\src\admin-app\AdminApp.tsx ────────────────*/

import { Suspense } from 'react';
import { Navigate, Route, Routes } from 'react-router-dom';

import { DashboardPage as AdminDashboard } from './components/adminDashboard';
import { PreviewGeneratorPage, PreviewPage } from '@/admin-app/components/preview';
import { LoginPage, ProtectedRoute } from '@/shared/ui';
import { SEOManager } from '@/shared/bootstrap';

export default function AdminApp() {
  const routes = (
    <Suspense fallback={<div className="p-8 text-white">Loading…</div>}>
      <Routes>
        {/* Admin Dashboard - redirect root to admin dashboard */}
        <Route path="/" element={<Navigate to="/admin-dashboard" replace />} />
        
        {/* Login route */}
        <Route path="/login" element={<LoginPage />} />
        
        {/* Admin Dashboard - protected route */}
        <Route path="/admin-dashboard" element={
          <ProtectedRoute requiredRole="admin" fallbackPath="/login">
            <AdminDashboard />
          </ProtectedRoute>
        } />
        
        {/* Preview routes */}
        <Route path="/preview-generator" element={<PreviewGeneratorPage />} />
        <Route path="/preview/:tenantSlug" element={<PreviewPage />} />
        
        {/* Catch all - redirect to admin dashboard */}
        <Route path="*" element={<Navigate to="/admin-dashboard" replace />} />
      </Routes>
    </Suspense>
  );

  return (
    <div className="min-h-screen bg-gray-900">
      <SEOManager />
      {routes}
    </div>
  );
}


/*──────────────── frontend\src\main-site\MainSiteApp.tsx ────────────────*/

import React, { useEffect } from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';

import { HomePage } from './routes/HomePage';
import { LoginPage } from './routes/LoginPage';
import { TenantOnboardingPage } from './routes/TenantOnboardingPage';
import { PricingPage } from './routes/PricingPage';

// Admin redirect component
function AdminRedirect() {
  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center">
      <div className="text-center max-w-md mx-auto p-8">
        <div className="bg-blue-100 w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-6">
          <span className="text-2xl">🔐</span>
        </div>
        <h1 className="text-2xl font-bold text-gray-900 mb-4">
          Admin Access
        </h1>
        <p className="text-gray-600 mb-6">
          To access the admin panel, you need to start the admin app separately.
        </p>
        <div className="bg-white rounded-lg p-4 mb-6 text-left">
          <h3 className="font-semibold text-gray-900 mb-2">Development Setup:</h3>
          <ol className="text-sm text-gray-600 space-y-1">
            <li>1. Open a new terminal</li>
            <li>2. Run: <code className="bg-gray-100 px-2 py-1 rounded">npm run dev:admin</code></li>
            <li>3. Visit: <code className="bg-gray-100 px-2 py-1 rounded">http://localhost:5177</code></li>
          </ol>
        </div>
        <div className="space-y-3">
          <a 
            href="http://localhost:5177" 
            target="_blank"
            rel="noopener noreferrer"
            className="block bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition-colors"
          >
            Open Admin Panel
          </a>
          <a 
            href="/" 
            className="block text-blue-600 hover:text-blue-500 font-medium"
          >
            ← Back to Home
          </a>
        </div>
      </div>
    </div>
  );
}

export default function MainSiteApp() {
  return (
    <div className="min-h-screen bg-white">
      <Routes>
        {/* Root path - marketing homepage */}
        <Route path="/" element={<HomePage />} />
        
        {/* Authentication */}
        <Route path="/login" element={<LoginPage />} />
        
        {/* Tenant onboarding */}
        <Route path="/onboard" element={<TenantOnboardingPage />} />
        
        {/* Marketing pages */}
        <Route path="/pricing" element={<PricingPage />} />
        
        {/* Admin redirect */}
        <Route path="/admin" element={<AdminRedirect />} />
        
        {/* Catch all - redirect to home */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </div>
  );
}

/*──────────────── frontend\src\tenant-app\TenantApp.tsx ────────────────*/

import { lazy, Suspense, useState } from 'react';
import { Navigate, Route, Routes } from 'react-router-dom';
import { useRouterDebug } from '@/shared/useRouterDebug';

import { DataProvider, TenantPage } from '@/tenant-app/components/header';
import { LazyRequestQuoteModal } from '@/tenant-app/components/quotes';
import { DashboardPage } from '@/tenant-app/components/tenantDashboard';
import TenantApplicationPage from '@/admin-app/components/tenantOnboarding/components/TenantApplicationPage';
import { LoginPage, ProtectedRoute } from '@/shared/ui';
import { SEOManager } from '@/shared/bootstrap';

import HomePage from '@main/pages/HomePage';
import ServicePage from '@main/pages/ServicePage';

// Heavy modules are NOT imported here - they stay out of the initial bundle
const Booking = lazy(() => import('./components/booking/BookingApp'));


export default function TenantApp() {
  useRouterDebug('TenantApp');
  const [isQuoteModalOpen, setIsQuoteModalOpen] = useState(false);

  const handleOpenQuoteModal = () => {
    setIsQuoteModalOpen(true);
  };
  const handleCloseQuoteModal = () => {
    setIsQuoteModalOpen(false);
  };

  const routes = (
    <Suspense fallback={<div className="p-8 text-white">Loading…</div>}>
      <Routes>
        {/* Root path - show tenant page */}
        <Route path="/" element={<TenantPage />} />
        
        {/* Login route */}
        <Route path="/login" element={<LoginPage />} />
        
        {/* Tenant Dashboard - protected route */}
        <Route path="/dashboard" element={
          <ProtectedRoute requiredRole={['admin', 'tenant']} fallbackPath="/">
            <DashboardPage />
          </ProtectedRoute>
        } />
        
        {/* Tenant Application */}
        <Route path="/tenant-onboarding" element={<TenantApplicationPage />} />
        
        {/* Booking route */}
        <Route path="/booking" element={<Booking />} />
        
        {/* Redirect old service routes to tenant-based structure */}
        <Route path="/services/:serviceType" element={<Navigate to="/services/:serviceType" replace />} />
        
        {/* Service routes - must come before generic businessSlug route */}
        <Route path="/:businessSlug/services/:serviceType" element={<ServicePage />} />
        
        <Route path="/:businessSlug/dashboard" element={
          <div style={{ padding: '20px', background: 'red', color: 'white' }}>
            <h1>DASHBOARD ROUTE MATCHED!</h1>
            <p>Business Slug: {window.location.pathname.split('/')[1]}</p>
            <ProtectedRoute requiredRole={['admin', 'tenant']} fallbackPath="/">
                <DashboardPage />
            </ProtectedRoute>
          </div>
        } />
        <Route path="/:businessSlug/booking" element={<Booking />} />
        
        {/* Tenant-specific routes */}
        <Route path="/:businessSlug" element={<HomePage />} />
        
        {/* Catch all - redirect to root */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </Suspense>
  );

  return (
    <div className="min-h-screen bg-gray-900">
      <SEOManager />
      {routes}
      
      {/* Quote Modal */}
      <LazyRequestQuoteModal 
        isOpen={isQuoteModalOpen}
        onClose={handleCloseQuoteModal}
      />
    </div>
  );
}


/*──────────────── backend\middleware\errorHandler.js ────────────────*/

/**
 * Error Handling Middleware
 * Provides centralized error handling for the application
 */

import logger from '../utils/logger.js';
import { ValidationError } from '../utils/validators.js';
import { errorMonitor } from '../utils/errorMonitor.js';
import { sendError, sendValidationError, sendNotFound } from '../utils/responseFormatter.js';

/**
 * Error handler middleware
 * Must be the last middleware in the chain
 */
const errorHandler = (err, req, res, next) => {
  // If headers already sent, delegate to default Express handler to avoid double-send
  if (res.headersSent) {
    return next(err);
  }
  // Log the error
  logger.error('Unhandled error:', {
    error: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip || req.connection.remoteAddress,
    userAgent: req.get('User-Agent')
  });

  // Capture error in our monitoring system
  errorMonitor.captureRequestError(req, res, err);

  // Handle validation errors
  if (err instanceof ValidationError) {
    return sendValidationError(res, 'Validation failed', [{
      field: err.field,
      message: err.message,
      value: err.value
    }]);
  }

  // Handle Zod validation errors
  if (err.code === 'VALIDATION_ERROR' || err.code === 'SANITIZATION_ERROR') {
    return sendValidationError(res, err.message, err.details || []);
  }

  // Handle database connection errors
  if (err.code === 'ECONNREFUSED' || err.code === 'ENOTFOUND') {
    return sendError(res, 'Database service unavailable', err.code, 503);
  }

  // Handle database constraint violations
  if (err.code === '23505') { // Unique violation
    return sendError(res, 'A record with this information already exists', 'Duplicate entry', 409);
  }

  if (err.code === '23503') { // Foreign key violation
    return sendError(res, 'Referenced record does not exist', 'Invalid reference', 400);
  }

  if (err.code === '23514') { // Check violation
    return sendError(res, 'Data does not meet requirements', 'Invalid data', 400);
  }

  // Handle JWT errors
  if (err.name === 'JsonWebTokenError') {
    return sendError(res, 'Authentication token is invalid', 'Invalid token', 401);
  }

  if (err.name === 'TokenExpiredError') {
    return sendError(res, 'Authentication token has expired', 'Token expired', 401);
  }

  // Handle rate limiting errors
  if (err.status === 429) {
    return sendError(res, 'Please try again later', 'Too many requests', 429);
  }

  // Handle request size errors
  if (err.status === 413) {
    return sendError(res, 'Request body exceeds size limit', 'Request too large', 413);
  }

  // Handle syntax errors in JSON
  if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
    return sendError(res, 'Request body contains invalid JSON', 'Invalid JSON', 400);
  }

  // Handle multer file upload errors
  if (err.code === 'LIMIT_FILE_SIZE') {
    return sendError(res, 'Uploaded file exceeds size limit', 'File too large', 413);
  }

  if (err.code === 'LIMIT_FILE_COUNT') {
    return sendError(res, 'Too many files uploaded', 'Too many files', 413);
  }

  if (err.code === 'LIMIT_UNEXPECTED_FILE') {
    return sendError(res, 'Unexpected file field in upload', 'Unexpected file field', 400);
  }

  // Handle custom upload validation errors
  if (err.statusCode === 415) {
    return sendError(res, err.message || 'File type not supported', 'Unsupported media type', 415);
  }

  if (err.statusCode === 413) {
    return sendError(res, err.message || 'Upload exceeds size limits', 'Request entity too large', 413);
  }

  // Handle generic database errors
  if (err.code && err.code.startsWith('23')) {
    return sendError(res, 'Invalid data provided', 'Database error', 400);
  }

  // Handle generic server errors
  if (err.status) {
    return sendError(res, err.message || 'Server error', null, err.status);
  }

  // Default error response
  const statusCode = err.statusCode || 500;
  const message = process.env.NODE_ENV === 'production' ? 'Something went wrong' : (err.message || 'Internal server error');
  
  return sendError(res, message, 'Server error', statusCode);
};

/**
 * 404 handler for unmatched routes
 */
const notFoundHandler = (req, res) => {
  logger.warn('Route not found:', {
    url: req.url,
    method: req.method,
    ip: req.ip || req.connection.remoteAddress
  });

  return sendNotFound(res, `Route ${req.method} ${req.url} not found`);
};

/**
 * Async error wrapper
 * Wraps async route handlers to catch errors
 */
const asyncHandler = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

export {
  errorHandler,
  notFoundHandler,
  asyncHandler
};
