#!/usr/bin/env node

/**
 * Generate TypeScript Database Types from Schema Snapshot
 * 
 * Reads: backend/schemas/current-schema.json
 * Writes: frontend/src/shared/types/generated/db.types.ts
 * 
 * This script automatically generates TypeScript interfaces for all database tables.
 * The generated types are the single source of truth for database structure in TypeScript.
 * 
 * Usage:
 *   node scripts/devtools/generate-db-types.js
 *   npm run migrate (automatically runs this after migrations)
 * 
 * Note: This script is part of the migration pipeline and runs automatically.
 *       The generated file should NOT be edited manually.
 */

import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import chalk from 'chalk';

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = join(__dirname, '../..');
const snapshotPath = join(rootDir, 'backend/schemas/generated/current-schema.json');
const outputPath = join(rootDir, 'frontend/src/shared/types/generated/db.types.ts');

/**
 * Map PostgreSQL types to TypeScript types
 */
function postgresTypeToTS(pgType) {
  const typeMap = {
    // Integer types
    'integer': 'number',
    'bigint': 'number',
    'smallint': 'number',
    'serial': 'number',
    'bigserial': 'number',
    
    // Numeric types
    'numeric': 'number',
    'decimal': 'number',
    'real': 'number',
    'double precision': 'number',
    'money': 'number',
    
    // String types
    'character varying': 'string',
    'varchar': 'string',
    'character': 'string',
    'char': 'string',
    'text': 'string',
    
    // Boolean
    'boolean': 'boolean',
    
    // Date/Time types (stored as ISO strings in JSON)
    'timestamp with time zone': 'string',
    'timestamp without time zone': 'string',
    'timestamptz': 'string',
    'timestamp': 'string',
    'date': 'string',
    'time': 'string',
    'time with time zone': 'string',
    'time without time zone': 'string',
    'interval': 'string',
    
    // JSON types
    'jsonb': 'Record<string, unknown>',
    'json': 'Record<string, unknown>',
    
    // UUID
    'uuid': 'string',
    
    // Array types
    'ARRAY': 'unknown[]',
    
    // Binary
    'bytea': 'Buffer',
    
    // Network types
    'inet': 'string',
    'cidr': 'string',
    'macaddr': 'string',
  };
  
  return typeMap[pgType.toLowerCase()] || 'unknown';
}

/**
 * Convert snake_case table name to PascalCase interface name
 */
function tableNameToInterface(tableName) {
  return tableName
    .split('_')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

/**
 * Generate a TypeScript interface for a database table
 */
function generateInterface(schemaName, tableName, columns) {
  const interfaceName = tableNameToInterface(tableName);
  
  let code = `/**\n`;
  code += ` * Database table: ${schemaName}.${tableName}\n`;
  code += ` * Auto-generated from database schema\n`;
  code += ` */\n`;
  code += `export interface ${interfaceName} {\n`;
  
  for (const col of columns) {
    const tsType = postgresTypeToTS(col.type);
    const optional = col.nullable ? '?' : '';
    
    // Add JSDoc comment if there's a default value
    if (col.default) {
      code += `  /** Default: ${col.default} */\n`;
    }
    
    code += `  ${col.name}${optional}: ${tsType};\n`;
  }
  
  code += '}\n\n';
  return code;
}

/**
 * Main generation function
 */
async function generateTypes() {
  console.log(chalk.blue.bold('\nüîß Generating TypeScript Database Types\n'));
  
  // Check if snapshot exists
  if (!existsSync(snapshotPath)) {
    console.error(chalk.red('‚ùå Schema snapshot not found:'), snapshotPath);
    console.error(chalk.yellow('üí° Run "npm run db:snapshot" first to generate the schema snapshot'));
    process.exit(1);
  }
  
  // Read snapshot
  let snapshot;
  try {
    const snapshotContent = readFileSync(snapshotPath, 'utf-8');
    snapshot = JSON.parse(snapshotContent);
    console.log(chalk.green('‚úÖ Loaded schema snapshot'));
  } catch (error) {
    console.error(chalk.red('‚ùå Failed to read schema snapshot:'), error.message);
    process.exit(1);
  }
  
  // Generate TypeScript code
  let output = `/**
 * AUTO-GENERATED DATABASE TYPES
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * 
 * This file is automatically generated from the database schema.
 * 
 * Source: backend/schemas/current-schema.json
 * Generated: ${new Date().toISOString()}
 * Database: ${snapshot.database_version ? snapshot.database_version.split(',')[0] : 'Unknown'}
 * 
 * To regenerate:
 *   npm run migrate        (runs migrations + generates types)
 *   npm run db:snapshot    (updates snapshot + generates types)
 * 
 * These types represent the raw database structure.
 * For API validation, see: backend/schemas/apiSchemas.js
 */

/* eslint-disable @typescript-eslint/no-explicit-any */

`;

  let totalTables = 0;
  let totalInterfaces = 0;
  
  // Generate types for each schema
  const schemaNames = Object.keys(snapshot.schemas).sort();
  
  for (const schemaName of schemaNames) {
    const schema = snapshot.schemas[schemaName];
    const tables = schema.tables || [];
    
    if (tables.length === 0) continue;
    
    output += `// ================================================================\n`;
    output += `// Schema: ${schemaName}\n`;
    output += `// ================================================================\n\n`;
    
    totalTables += tables.length;
    
    for (const table of tables) {
      output += generateInterface(schemaName, table.name, table.columns);
      totalInterfaces++;
    }
  }
  
  // Add helpful type exports at the end
  output += `// ================================================================\n`;
  output += `// Type Utilities\n`;
  output += `// ================================================================\n\n`;
  output += `/**\n`;
  output += ` * Helper type: Make all properties of T optional (for UPDATE operations)\n`;
  output += ` */\n`;
  output += `export type Partial<T> = {\n`;
  output += `  [P in keyof T]?: T[P];\n`;
  output += `};\n\n`;
  output += `/**\n`;
  output += ` * Helper type: Omit certain keys from T (for INSERT operations without auto-generated fields)\n`;
  output += ` */\n`;
  output += `export type Omit<T, K extends keyof T> = {\n`;
  output += `  [P in Exclude<keyof T, K>]: T[P];\n`;
  output += `};\n`;
  
  // Create output directory if it doesn't exist
  const outputDir = dirname(outputPath);
  mkdirSync(outputDir, { recursive: true });
  
  // Write the generated types
  try {
    writeFileSync(outputPath, output, 'utf-8');
    console.log(chalk.green.bold('\n‚úÖ TypeScript types generated successfully!'));
    console.log(chalk.gray(`   Location: ${outputPath}`));
    console.log(chalk.gray(`   Schemas: ${schemaNames.length}`));
    console.log(chalk.gray(`   Tables: ${totalTables}`));
    console.log(chalk.gray(`   Interfaces: ${totalInterfaces}`));
    console.log(chalk.blue('\nüì¶ Import in your code:'));
    console.log(chalk.cyan(`   import type { Business, Review } from '@/shared/types/generated/db.types';`));
  } catch (error) {
    console.error(chalk.red('\n‚ùå Failed to write types file:'), error.message);
    process.exit(1);
  }
}

// Run the generator
generateTypes().catch(error => {
  console.error(chalk.red('‚ùå Type generation failed:'), error);
  process.exit(1);
});

