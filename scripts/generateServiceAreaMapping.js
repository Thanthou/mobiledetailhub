#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// State abbreviation to full name mapping
const STATE_MAPPING = {
  'AL': 'Alabama',
  'AK': 'Alaska',
  'AZ': 'Arizona',
  'AR': 'Arkansas',
  'CA': 'California',
  'CO': 'Colorado',
  'CT': 'Connecticut',
  'DE': 'Delaware',
  'FL': 'Florida',
  'GA': 'Georgia',
  'HI': 'Hawaii',
  'ID': 'Idaho',
  'IL': 'Illinois',
  'IN': 'Indiana',
  'IA': 'Iowa',
  'KS': 'Kansas',
  'KY': 'Kentucky',
  'LA': 'Louisiana',
  'ME': 'Maine',
  'MD': 'Maryland',
  'MA': 'Massachusetts',
  'MI': 'Michigan',
  'MN': 'Minnesota',
  'MS': 'Mississippi',
  'MO': 'Missouri',
  'MT': 'Montana',
  'NE': 'Nebraska',
  'NV': 'Nevada',
  'NH': 'New Hampshire',
  'NJ': 'New Jersey',
  'NM': 'New Mexico',
  'NY': 'New York',
  'NC': 'North Carolina',
  'ND': 'North Dakota',
  'OH': 'Ohio',
  'OK': 'Oklahoma',
  'OR': 'Oregon',
  'PA': 'Pennsylvania',
  'RI': 'Rhode Island',
  'SC': 'South Carolina',
  'SD': 'South Dakota',
  'TN': 'Tennessee',
  'TX': 'Texas',
  'UT': 'Utah',
  'VT': 'Vermont',
  'VA': 'Virginia',
  'WA': 'Washington',
  'WV': 'West Virginia',
  'WI': 'Wisconsin',
  'WY': 'Wyoming'
};

function extractStateCitiesFromConfig(configPath, businessSlug) {
  try {
    const config = require(configPath);
    const stateCities = {};

    if (config.serviceLocations && Array.isArray(config.serviceLocations)) {
      config.serviceLocations.forEach(location => {
        // Extract state and city from "City, ST" format
        const locationMatch = location.match(/^(.+?),\s*([A-Z]{2})$/);
        if (locationMatch) {
          const city = locationMatch[1].trim();
          const state = locationMatch[2];
          const fullStateName = STATE_MAPPING[state] || state;

          if (!stateCities[fullStateName]) {
            stateCities[fullStateName] = {};
          }
          if (!stateCities[fullStateName][city]) {
            stateCities[fullStateName][city] = [];
          }
          stateCities[fullStateName][city].push(businessSlug);
        } else {
          console.warn(`âš ï¸  Skipping unrecognized location format in ${businessSlug}: '${location}' (expected 'City, ST')`);
        }
      });
    }

    return stateCities;
  } catch (error) {
    console.error(`Error reading config from ${configPath}:`, error.message);
    return {};
  }
}

function generateServiceAreaMapping() {
  const businessesDir = path.join(__dirname, '..', 'businesses');
  const outputPath = path.join(__dirname, '..', 'shared', 'utils', 'serviceAreaMapping.ts');

  // Get all business directories, excluding 'mdh'
  const businessDirs = fs.readdirSync(businessesDir)
    .filter(dir => {
      const fullPath = path.join(businessesDir, dir);
      return fs.statSync(fullPath).isDirectory() && dir !== 'mdh';
    });

  // Extract stateCities from each business config
  const allStateCities = {};

  businessDirs.forEach(businessDir => {
    const configPath = path.join(businessesDir, businessDir, 'config.js');
    if (fs.existsSync(configPath)) {
      const stateCities = extractStateCitiesFromConfig(configPath, businessDir);
      // Merge into global stateCities
      Object.keys(stateCities).forEach(state => {
        if (!allStateCities[state]) {
          allStateCities[state] = {};
        }
        Object.keys(stateCities[state]).forEach(city => {
          if (!allStateCities[state][city]) {
            allStateCities[state][city] = [];
          }
          allStateCities[state][city].push(...stateCities[state][city]);
        });
      });
    }
  });

  // Remove duplicates and sort slugs for each city
  Object.keys(allStateCities).forEach(state => {
    Object.keys(allStateCities[state]).forEach(city => {
      allStateCities[state][city] = [...new Set(allStateCities[state][city])].sort();
    });
  });

  // Sort states and cities
  const sortedStates = Object.keys(allStateCities).sort();
  const sortedStateCities = {};
  sortedStates.forEach(state => {
    const cities = Object.keys(allStateCities[state]).sort();
    sortedStateCities[state] = {};
    cities.forEach(city => {
      sortedStateCities[state][city] = allStateCities[state][city];
    });
  });

  // Generate the TypeScript file content
  const fileContent = `// Service Area Mapping - Auto-generated from business configs\n// This file is generated by scripts/generateServiceAreaMapping.js\n// Do not edit directly.\n\nexport interface StateCitiesMapping {\n  [state: string]: {\n    [city: string]: string[]; // Array of business slugs that serve this city\n  };\n}\n\n// State abbreviation to full name mapping\nexport const STATE_MAPPING: { [abbr: string]: string } = ${JSON.stringify(STATE_MAPPING, null, 2)};\n\n// State to city to business slugs mapping\nexport const STATE_CITIES_MAPPING: StateCitiesMapping = ${JSON.stringify(sortedStateCities, null, 2)};\n\n// Utility functions\nexport const getStates = (): string[] => {\n  return Object.keys(STATE_CITIES_MAPPING).sort();\n};\n\nexport const getCitiesForState = (state: string): string[] => {\n  return STATE_CITIES_MAPPING[state] ? Object.keys(STATE_CITIES_MAPPING[state]).sort() : [];\n};\n\nexport const getBusinessesForCity = (state: string, city: string): string[] => {\n  return STATE_CITIES_MAPPING[state] && STATE_CITIES_MAPPING[state][city]\n    ? STATE_CITIES_MAPPING[state][city]\n    : [];\n};\n\nexport const isCityServedByBusiness = (state: string, city: string, businessSlug: string): boolean => {\n  return getBusinessesForCity(state, city).includes(businessSlug);\n};\n`;

  // Write the generated file
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, fileContent, 'utf8');

  console.log('\nâœ… Service area mapping generated successfully!');
  console.log(`ğŸ“ Generated mapping for ${sortedStates.length} states`);
  console.log(`ğŸ™ï¸  State-to-cities mapping with ${Object.keys(sortedStateCities).length} states`);
  let totalCities = 0;
  Object.values(sortedStateCities).forEach(citiesObj => {
    totalCities += Object.keys(citiesObj).length;
  });
  console.log(`ğŸ¢  Total cities mapped: ${totalCities}`);
  console.log(`ğŸ“ Output file: ${outputPath}`);
}

// Run the script
if (require.main === module) {
  generateServiceAreaMapping();
}

module.exports = { generateServiceAreaMapping };
